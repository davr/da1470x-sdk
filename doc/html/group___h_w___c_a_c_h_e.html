<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: iCache Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iCache Controller<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___d_r_i_v_e_r_s.html">Drivers</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___m_e_m_o_r_y.html">Memory Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>iCache Controller LLD common API  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__cache_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__cache_8h.html">hw_cache.h</a></td></tr>
<tr class="memdesc:hw__cache_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the iCache Controller Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hw__cache__da1470x_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__cache__da1470x_8h.html">hw_cache_da1470x.h</a></td></tr>
<tr class="memdesc:hw__cache__da1470x_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of DA1470x specific API for the iCache Controller Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5629c89852d71dd11da8dba6c80e7eab"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">hw_cache_mrm_cb_t</a>) (void)</td></tr>
<tr class="memdesc:ga5629c89852d71dd11da8dba6c80e7eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application defined callback for the MRM interrupt.  <a href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">More...</a><br /></td></tr>
<tr class="separator:ga5629c89852d71dd11da8dba6c80e7eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac5db731d4daed45ab6570f2d979457dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> </td></tr>
<tr class="memdesc:gac5db731d4daed45ab6570f2d979457dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cacheable flash Region Sizes as defined in DA1470x datasheet.  <a href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">More...</a><br /></td></tr>
<tr class="separator:gac5db731d4daed45ab6570f2d979457dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga15c6ac9e2869e341c338f036edbb894b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga15c6ac9e2869e341c338f036edbb894b">hw_cache_mrm_set_misses_thres</a> (uint32_t thres)</td></tr>
<tr class="memdesc:ga15c6ac9e2869e341c338f036edbb894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM interrupt threshold for misses.  <a href="group___h_w___c_a_c_h_e.html#ga15c6ac9e2869e341c338f036edbb894b">More...</a><br /></td></tr>
<tr class="separator:ga15c6ac9e2869e341c338f036edbb894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042acf2dd528d343409f2458fb59eb7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaa042acf2dd528d343409f2458fb59eb7">hw_cache_mrm_get_misses_thres</a> (void)</td></tr>
<tr class="memdesc:gaa042acf2dd528d343409f2458fb59eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM interrupt threshold for misses.  <a href="group___h_w___c_a_c_h_e.html#gaa042acf2dd528d343409f2458fb59eb7">More...</a><br /></td></tr>
<tr class="separator:gaa042acf2dd528d343409f2458fb59eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab50dd16bc01c517e505c0bc4a66b60e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaab50dd16bc01c517e505c0bc4a66b60e">hw_cache_mrm_set_hits_thres</a> (uint32_t thres)</td></tr>
<tr class="memdesc:gaab50dd16bc01c517e505c0bc4a66b60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM interrupt threshold for hits.  <a href="group___h_w___c_a_c_h_e.html#gaab50dd16bc01c517e505c0bc4a66b60e">More...</a><br /></td></tr>
<tr class="separator:gaab50dd16bc01c517e505c0bc4a66b60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece12257a8c6f3cb3699f7661378842f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaece12257a8c6f3cb3699f7661378842f">hw_cache_mrm_get_hits_thres</a> (void)</td></tr>
<tr class="memdesc:gaece12257a8c6f3cb3699f7661378842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM interrupt threshold for hits.  <a href="group___h_w___c_a_c_h_e.html#gaece12257a8c6f3cb3699f7661378842f">More...</a><br /></td></tr>
<tr class="separator:gaece12257a8c6f3cb3699f7661378842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f877bb6a3bb3999c6229ebaaf9680e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga02f877bb6a3bb3999c6229ebaaf9680e">hw_cache_mrm_get_misses_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga02f877bb6a3bb3999c6229ebaaf9680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM misses threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga02f877bb6a3bb3999c6229ebaaf9680e">More...</a><br /></td></tr>
<tr class="separator:ga02f877bb6a3bb3999c6229ebaaf9680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18af98472de537f4af4496fa34412e6d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga18af98472de537f4af4496fa34412e6d">hw_cache_mrm_clr_misses_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga18af98472de537f4af4496fa34412e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cache MRM misses threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga18af98472de537f4af4496fa34412e6d">More...</a><br /></td></tr>
<tr class="separator:ga18af98472de537f4af4496fa34412e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d269a059a7ac36dcc93c9c3aa53047"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga89d269a059a7ac36dcc93c9c3aa53047">hw_cache_mrm_get_hits_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga89d269a059a7ac36dcc93c9c3aa53047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM hits threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga89d269a059a7ac36dcc93c9c3aa53047">More...</a><br /></td></tr>
<tr class="separator:ga89d269a059a7ac36dcc93c9c3aa53047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga7a6fc6d13aa50fd8fdbfee60ce64f3dc">hw_cache_mrm_clr_hits_thres_status</a> (void)</td></tr>
<tr class="memdesc:ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cache MRM hits threshold IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga7a6fc6d13aa50fd8fdbfee60ce64f3dc">More...</a><br /></td></tr>
<tr class="separator:ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50baaa9ef1a4bb9bbe7832986fda9585"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga50baaa9ef1a4bb9bbe7832986fda9585">hw_cache_mrm_set_tint</a> (uint32_t tint)</td></tr>
<tr class="memdesc:ga50baaa9ef1a4bb9bbe7832986fda9585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM monitoring time interval.  <a href="group___h_w___c_a_c_h_e.html#ga50baaa9ef1a4bb9bbe7832986fda9585">More...</a><br /></td></tr>
<tr class="separator:ga50baaa9ef1a4bb9bbe7832986fda9585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0470d2492f249a0bf97743081fee47c0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga0470d2492f249a0bf97743081fee47c0">hw_cache_mrm_get_tint</a> (void)</td></tr>
<tr class="memdesc:ga0470d2492f249a0bf97743081fee47c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM monitoring time interval.  <a href="group___h_w___c_a_c_h_e.html#ga0470d2492f249a0bf97743081fee47c0">More...</a><br /></td></tr>
<tr class="separator:ga0470d2492f249a0bf97743081fee47c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d63128c10cd15f37d7b829ce2c9a15"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga57d63128c10cd15f37d7b829ce2c9a15">hw_cache_mrm_get_tint_status</a> (void)</td></tr>
<tr class="memdesc:ga57d63128c10cd15f37d7b829ce2c9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM timer interval IRQ status.  <a href="group___h_w___c_a_c_h_e.html#ga57d63128c10cd15f37d7b829ce2c9a15">More...</a><br /></td></tr>
<tr class="separator:ga57d63128c10cd15f37d7b829ce2c9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffbce6fba4487f7c77dc8fb24dae36c8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaffbce6fba4487f7c77dc8fb24dae36c8">hw_cache_mrm_clr_tint_status</a> (void)</td></tr>
<tr class="memdesc:gaffbce6fba4487f7c77dc8fb24dae36c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the cache MRM timer interval IRQ status.  <a href="group___h_w___c_a_c_h_e.html#gaffbce6fba4487f7c77dc8fb24dae36c8">More...</a><br /></td></tr>
<tr class="separator:gaffbce6fba4487f7c77dc8fb24dae36c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d33383047222cc93669b3db989642e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga07d33383047222cc93669b3db989642e">hw_cache_mrm_start_counters</a> (void)</td></tr>
<tr class="memdesc:ga07d33383047222cc93669b3db989642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start MRM counters.  <a href="group___h_w___c_a_c_h_e.html#ga07d33383047222cc93669b3db989642e">More...</a><br /></td></tr>
<tr class="separator:ga07d33383047222cc93669b3db989642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a52e77bc6d5eb104910df4ff02e202c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga2a52e77bc6d5eb104910df4ff02e202c">hw_cache_mrm_freeze_counters</a> (void)</td></tr>
<tr class="memdesc:ga2a52e77bc6d5eb104910df4ff02e202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freeze MRM counters.  <a href="group___h_w___c_a_c_h_e.html#ga2a52e77bc6d5eb104910df4ff02e202c">More...</a><br /></td></tr>
<tr class="separator:ga2a52e77bc6d5eb104910df4ff02e202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1515565552194cea562af1fd4b7d1afa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga1515565552194cea562af1fd4b7d1afa">hw_cache_mrm_get_misses</a> (void)</td></tr>
<tr class="memdesc:ga1515565552194cea562af1fd4b7d1afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM misses number.  <a href="group___h_w___c_a_c_h_e.html#ga1515565552194cea562af1fd4b7d1afa">More...</a><br /></td></tr>
<tr class="separator:ga1515565552194cea562af1fd4b7d1afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9a24961355cdee7e3279dc8989645a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gabf9a24961355cdee7e3279dc8989645a">hw_cache_mrm_set_misses</a> (uint32_t misses)</td></tr>
<tr class="memdesc:gabf9a24961355cdee7e3279dc8989645a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM cache misses number.  <a href="group___h_w___c_a_c_h_e.html#gabf9a24961355cdee7e3279dc8989645a">More...</a><br /></td></tr>
<tr class="separator:gabf9a24961355cdee7e3279dc8989645a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3d5651fb23ce09f7d5b87fac9b3284"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga0d3d5651fb23ce09f7d5b87fac9b3284">hw_cache_mrm_get_hits</a> (void)</td></tr>
<tr class="memdesc:ga0d3d5651fb23ce09f7d5b87fac9b3284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache MRM cache hits number.  <a href="group___h_w___c_a_c_h_e.html#ga0d3d5651fb23ce09f7d5b87fac9b3284">More...</a><br /></td></tr>
<tr class="separator:ga0d3d5651fb23ce09f7d5b87fac9b3284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd77a7961e527eab7796d5ccd56d6bf6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gadd77a7961e527eab7796d5ccd56d6bf6">hw_cache_mrm_set_hits</a> (uint32_t hits)</td></tr>
<tr class="memdesc:gadd77a7961e527eab7796d5ccd56d6bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache MRM cache hits number.  <a href="group___h_w___c_a_c_h_e.html#gadd77a7961e527eab7796d5ccd56d6bf6">More...</a><br /></td></tr>
<tr class="separator:gadd77a7961e527eab7796d5ccd56d6bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d7f102749e23ac9c59b58a4844aef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga23d7f102749e23ac9c59b58a4844aef5">hw_cache_mrm_enable_interrupt</a> (<a class="el" href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">hw_cache_mrm_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga23d7f102749e23ac9c59b58a4844aef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the MRM interrupt generation.  <a href="group___h_w___c_a_c_h_e.html#ga23d7f102749e23ac9c59b58a4844aef5">More...</a><br /></td></tr>
<tr class="separator:ga23d7f102749e23ac9c59b58a4844aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851f28d720b3778761c2d5f26e626898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga851f28d720b3778761c2d5f26e626898">hw_cache_mrm_disable_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga851f28d720b3778761c2d5f26e626898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the MRM interrupt generation.  <a href="group___h_w___c_a_c_h_e.html#ga851f28d720b3778761c2d5f26e626898">More...</a><br /></td></tr>
<tr class="separator:ga851f28d720b3778761c2d5f26e626898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab507b617d9d54566cc3110d7f857d4ac"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gab507b617d9d54566cc3110d7f857d4ac">hw_cache_enable</a> (void)</td></tr>
<tr class="memdesc:gab507b617d9d54566cc3110d7f857d4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the iCache Controller.  <a href="group___h_w___c_a_c_h_e.html#gab507b617d9d54566cc3110d7f857d4ac">More...</a><br /></td></tr>
<tr class="separator:gab507b617d9d54566cc3110d7f857d4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3edce3480a91cf1d18378e5341c23141"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga3edce3480a91cf1d18378e5341c23141">hw_cache_disable</a> (void)</td></tr>
<tr class="memdesc:ga3edce3480a91cf1d18378e5341c23141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the iCache Controller.  <a href="group___h_w___c_a_c_h_e.html#ga3edce3480a91cf1d18378e5341c23141">More...</a><br /></td></tr>
<tr class="separator:ga3edce3480a91cf1d18378e5341c23141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ffcb1d04689a73d4bd5ff49632da9d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gad2ffcb1d04689a73d4bd5ff49632da9d">hw_cache_is_enabled</a> (void)</td></tr>
<tr class="memdesc:gad2ffcb1d04689a73d4bd5ff49632da9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iCache Controller is enabled.  <a href="group___h_w___c_a_c_h_e.html#gad2ffcb1d04689a73d4bd5ff49632da9d">More...</a><br /></td></tr>
<tr class="separator:gad2ffcb1d04689a73d4bd5ff49632da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391dd64abb0e016d623c00702f5b56dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga391dd64abb0e016d623c00702f5b56dc">hw_cache_set_extflash_cacheable_len</a> (uint32_t len)</td></tr>
<tr class="memdesc:ga391dd64abb0e016d623c00702f5b56dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the external flash cacheable memory length.  <a href="group___h_w___c_a_c_h_e.html#ga391dd64abb0e016d623c00702f5b56dc">More...</a><br /></td></tr>
<tr class="separator:ga391dd64abb0e016d623c00702f5b56dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10fc89bc6d6708b54d7c5a2b5e0cfa2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gab10fc89bc6d6708b54d7c5a2b5e0cfa2">hw_cache_get_extflash_cacheable_len</a> (void)</td></tr>
<tr class="memdesc:gab10fc89bc6d6708b54d7c5a2b5e0cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the external flash cacheable memory length.  <a href="group___h_w___c_a_c_h_e.html#gab10fc89bc6d6708b54d7c5a2b5e0cfa2">More...</a><br /></td></tr>
<tr class="separator:gab10fc89bc6d6708b54d7c5a2b5e0cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb063c4ced8b37db07e30bfb2cc3cd00"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gacb063c4ced8b37db07e30bfb2cc3cd00">hw_cache_set_len</a> (uint32_t len)</td></tr>
<tr class="memdesc:gacb063c4ced8b37db07e30bfb2cc3cd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cacheable memory length. Backwards compatibility wrapper.  <a href="group___h_w___c_a_c_h_e.html#gacb063c4ced8b37db07e30bfb2cc3cd00">More...</a><br /></td></tr>
<tr class="separator:gacb063c4ced8b37db07e30bfb2cc3cd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac571c4564be1ef5097831cb423b2d4ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gac571c4564be1ef5097831cb423b2d4ff">hw_cache_get_len</a> (void)</td></tr>
<tr class="memdesc:gac571c4564be1ef5097831cb423b2d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cacheable memory length. Backwards compatibility wrapper.  <a href="group___h_w___c_a_c_h_e.html#gac571c4564be1ef5097831cb423b2d4ff">More...</a><br /></td></tr>
<tr class="separator:gac571c4564be1ef5097831cb423b2d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ceeb640ebb3aca7ea623eee2ebe07d"><td class="memItemLeft" align="right" valign="top"><a id="gaa2ceeb640ebb3aca7ea623eee2ebe07d"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaa2ceeb640ebb3aca7ea623eee2ebe07d">hw_cache_enable_flushing</a> (void)</td></tr>
<tr class="memdesc:gaa2ceeb640ebb3aca7ea623eee2ebe07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable flushing the iCache Controller (cache RAM cells) contents. For debugging only. <br /></td></tr>
<tr class="separator:gaa2ceeb640ebb3aca7ea623eee2ebe07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef714fd3cacea08aca7fff7dd41c1ebe"><td class="memItemLeft" align="right" valign="top"><a id="gaef714fd3cacea08aca7fff7dd41c1ebe"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaef714fd3cacea08aca7fff7dd41c1ebe">hw_cache_disable_flushing</a> (void)</td></tr>
<tr class="memdesc:gaef714fd3cacea08aca7fff7dd41c1ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable flushing the iCache Controller (cache RAM cells) contents. For debugging only. <br /></td></tr>
<tr class="separator:gaef714fd3cacea08aca7fff7dd41c1ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecf98398bdb2fb5fa2c435fbaf4d744"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga9ecf98398bdb2fb5fa2c435fbaf4d744">hw_cache_is_flushing_disabled</a> (void)</td></tr>
<tr class="memdesc:ga9ecf98398bdb2fb5fa2c435fbaf4d744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iCache Controller flushing is disabled. For debugging only.  <a href="group___h_w___c_a_c_h_e.html#ga9ecf98398bdb2fb5fa2c435fbaf4d744">More...</a><br /></td></tr>
<tr class="separator:ga9ecf98398bdb2fb5fa2c435fbaf4d744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e519284b12d1e2b70b992d3741b0f5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga70e519284b12d1e2b70b992d3741b0f5">hw_cache_is_flushed</a> (void)</td></tr>
<tr class="memdesc:ga70e519284b12d1e2b70b992d3741b0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the flushing process is complete.  <a href="group___h_w___c_a_c_h_e.html#ga70e519284b12d1e2b70b992d3741b0f5">More...</a><br /></td></tr>
<tr class="separator:ga70e519284b12d1e2b70b992d3741b0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a5ee95d2aceb5f85ad2653e46cf918"><td class="memItemLeft" align="right" valign="top"><a id="ga18a5ee95d2aceb5f85ad2653e46cf918"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga18a5ee95d2aceb5f85ad2653e46cf918">hw_cache_clear_flushed</a> (void)</td></tr>
<tr class="memdesc:ga18a5ee95d2aceb5f85ad2653e46cf918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the indication that a prior flushing process is complete. <br /></td></tr>
<tr class="separator:ga18a5ee95d2aceb5f85ad2653e46cf918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21654107b254110725ddacd01346412"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gae21654107b254110725ddacd01346412">hw_cache_flush</a> (void)</td></tr>
<tr class="memdesc:gae21654107b254110725ddacd01346412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the iCache controller contents.  <a href="group___h_w___c_a_c_h_e.html#gae21654107b254110725ddacd01346412">More...</a><br /></td></tr>
<tr class="separator:gae21654107b254110725ddacd01346412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b6da1c94c0a47fa3887601ae6018b7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga44b6da1c94c0a47fa3887601ae6018b7">hw_cache_is_ready</a> (void)</td></tr>
<tr class="memdesc:ga44b6da1c94c0a47fa3887601ae6018b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">iCache controller status  <a href="group___h_w___c_a_c_h_e.html#ga44b6da1c94c0a47fa3887601ae6018b7">More...</a><br /></td></tr>
<tr class="separator:ga44b6da1c94c0a47fa3887601ae6018b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cbf12fdf61dd26885df8e7c4c11749"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga59cbf12fdf61dd26885df8e7c4c11749">hw_cache_enable_cwf</a> (void)</td></tr>
<tr class="memdesc:ga59cbf12fdf61dd26885df8e7c4c11749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Critical Word First.  <a href="group___h_w___c_a_c_h_e.html#ga59cbf12fdf61dd26885df8e7c4c11749">More...</a><br /></td></tr>
<tr class="separator:ga59cbf12fdf61dd26885df8e7c4c11749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e0fb1cf22c910e5045dc0e2f19b5152"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga4e0fb1cf22c910e5045dc0e2f19b5152">hw_cache_disable_cwf</a> (void)</td></tr>
<tr class="memdesc:ga4e0fb1cf22c910e5045dc0e2f19b5152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Critical Word First.  <a href="group___h_w___c_a_c_h_e.html#ga4e0fb1cf22c910e5045dc0e2f19b5152">More...</a><br /></td></tr>
<tr class="separator:ga4e0fb1cf22c910e5045dc0e2f19b5152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac969b2ee2c4318a19d8e793bce89543b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gac969b2ee2c4318a19d8e793bce89543b">hw_cache_is_cwf_disabled</a> (void)</td></tr>
<tr class="memdesc:gac969b2ee2c4318a19d8e793bce89543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iCache Controller Critical-Word-First mode is disabled.  <a href="group___h_w___c_a_c_h_e.html#gac969b2ee2c4318a19d8e793bce89543b">More...</a><br /></td></tr>
<tr class="separator:gac969b2ee2c4318a19d8e793bce89543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6f61fb3179b2373be971d32f53217e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e">hw_cache_flash_set_region_base</a> (flash_region_base_t base)</td></tr>
<tr class="memdesc:gaef6f61fb3179b2373be971d32f53217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flash region base. Indicates where caching will start from.  <a href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e">More...</a><br /></td></tr>
<tr class="separator:gaef6f61fb3179b2373be971d32f53217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3dc80229343ba08983c873c8cfadb5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE flash_region_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gafc3dc80229343ba08983c873c8cfadb5">hw_cache_flash_get_region_base</a> (void)</td></tr>
<tr class="memdesc:gafc3dc80229343ba08983c873c8cfadb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash region base.  <a href="group___h_w___c_a_c_h_e.html#gafc3dc80229343ba08983c873c8cfadb5">More...</a><br /></td></tr>
<tr class="separator:gafc3dc80229343ba08983c873c8cfadb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1ea0d5a8cfacfa39c6e6339a73a670"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gaea1ea0d5a8cfacfa39c6e6339a73a670">hw_cache_flash_set_region_offset</a> (flash_region_offset_t offset)</td></tr>
<tr class="memdesc:gaea1ea0d5a8cfacfa39c6e6339a73a670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flash region offset. Indicates where remapping will start from.  <a href="group___h_w___c_a_c_h_e.html#gaea1ea0d5a8cfacfa39c6e6339a73a670">More...</a><br /></td></tr>
<tr class="separator:gaea1ea0d5a8cfacfa39c6e6339a73a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb8044d69a876bb2ab73a02074408f4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE flash_region_offset_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga3bb8044d69a876bb2ab73a02074408f4">hw_cache_flash_get_region_offset</a> (void)</td></tr>
<tr class="memdesc:ga3bb8044d69a876bb2ab73a02074408f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash region offset.  <a href="group___h_w___c_a_c_h_e.html#ga3bb8044d69a876bb2ab73a02074408f4">More...</a><br /></td></tr>
<tr class="separator:ga3bb8044d69a876bb2ab73a02074408f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32c463d2527fad789e403ba750bd447"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gab32c463d2527fad789e403ba750bd447">hw_cache_flash_set_region_size</a> (<a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> sz)</td></tr>
<tr class="memdesc:gab32c463d2527fad789e403ba750bd447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flash region size.  <a href="group___h_w___c_a_c_h_e.html#gab32c463d2527fad789e403ba750bd447">More...</a><br /></td></tr>
<tr class="separator:gab32c463d2527fad789e403ba750bd447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe46dd7763e7a87de77e7f2321106f76"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gafe46dd7763e7a87de77e7f2321106f76">hw_cache_flash_get_region_size</a> (void)</td></tr>
<tr class="memdesc:gafe46dd7763e7a87de77e7f2321106f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash region size.  <a href="group___h_w___c_a_c_h_e.html#gafe46dd7763e7a87de77e7f2321106f76">More...</a><br /></td></tr>
<tr class="separator:gafe46dd7763e7a87de77e7f2321106f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaebf0eb7907c1c96a4c428d4617d5b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gadaebf0eb7907c1c96a4c428d4617d5b3">hw_cache_flash_configure_region</a> (flash_region_base_t base, flash_region_offset_t offset, <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> sz)</td></tr>
<tr class="memdesc:gadaebf0eb7907c1c96a4c428d4617d5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the flash memory region that will be cacheable.  <a href="group___h_w___c_a_c_h_e.html#gadaebf0eb7907c1c96a4c428d4617d5b3">More...</a><br /></td></tr>
<tr class="separator:gadaebf0eb7907c1c96a4c428d4617d5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a362070011ed747f3a4f3b1ea988c8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#ga22a362070011ed747f3a4f3b1ea988c8">hw_cache_mrm_get_hits_with_one_wait_state</a> (void)</td></tr>
<tr class="memdesc:ga22a362070011ed747f3a4f3b1ea988c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iCache controller MRM hits with 1 Wait State number.  <a href="group___h_w___c_a_c_h_e.html#ga22a362070011ed747f3a4f3b1ea988c8">More...</a><br /></td></tr>
<tr class="separator:ga22a362070011ed747f3a4f3b1ea988c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc291399ea5262bdd95c09d1a4d2b992"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___c_a_c_h_e.html#gafc291399ea5262bdd95c09d1a4d2b992">hw_cache_mrm_set_hits_with_one_wait_state</a> (uint32_t hits)</td></tr>
<tr class="memdesc:gafc291399ea5262bdd95c09d1a4d2b992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iCache controller MRM hits with 1 Wait State number.  <a href="group___h_w___c_a_c_h_e.html#gafc291399ea5262bdd95c09d1a4d2b992">More...</a><br /></td></tr>
<tr class="separator:gafc291399ea5262bdd95c09d1a4d2b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>iCache Controller LLD common API </p>
<p>iCache Controller DA1470x specific LLD API</p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5629c89852d71dd11da8dba6c80e7eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5629c89852d71dd11da8dba6c80e7eab">&#9670;&nbsp;</a></span>hw_cache_mrm_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_cache_mrm_cb_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application defined callback for the MRM interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>The application defined callback should be declared as __RETAINED_CODE. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac5db731d4daed45ab6570f2d979457dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5db731d4daed45ab6570f2d979457dc">&#9670;&nbsp;</a></span>HW_CACHE_FLASH_REGION_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cacheable flash Region Sizes as defined in DA1470x datasheet. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3edce3480a91cf1d18378e5341c23141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3edce3480a91cf1d18378e5341c23141">&#9670;&nbsp;</a></span>hw_cache_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the iCache Controller. </p>
<p>The iCache Controller is disabled by setting the CACHERAM_MUX to '0'. This action disables the corresponding HW block, bypassing the iCache Controller for all read requests and letting the RAM memory of the block be visible in the entire memory space. </p>

</div>
</div>
<a id="ga4e0fb1cf22c910e5045dc0e2f19b5152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e0fb1cf22c910e5045dc0e2f19b5152">&#9670;&nbsp;</a></span>hw_cache_disable_cwf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_disable_cwf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Critical Word First. </p>
<p>It affects which word is fetched first on a cache line refill.</p>
<p>Note: When CWF is disabled, the cache line refill is performed with a burst </p>

</div>
</div>
<a id="gab507b617d9d54566cc3110d7f857d4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab507b617d9d54566cc3110d7f857d4ac">&#9670;&nbsp;</a></span>hw_cache_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the iCache Controller. </p>
<p>The iCache Controller is enabled by setting the CACHERAM_MUX to '1'. This action enables the corresponding HW block, letting the RAM memory of the block be visible only to the iCache Controller for caching purposes. </p>

</div>
</div>
<a id="ga59cbf12fdf61dd26885df8e7c4c11749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59cbf12fdf61dd26885df8e7c4c11749">&#9670;&nbsp;</a></span>hw_cache_enable_cwf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_enable_cwf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Critical Word First. </p>
<p>It affects which word is fetched first on a cache line refill. </p>

</div>
</div>
<a id="gadaebf0eb7907c1c96a4c428d4617d5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaebf0eb7907c1c96a4c428d4617d5b3">&#9670;&nbsp;</a></span>hw_cache_flash_configure_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_configure_region </td>
          <td>(</td>
          <td class="paramtype">flash_region_base_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flash_region_offset_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a>&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the flash memory region that will be cacheable. </p>
<p>This is an alternative API to <a class="el" href="group___h_w___c_a_c_h_e.html#gaef6f61fb3179b2373be971d32f53217e" title="Set the flash region base. Indicates where caching will start from.">hw_cache_flash_set_region_base()</a>/_size()/_offset(). It automatically configures the entire flash region in one call.</p>
<p>See the relevant called functions for input parameter definition.</p>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gafc3dc80229343ba08983c873c8cfadb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3dc80229343ba08983c873c8cfadb5">&#9670;&nbsp;</a></span>hw_cache_flash_get_region_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE flash_region_base_t hw_cache_flash_get_region_base </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash region base. </p>
<dl class="section return"><dt>Returns</dt><dd>The flash region base to use with the iCache controller </dd></dl>

</div>
</div>
<a id="ga3bb8044d69a876bb2ab73a02074408f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bb8044d69a876bb2ab73a02074408f4">&#9670;&nbsp;</a></span>hw_cache_flash_get_region_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE flash_region_offset_t hw_cache_flash_get_region_offset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash region offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The region offset to be used in conjunction with the region base to indicate the starting address within the flash memory area that will be remapped. </dd></dl>

</div>
</div>
<a id="gafe46dd7763e7a87de77e7f2321106f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe46dd7763e7a87de77e7f2321106f76">&#9670;&nbsp;</a></span>hw_cache_flash_get_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a> hw_cache_flash_get_region_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash region size. </p>
<dl class="section return"><dt>Returns</dt><dd>The flash region size to use with the iCache controller </dd></dl>

</div>
</div>
<a id="gaef6f61fb3179b2373be971d32f53217e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef6f61fb3179b2373be971d32f53217e">&#9670;&nbsp;</a></span>hw_cache_flash_set_region_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_set_region_base </td>
          <td>(</td>
          <td class="paramtype">flash_region_base_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flash region base. Indicates where caching will start from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The Flash region base corresponds to the flash address bits [31:16]. Default values is '0x1800'. Bits [31:27] are fixed to '0b00011'. Therefore, valid values are from 0x1800 to 0x1FFF. This address should be region 'size'-param aligned (<a class="el" href="group___h_w___c_a_c_h_e.html#gab32c463d2527fad789e403ba750bd447" title="Set the flash region size.">hw_cache_flash_set_region_size()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gaea1ea0d5a8cfacfa39c6e6339a73a670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea1ea0d5a8cfacfa39c6e6339a73a670">&#9670;&nbsp;</a></span>hw_cache_flash_set_region_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_set_region_offset </td>
          <td>(</td>
          <td class="paramtype">flash_region_offset_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flash region offset. Indicates where remapping will start from. </p>
<p>This value (expressed in words) is added to flash region base (see hw_cache_flash_set/get_region_base()) to calculate the the starting address within the flash memory area that will be remapped to 0x0 and XiPed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>flash region offset in 32-bit words. Max: 0xFFF since the corresponding register bit field area is 3 nibbles in length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gab32c463d2527fad789e403ba750bd447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32c463d2527fad789e403ba750bd447">&#9670;&nbsp;</a></span>hw_cache_flash_set_region_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flash_set_region_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#gac5db731d4daed45ab6570f2d979457dc">HW_CACHE_FLASH_REGION_SZ</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flash region size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The cacheable region size to use with the iCache controller</td></tr>
  </table>
  </dd>
</dl>
<p>This is the size of the flash memory that is cacheable and remappable in which one or more FW images and SW library modules may reside and can be XiPed.</p>
<dl class="section note"><dt>Note</dt><dd>Differs from the cache length (see hw_cache_set/get_extflash_cacheable_len()). </dd>
<dd>
The updated value takes effect only after a software reset. </dd></dl>

</div>
</div>
<a id="gae21654107b254110725ddacd01346412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21654107b254110725ddacd01346412">&#9670;&nbsp;</a></span>hw_cache_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the iCache controller contents. </p>
<p>Note: The very first flushing occurred after power on reset when the iCache Controller is enabled for the first time by the booter. </p>

</div>
</div>
<a id="gab10fc89bc6d6708b54d7c5a2b5e0cfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10fc89bc6d6708b54d7c5a2b5e0cfa2">&#9670;&nbsp;</a></span>hw_cache_get_extflash_cacheable_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int hw_cache_get_extflash_cacheable_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the external flash cacheable memory length. </p>
<dl class="section return"><dt>Returns</dt><dd>The flash cacheable memory length, in 64KB blocks. The actual cacheable memory length will therefore be len * 64KB. </dd></dl>

</div>
</div>
<a id="gac571c4564be1ef5097831cb423b2d4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac571c4564be1ef5097831cb423b2d4ff">&#9670;&nbsp;</a></span>hw_cache_get_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int hw_cache_get_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cacheable memory length. Backwards compatibility wrapper. </p>
<dl class="section return"><dt>Returns</dt><dd>See hw_cache_get_extflash_cacheable_len for details. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>API no longer supported, use hw_cache_get_extflash_cacheable_len. </dd></dl>

</div>
</div>
<a id="gac969b2ee2c4318a19d8e793bce89543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac969b2ee2c4318a19d8e793bce89543b">&#9670;&nbsp;</a></span>hw_cache_is_cwf_disabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_cwf_disabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the iCache Controller Critical-Word-First mode is disabled. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iCache Controller CWF is disabled, False otherwise. </dd></dl>

</div>
</div>
<a id="gad2ffcb1d04689a73d4bd5ff49632da9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2ffcb1d04689a73d4bd5ff49632da9d">&#9670;&nbsp;</a></span>hw_cache_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the iCache Controller is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iCache Controller is enabled, False otherwise. </dd></dl>

</div>
</div>
<a id="ga70e519284b12d1e2b70b992d3741b0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e519284b12d1e2b70b992d3741b0f5">&#9670;&nbsp;</a></span>hw_cache_is_flushed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_flushed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the flushing process is complete. </p>
<dl class="section return"><dt>Returns</dt><dd>True if flushing is complete, False if the iCache controller flushing is still in progress or there is no pending flushing termination indication as it will be cleared via a prior <a class="el" href="group___h_w___c_a_c_h_e.html#ga18a5ee95d2aceb5f85ad2653e46cf918" title="Clear the indication that a prior flushing process is complete.">hw_cache_clear_flushed()</a> call. </dd></dl>

</div>
</div>
<a id="ga9ecf98398bdb2fb5fa2c435fbaf4d744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ecf98398bdb2fb5fa2c435fbaf4d744">&#9670;&nbsp;</a></span>hw_cache_is_flushing_disabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_flushing_disabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the iCache Controller flushing is disabled. For debugging only. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iCache Controller flushing is disabled, False otherwise. </dd></dl>

</div>
</div>
<a id="ga44b6da1c94c0a47fa3887601ae6018b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b6da1c94c0a47fa3887601ae6018b7">&#9670;&nbsp;</a></span>hw_cache_is_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_is_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iCache controller status </p>
<dl class="section return"><dt>Returns</dt><dd>True if iCache controller is enabled, initialized and ready for a cacheable access. </dd></dl>

</div>
</div>
<a id="ga7a6fc6d13aa50fd8fdbfee60ce64f3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a6fc6d13aa50fd8fdbfee60ce64f3dc">&#9670;&nbsp;</a></span>hw_cache_mrm_clr_hits_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_clr_hits_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the cache MRM hits threshold IRQ status. </p>

</div>
</div>
<a id="ga18af98472de537f4af4496fa34412e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18af98472de537f4af4496fa34412e6d">&#9670;&nbsp;</a></span>hw_cache_mrm_clr_misses_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_clr_misses_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the cache MRM misses threshold IRQ status. </p>

</div>
</div>
<a id="gaffbce6fba4487f7c77dc8fb24dae36c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffbce6fba4487f7c77dc8fb24dae36c8">&#9670;&nbsp;</a></span>hw_cache_mrm_clr_tint_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_clr_tint_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the cache MRM timer interval IRQ status. </p>

</div>
</div>
<a id="ga851f28d720b3778761c2d5f26e626898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga851f28d720b3778761c2d5f26e626898">&#9670;&nbsp;</a></span>hw_cache_mrm_disable_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_cache_mrm_disable_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the MRM interrupt generation. </p>
<dl class="section note"><dt>Note</dt><dd>The application defined called is unregistered. </dd></dl>

</div>
</div>
<a id="ga23d7f102749e23ac9c59b58a4844aef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23d7f102749e23ac9c59b58a4844aef5">&#9670;&nbsp;</a></span>hw_cache_mrm_enable_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_cache_mrm_enable_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_a_c_h_e.html#ga5629c89852d71dd11da8dba6c80e7eab">hw_cache_mrm_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the MRM interrupt generation. </p>
<p>The application should define its own callback. The latter is registered and then invoked when the MRM interrupt is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback defined by the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a52e77bc6d5eb104910df4ff02e202c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a52e77bc6d5eb104910df4ff02e202c">&#9670;&nbsp;</a></span>hw_cache_mrm_freeze_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_freeze_counters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freeze MRM counters. </p>

</div>
</div>
<a id="ga0d3d5651fb23ce09f7d5b87fac9b3284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3d5651fb23ce09f7d5b87fac9b3284">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_hits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM cache hits number. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of cache hits </dd></dl>

</div>
</div>
<a id="gaece12257a8c6f3cb3699f7661378842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece12257a8c6f3cb3699f7661378842f">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_hits_thres </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM interrupt threshold for hits. </p>
<dl class="section return"><dt>Returns</dt><dd>The interrupt generation threshold (in hits) </dd></dl>

</div>
</div>
<a id="ga89d269a059a7ac36dcc93c9c3aa53047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d269a059a7ac36dcc93c9c3aa53047">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_mrm_get_hits_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM hits threshold IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>True if an interrupt has been generated because the number of hits reached the programmed threshold (if !=0) </dd></dl>

</div>
</div>
<a id="ga22a362070011ed747f3a4f3b1ea988c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a362070011ed747f3a4f3b1ea988c8">&#9670;&nbsp;</a></span>hw_cache_mrm_get_hits_with_one_wait_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_hits_with_one_wait_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iCache controller MRM hits with 1 Wait State number. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of hits with 1 Wait State </dd></dl>

</div>
</div>
<a id="ga1515565552194cea562af1fd4b7d1afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1515565552194cea562af1fd4b7d1afa">&#9670;&nbsp;</a></span>hw_cache_mrm_get_misses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_misses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM misses number. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of cache misses </dd></dl>

</div>
</div>
<a id="gaa042acf2dd528d343409f2458fb59eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa042acf2dd528d343409f2458fb59eb7">&#9670;&nbsp;</a></span>hw_cache_mrm_get_misses_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_misses_thres </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM interrupt threshold for misses. </p>
<dl class="section return"><dt>Returns</dt><dd>The interrupt generation threshold (in misses) </dd></dl>

</div>
</div>
<a id="ga02f877bb6a3bb3999c6229ebaaf9680e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f877bb6a3bb3999c6229ebaaf9680e">&#9670;&nbsp;</a></span>hw_cache_mrm_get_misses_thres_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_mrm_get_misses_thres_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM misses threshold IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>True if an interrupt has been generated because the number of misses reached the programmed threshold (if !=0) </dd></dl>

</div>
</div>
<a id="ga0470d2492f249a0bf97743081fee47c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0470d2492f249a0bf97743081fee47c0">&#9670;&nbsp;</a></span>hw_cache_mrm_get_tint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t hw_cache_mrm_get_tint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM monitoring time interval. </p>
<dl class="section return"><dt>Returns</dt><dd>The monitoring time interval in clock cycles </dd></dl>

</div>
</div>
<a id="ga57d63128c10cd15f37d7b829ce2c9a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d63128c10cd15f37d7b829ce2c9a15">&#9670;&nbsp;</a></span>hw_cache_mrm_get_tint_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_cache_mrm_get_tint_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cache MRM timer interval IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>True if an interrupt has been generated because the time interval counter reached the end (time interval != 0). </dd></dl>

</div>
</div>
<a id="gadd77a7961e527eab7796d5ccd56d6bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd77a7961e527eab7796d5ccd56d6bf6">&#9670;&nbsp;</a></span>hw_cache_mrm_set_hits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_hits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM cache hits number. </p>
<p>This is primarily intended for clearing the hits number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hits</td><td>The number of cache hits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab50dd16bc01c517e505c0bc4a66b60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab50dd16bc01c517e505c0bc4a66b60e">&#9670;&nbsp;</a></span>hw_cache_mrm_set_hits_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_hits_thres </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM interrupt threshold for hits. </p>
<p>Defines the threshold (in hits) to trigger the interrupt generation. A value of 0 disables interrupt generation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thres</td><td>The interrupt generation threshold (in hits) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc291399ea5262bdd95c09d1a4d2b992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc291399ea5262bdd95c09d1a4d2b992">&#9670;&nbsp;</a></span>hw_cache_mrm_set_hits_with_one_wait_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_hits_with_one_wait_state </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iCache controller MRM hits with 1 Wait State number. </p>
<p>This is primarily intended for clearing the register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hits</td><td>The number of hits with 1 Wait State </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf9a24961355cdee7e3279dc8989645a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf9a24961355cdee7e3279dc8989645a">&#9670;&nbsp;</a></span>hw_cache_mrm_set_misses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_misses </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>misses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM cache misses number. </p>
<p>This is primarily intended for clearing the misses number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">misses</td><td>The number of cache misses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15c6ac9e2869e341c338f036edbb894b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c6ac9e2869e341c338f036edbb894b">&#9670;&nbsp;</a></span>hw_cache_mrm_set_misses_thres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_misses_thres </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM interrupt threshold for misses. </p>
<p>Defines the threshold (in misses) to trigger the interrupt generation. A value of 0 disables interrupt generation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thres</td><td>The interrupt generation threshold (in misses) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50baaa9ef1a4bb9bbe7832986fda9585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50baaa9ef1a4bb9bbe7832986fda9585">&#9670;&nbsp;</a></span>hw_cache_mrm_set_tint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_set_tint </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache MRM monitoring time interval. </p>
<p>Defines the time interval for the monitoring in 32 MHz clock cycles. Must be an 19-bit value max. When this time is reached, an interrupt will be generated. A value of 0 disables interrupt generation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tint</td><td>Monitoring time interval in clock cycles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07d33383047222cc93669b3db989642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d33383047222cc93669b3db989642e">&#9670;&nbsp;</a></span>hw_cache_mrm_start_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_mrm_start_counters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start MRM counters. </p>
<dl class="section note"><dt>Note</dt><dd>If Timer interval is not set to 0 using hw_cache_mrm_set_tint, the timer interval will count down to 0. When zero is reached, an interrupt will be generated, and the counters will be disabled automatically. </dd></dl>

</div>
</div>
<a id="ga391dd64abb0e016d623c00702f5b56dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391dd64abb0e016d623c00702f5b56dc">&#9670;&nbsp;</a></span>hw_cache_set_extflash_cacheable_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_set_extflash_cacheable_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the external flash cacheable memory length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The external flash cacheable memory length, in 64KB blocks. The actual cacheable memory length will therefore be len * 64KB. Valid values: [0, 2048] to address a max 128MB cacheable length. A value of 0 sets the iCache Controller in bypass mode for the read requests targeting the cacheable external flash memory area. Any value greater than zero will set it in caching mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Indicates the size of the instruction code that will be cached in an execution lifecycle. Differs from region size (hw_cache_flash_set/get_region_size()). Runtime reconfigurable. </dd></dl>

</div>
</div>
<a id="gacb063c4ced8b37db07e30bfb2cc3cd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb063c4ced8b37db07e30bfb2cc3cd00">&#9670;&nbsp;</a></span>hw_cache_set_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_cache_set_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cacheable memory length. Backwards compatibility wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>See hw_cache_set_extflash_cacheable_len for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>API no longer supported, use hw_cache_set_extflash_cacheable_len. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:41 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
