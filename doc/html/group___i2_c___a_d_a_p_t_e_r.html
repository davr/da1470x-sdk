<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: I2C Adapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Adapter<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___a_d_a_p_t_e_r_s.html">System Adapters</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Inter Integrated Circuit adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__i2c_8h.html">ad_i2c.h</a></td></tr>
<tr class="memdesc:ad__i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C device access API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__i2c__io__conf__t.html">ad_i2c_io_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C I/O configuration.  <a href="structad__i2c__io__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__i2c__driver__conf__t.html">ad_i2c_driver_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C driver configuration.  <a href="structad__i2c__driver__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__i2c__controller__conf__t.html">ad_i2c_controller_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C controller configuration.  <a href="structad__i2c__controller__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae1ea113649ff626de4173a4ba95541b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gae1ea113649ff626de4173a4ba95541b7">CONFIG_I2C_USE_ASYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gae1ea113649ff626de4173a4ba95541b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether I2C asynchronous transaction API will be used.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gae1ea113649ff626de4173a4ba95541b7">More...</a><br /></td></tr>
<tr class="separator:gae1ea113649ff626de4173a4ba95541b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0408c9e56fb249945b5b147011fc6f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaf0408c9e56fb249945b5b147011fc6f8">CONFIG_I2C_USE_SYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaf0408c9e56fb249945b5b147011fc6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether I2C synchronous transaction API will be used.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gaf0408c9e56fb249945b5b147011fc6f8">More...</a><br /></td></tr>
<tr class="separator:gaf0408c9e56fb249945b5b147011fc6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafd97fc778be31559d1c682d3ad00e045"><td class="memItemLeft" align="right" valign="top"><a id="gafd97fc778be31559d1c682d3ad00e045"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a></td></tr>
<tr class="memdesc:gafd97fc778be31559d1c682d3ad00e045"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Handle returned by <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> <br /></td></tr>
<tr class="separator:gafd97fc778be31559d1c682d3ad00e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b665bf082202d3e106611b9fa0e260"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>) (void *user_data, <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> error)</td></tr>
<tr class="memdesc:gab9b665bf082202d3e106611b9fa0e260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous callback function.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">More...</a><br /></td></tr>
<tr class="separator:gab9b665bf082202d3e106611b9fa0e260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2d28fe9a89c02b4815c5d5f5c9ce24b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga2d28fe9a89c02b4815c5d5f5c9ce24b7">AD_I2C_ERROR</a> </td></tr>
<tr class="memdesc:ga2d28fe9a89c02b4815c5d5f5c9ce24b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C adapter error codes.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga2d28fe9a89c02b4815c5d5f5c9ce24b7">More...</a><br /></td></tr>
<tr class="separator:ga2d28fe9a89c02b4815c5d5f5c9ce24b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b3105a748890da0dec74c504185819a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga1b3105a748890da0dec74c504185819a">ad_i2c_init</a> (void)</td></tr>
<tr class="memdesc:ga1b3105a748890da0dec74c504185819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga1b3105a748890da0dec74c504185819a">More...</a><br /></td></tr>
<tr class="separator:ga1b3105a748890da0dec74c504185819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef785c2b17e762efd103e2ae6630403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403">ad_i2c_open</a> (const <a class="el" href="structad__i2c__controller__conf__t.html">ad_i2c_controller_conf_t</a> *conf)</td></tr>
<tr class="memdesc:gabef785c2b17e762efd103e2ae6630403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open I2C controller.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403">More...</a><br /></td></tr>
<tr class="separator:gabef785c2b17e762efd103e2ae6630403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0659b852cb6030cf508b9efc61c95d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafa0659b852cb6030cf508b9efc61c95d">ad_i2c_reconfig</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const <a class="el" href="structad__i2c__driver__conf__t.html">ad_i2c_driver_conf_t</a> *conf)</td></tr>
<tr class="memdesc:gafa0659b852cb6030cf508b9efc61c95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure I2C controller.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gafa0659b852cb6030cf508b9efc61c95d">More...</a><br /></td></tr>
<tr class="separator:gafa0659b852cb6030cf508b9efc61c95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d3cd1892d3a7ed78d4b6702b416f101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga1d3cd1892d3a7ed78d4b6702b416f101">ad_i2c_close</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, bool force)</td></tr>
<tr class="memdesc:ga1d3cd1892d3a7ed78d4b6702b416f101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close I2C controller.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga1d3cd1892d3a7ed78d4b6702b416f101">More...</a><br /></td></tr>
<tr class="separator:ga1d3cd1892d3a7ed78d4b6702b416f101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c20fb5b818d5ae61ad48b581cceadb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaa1c20fb5b818d5ae61ad48b581cceadb">ad_i2c_io_config</a> (HW_I2C_ID id, const <a class="el" href="structad__i2c__io__conf__t.html">ad_i2c_io_conf_t</a> *io, <a class="el" href="group___a_d_a_p_t_e_r.html#ga37f7ad66c2edac01fa114cd43d15d428">AD_IO_CONF_STATE</a> state)</td></tr>
<tr class="memdesc:gaa1c20fb5b818d5ae61ad48b581cceadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize controller pins to on / off io configuration.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gaa1c20fb5b818d5ae61ad48b581cceadb">More...</a><br /></td></tr>
<tr class="separator:gaa1c20fb5b818d5ae61ad48b581cceadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d29ecd47d69bbf4d535950dc9a3ddf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga25d29ecd47d69bbf4d535950dc9a3ddf">ad_i2c_write</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga25d29ecd47d69bbf4d535950dc9a3ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking write transaction.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga25d29ecd47d69bbf4d535950dc9a3ddf">More...</a><br /></td></tr>
<tr class="separator:ga25d29ecd47d69bbf4d535950dc9a3ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ae581e37295ff9e7791a7d0ce784a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga27ae581e37295ff9e7791a7d0ce784a5">ad_i2c_write_with_to</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t condition_flags, <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a> timeout)</td></tr>
<tr class="memdesc:ga27ae581e37295ff9e7791a7d0ce784a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking write transaction with time out.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga27ae581e37295ff9e7791a7d0ce784a5">More...</a><br /></td></tr>
<tr class="separator:ga27ae581e37295ff9e7791a7d0ce784a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9cadc282a01e3dbf0122596bd62c62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3a9cadc282a01e3dbf0122596bd62c62">ad_i2c_read</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, uint8_t *rbuf, size_t rlen, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga3a9cadc282a01e3dbf0122596bd62c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking read transaction.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga3a9cadc282a01e3dbf0122596bd62c62">More...</a><br /></td></tr>
<tr class="separator:ga3a9cadc282a01e3dbf0122596bd62c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efc08920953e579163ec411c2a0d4f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5efc08920953e579163ec411c2a0d4f3">ad_i2c_read_with_to</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, uint8_t *rbuf, size_t rlen, uint8_t condition_flags, <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a> timeout)</td></tr>
<tr class="memdesc:ga5efc08920953e579163ec411c2a0d4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking read transaction with time out.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga5efc08920953e579163ec411c2a0d4f3">More...</a><br /></td></tr>
<tr class="separator:ga5efc08920953e579163ec411c2a0d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e732a37377b2f95dc9d0961d383af2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5e732a37377b2f95dc9d0961d383af2a">ad_i2c_write_read</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga5e732a37377b2f95dc9d0961d383af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform synchronous write/read transaction.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga5e732a37377b2f95dc9d0961d383af2a">More...</a><br /></td></tr>
<tr class="separator:ga5e732a37377b2f95dc9d0961d383af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488ac6f40a170cf804589d5076bb1bb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga488ac6f40a170cf804589d5076bb1bb6">ad_i2c_write_read_with_to</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen, uint8_t condition_flags, <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a> timeout)</td></tr>
<tr class="memdesc:ga488ac6f40a170cf804589d5076bb1bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform synchronous write/read transaction with time out.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga488ac6f40a170cf804589d5076bb1bb6">More...</a><br /></td></tr>
<tr class="separator:ga488ac6f40a170cf804589d5076bb1bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b2a9949b0c2d41722f3ad814be35c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab4b2a9949b0c2d41722f3ad814be35c5">ad_i2c_wait_while_master_busy</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p)</td></tr>
<tr class="memdesc:gab4b2a9949b0c2d41722f3ad814be35c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait while I2C master device is busy.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gab4b2a9949b0c2d41722f3ad814be35c5">More...</a><br /></td></tr>
<tr class="separator:gab4b2a9949b0c2d41722f3ad814be35c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedad123674a8383d3f7a0e7a27d6893c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaedad123674a8383d3f7a0e7a27d6893c">ad_i2c_write_async</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a> cb, void *user_data, uint8_t condition_flags)</td></tr>
<tr class="memdesc:gaedad123674a8383d3f7a0e7a27d6893c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a non blocking write transaction.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gaedad123674a8383d3f7a0e7a27d6893c">More...</a><br /></td></tr>
<tr class="separator:gaedad123674a8383d3f7a0e7a27d6893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054ec1413ed354953cb8c4862be210be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga054ec1413ed354953cb8c4862be210be">ad_i2c_read_async</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, uint8_t *rbuf, size_t rlen, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a> cb, void *user_data, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga054ec1413ed354953cb8c4862be210be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a non blocking read transaction.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga054ec1413ed354953cb8c4862be210be">More...</a><br /></td></tr>
<tr class="separator:ga054ec1413ed354953cb8c4862be210be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac69454b40f7ac974708077c3468dd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga7ac69454b40f7ac974708077c3468dd3">ad_i2c_write_read_async</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a> cb, void *user_data, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga7ac69454b40f7ac974708077c3468dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform write and asynchronous read I2C transaction.  <a href="group___i2_c___a_d_a_p_t_e_r.html#ga7ac69454b40f7ac974708077c3468dd3">More...</a><br /></td></tr>
<tr class="separator:ga7ac69454b40f7ac974708077c3468dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Inter Integrated Circuit adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae1ea113649ff626de4173a4ba95541b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ea113649ff626de4173a4ba95541b7">&#9670;&nbsp;</a></span>CONFIG_I2C_USE_ASYNC_TRANSACTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_USE_ASYNC_TRANSACTIONS&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether I2C asynchronous transaction API will be used. </p>
<p>I2C asynchronous transaction API (see "ad_i2c_xx_async" API) maintains state in RAM for every I2C bus declared. If the API is not to be used, setting this macro to 0 will save RAM. </p>

</div>
</div>
<a id="gaf0408c9e56fb249945b5b147011fc6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0408c9e56fb249945b5b147011fc6f8">&#9670;&nbsp;</a></span>CONFIG_I2C_USE_SYNC_TRANSACTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_USE_SYNC_TRANSACTIONS&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether I2C synchronous transaction API will be used. </p>
<p>I2C synchronous transaction API (see "ad_i2c_write_read", "ad_i2c_write", "ad_i2c_read" functions) maintains state in retention RAM for every I2C bus declared. If the API is not to be used, setting this macro to 0 will save retention RAM. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab9b665bf082202d3e106611b9fa0e260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b665bf082202d3e106611b9fa0e260">&#9670;&nbsp;</a></span>ad_i2c_user_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ad_i2c_user_cb) (void *user_data, <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous callback function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2d28fe9a89c02b4815c5d5f5c9ce24b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d28fe9a89c02b4815c5d5f5c9ce24b7">&#9670;&nbsp;</a></span>AD_I2C_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga2d28fe9a89c02b4815c5d5f5c9ce24b7">AD_I2C_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C adapter error codes. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1d3cd1892d3a7ed78d4b6702b416f101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d3cd1892d3a7ed78d4b6702b416f101">&#9670;&nbsp;</a></span>ad_i2c_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close I2C controller. </p>
<p>This function:</p><ul>
<li>Aborts ongoing transactions</li>
<li>De-initializes the drivers associated with the controller</li>
<li>Resets controller interface IOs (as specified in <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a>)</li>
<li>Releases the controller resources</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>force close even if controller is occupied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga1b3105a748890da0dec74c504185819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b3105a748890da0dec74c504185819a">&#9670;&nbsp;</a></span>ad_i2c_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize adapter. </p>

</div>
</div>
<a id="gaa1c20fb5b818d5ae61ad48b581cceadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1c20fb5b818d5ae61ad48b581cceadb">&#9670;&nbsp;</a></span>ad_i2c_io_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_io_config </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structad__i2c__io__conf__t.html">ad_i2c_io_conf_t</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_a_p_t_e_r.html#ga37f7ad66c2edac01fa114cd43d15d428">AD_IO_CONF_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize controller pins to on / off io configuration. </p>
<p>This function should be called for setting pins to the correct level before external devices are powered up (e.g on system init). It does not need to be called before every <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>controller io configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>on/off io configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code </dd></dl>

</div>
</div>
<a id="gabef785c2b17e762efd103e2ae6630403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef785c2b17e762efd103e2ae6630403">&#9670;&nbsp;</a></span>ad_i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> ad_i2c_open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structad__i2c__controller__conf__t.html">ad_i2c_controller_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open I2C controller. </p>
<p>This function:</p><ul>
<li>Acquires the resources needed for using the controller</li>
<li>Configures the controller interface IOs</li>
<li>Initializes the drivers associated with the controller</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>controller configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0: non-NULL handle that should be used in subsequent API calls, NULL: error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function will block until it acquires all controller resources </dd></dl>

</div>
</div>
<a id="ga3a9cadc282a01e3dbf0122596bd62c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9cadc282a01e3dbf0122596bd62c62">&#9670;&nbsp;</a></span>ad_i2c_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking read transaction. </p>
<p>This function performs a synchronous read only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga054ec1413ed354953cb8c4862be210be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054ec1413ed354953cb8c4862be210be">&#9670;&nbsp;</a></span>ad_i2c_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a non blocking read transaction. </p>
<p>This function performs an asynchronous read only transaction Caller task should retry until function returns no error Callback will be called when transaction is completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data passed to cb callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga5efc08920953e579163ec411c2a0d4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5efc08920953e579163ec411c2a0d4f3">&#9670;&nbsp;</a></span>ad_i2c_read_with_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_read_with_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking read transaction with time out. </p>
<p>This function performs a synchronous read only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>time in OS ticks that is expected for read to complete. If time out occurs AD_I2C_ERROR_TRANSFER_TIMEOUT error is returned. <p class="starttd">:: OS_EVENT_FOREVER<br  />
 function will block for ever expecting the completion of transfer. It behaves as <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3a9cadc282a01e3dbf0122596bd62c62" title="Perform a blocking read transaction.">ad_i2c_read()</a> function.</p>
<p class="endtd">:: 0<br  />
 will poll once and check if the transaction is completed. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="gafa0659b852cb6030cf508b9efc61c95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa0659b852cb6030cf508b9efc61c95d">&#9670;&nbsp;</a></span>ad_i2c_reconfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_reconfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structad__i2c__driver__conf__t.html">ad_i2c_driver_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure I2C controller. </p>
<p>This function will apply a new I2C driver configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>pointer to driver configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="gab4b2a9949b0c2d41722f3ad814be35c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b2a9949b0c2d41722f3ad814be35c5">&#9670;&nbsp;</a></span>ad_i2c_wait_while_master_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_wait_while_master_busy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait while I2C master device is busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>pointer returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga25d29ecd47d69bbf4d535950dc9a3ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d29ecd47d69bbf4d535950dc9a3ddf">&#9670;&nbsp;</a></span>ad_i2c_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking write transaction. </p>
<p>This function performs a synchronous write only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="gaedad123674a8383d3f7a0e7a27d6893c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedad123674a8383d3f7a0e7a27d6893c">&#9670;&nbsp;</a></span>ad_i2c_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a non blocking write transaction. </p>
<p>This function performs an asynchronous write only transaction Caller task should retry until function returns no error Callback will be called when transaction is completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data passed to cb callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga5e732a37377b2f95dc9d0961d383af2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e732a37377b2f95dc9d0961d383af2a">&#9670;&nbsp;</a></span>ad_i2c_write_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform synchronous write/read transaction. </p>
<p>This function performs a synchronous write and read transaction on I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga7ac69454b40f7ac974708077c3468dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac69454b40f7ac974708077c3468dd3">&#9670;&nbsp;</a></span>ad_i2c_write_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform write and asynchronous read I2C transaction. </p>
<p>This function performs asynchronous write and read transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga488ac6f40a170cf804589d5076bb1bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488ac6f40a170cf804589d5076bb1bb6">&#9670;&nbsp;</a></span>ad_i2c_write_read_with_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_read_with_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform synchronous write/read transaction with time out. </p>
<p>This function performs a synchronous write and read transaction on I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>time in OS ticks that is expected for transaction to complete. If time out occurs AD_I2C_ERROR_TRANSFER_TIMEOUT error is returned. <p class="starttd">:: OS_EVENT_FOREVER<br  />
 function will block for ever expecting the completion of transfer. It behaves as <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5e732a37377b2f95dc9d0961d383af2a" title="Perform synchronous write/read transaction.">ad_i2c_write_read()</a> function.</p>
<p class="endtd">:: 0<br  />
 will poll once and check if the transaction is completed. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a id="ga27ae581e37295ff9e7791a7d0ce784a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ae581e37295ff9e7791a7d0ce784a5">&#9670;&nbsp;</a></span>ad_i2c_write_with_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_with_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking write transaction with time out. </p>
<p>This function performs a synchronous write only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br  />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p class="intertd"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br  />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br  />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>time in OS ticks that is expected for write to complete. If time out occurs AD_I2C_ERROR_TRANSFER_TIMEOUT error is returned. <p class="starttd">:: OS_EVENT_FOREVER<br  />
 function will block for ever expecting the completion of transfer. It behaves as <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga25d29ecd47d69bbf4d535950dc9a3ddf" title="Perform a blocking write transaction.">ad_i2c_write()</a> function.</p>
<p class="endtd">:: 0<br  />
 will poll once and check if the transaction is completed. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller.">ad_i2c_open()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:42 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
