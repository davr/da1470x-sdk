<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: CLI programmer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">CLI programmer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md455"></a>
Overview</h1>
<p><code>cli_programmer</code> is a command line interface (CLI) memory programming tool. CLI offers an extensive command set targeting all programmable memories a device can be equipped with (RAM, QSPI-based Flash, OTP). The supported commands' functionality include memory accessing (R/W), diagnostics, NVMS related functions, and application firmware programming of the actual target device.</p>
<h1><a class="anchor" id="autotoc_md456"></a>
Usage</h1>
<p>To run the cli_programmer, the user has to specify the interface (GDB server or serial port) followed by the intended command name and its arguments. </p><pre class="fragment">cli_programmer [&lt;options&gt;] &lt;interface&gt; &lt;command&gt; [&lt;args&gt;]
</pre><h2><a class="anchor" id="autotoc_md457"></a>
Interface</h2>
<ul>
<li>the serial port file name as presented by the operating system e.g. <b><code>COM5</code></b> (Windows), <b><code>/dev/ttyUSB0</code></b> (Linux), or</li>
<li><b><code>gdbserver</code></b>, if JTAG interface is to be used (J-Link debugger with the GDB server that must first be initiated in another terminal session).</li>
</ul>
<blockquote class="doxtable">
<p>Note: Writing an image to flash requires adding a header to the image. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md458"></a>
Commands and arguments</h2>
<pre class="fragment">write_qspi &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the FLASH/RAM at <code>address</code>. If <code>size</code> is omitted, the complete file is written. </p><pre class="fragment">write_qspi_bytes &lt;address&gt; &lt;data1&gt; [&lt;data2&gt; [...]]
</pre><p>Writes bytes specified on command line into the FLASH/RAM at <code>address</code>. </p><pre class="fragment">read_qspi &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from the FLASH/RAM, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">erase_qspi &lt;address&gt; &lt;size&gt;
</pre><p>Erases <code>size</code> bytes of the FLASH, starting at <code>address</code>. Note: The actual area erased may be bigger, due to the size of the erase block. </p><pre class="fragment">chip_erase_qspi [&lt;address&gt;]
</pre><p>Completely erases the QSPI flash device starting at <code>address</code>. Note: if no address is given, the flash memory connected to the first QSPI controller is erased. </p><pre class="fragment">copy_qspi &lt;address_ram&gt; &lt;address_qspi&gt; &lt;size&gt;
</pre><p>Copies <code>size</code> bytes from the RAM memory, starting at <code>address_ram</code> to FLASH/RAM at <code>address_qspi</code>. This is an advanced command and is not needed by the end user. </p><pre class="fragment">is_empty_qspi [&lt;start_address&gt; &lt;size&gt;]
</pre><p>Checks if the FLASH contains only 0xFF values. If no arguments are specified, starting address is 0 and size is 16MB. Command prints whether flash is empty and, if not, the offset of first non empty byte. </p><pre class="fragment">read_partition_table
</pre><p>Reads the partition table (if any exists) and prints its contents. </p><pre class="fragment">read_partition &lt;part_name|part_id&gt; &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from partition, selected by <code>part_name</code> or <code>part_id</code> according to the below table, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">part_name  </th><th class="markdownTableHeadNone">part_id   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NVMS_FIRMWARE_PART  </td><td class="markdownTableBodyNone">1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NVMS_PARAM_PART  </td><td class="markdownTableBodyNone">2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NVMS_BIN_PART  </td><td class="markdownTableBodyNone">3   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NVMS_LOG_PART  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NVMS_GENERIC_PART  </td><td class="markdownTableBodyNone">5   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NVMS_PLATFORM_PARAMS_PART  </td><td class="markdownTableBodyNone">15   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NVMS_PARTITION_TABLE  </td><td class="markdownTableBodyNone">16   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NVMS_FW_EXEC_PART  </td><td class="markdownTableBodyNone">17   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NVMS_FW_UPDATE_PART  </td><td class="markdownTableBodyNone">18   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NVMS_PRODUCT_HEADER_PART  </td><td class="markdownTableBodyNone">19   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NVMS_IMAGE_HEADER_PART  </td><td class="markdownTableBodyNone">20   </td></tr>
</table>
<pre class="fragment">write_partition &lt;part_name|part_id&gt; &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into NVMS partition, selected by <code>part_name</code> or <code>part_id</code> according to the above table, at <code>address</code>. If <code>size</code> is omitted, the complete file is written. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">write_partition_bytes &lt;part_name|part_id&gt; &lt;address&gt; &lt;data1&gt; [&lt;data2&gt; [...]]
</pre><p>Writes bytes specified on command line into the NVMS partition, selected by <code>part_name</code> or <code>part_id</code> according to the above table, at <code>address</code>. </p><pre class="fragment">write &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the RAM memory at <code>address</code>. If <code>size</code> is omitted, the complete <code>file</code> is written. </p><pre class="fragment">read &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from the RAM memory, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">write_otp &lt;address&gt; &lt;length&gt; [&lt;data&gt; [&lt;data&gt; [...]]]
</pre><p>Writes <code>length</code> words to the OTP at <code>address</code>. <code>data</code> are 32-bit words to be written. If less than <code>length</code> words are specified, remaining words are assumed to be 0x00. </p><pre class="fragment">write_otp_raw_file &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the OTP at <code>address</code>. If <code>size</code> is omitted, the complete file is written. Remaining bytes in the last word are assumed to be 0x00. </p><pre class="fragment">read_otp &lt;address&gt; &lt;length&gt;
</pre><p>Reads <code>length</code> 32-bit words from the OTP at <code>address</code>. </p><pre class="fragment">write_otp_file &lt;file&gt;
</pre><p>Writes data to the OTP as defined in <code>file</code> (default specified values are written). <code>file</code> is a CSV file separated by tabs. <b> <code>example_otp_file.csv</code> </b> is an example file which could be used with this command. Most of columns in this file have only informational purpose. <code>cli_programmer</code> uses only the 'Address', 'Size' and 'Default' columns, but the other columns are also needed for proper parsing of the file. A short description of each column is given below:</p>
<ul>
<li><b> Address </b> - could be a cell address or cell address combined with <code>OTP_BASE</code> (0x07F80000)</li>
<li><b> Size </b> - number of bytes required by this item</li>
<li><b> Type </b> - type of item, e.g flag, region or byte</li>
<li><b> RW </b> or <b> RO </b> - read/write or read-only item (only for information)</li>
<li><b> ShortName </b> - name of item</li>
<li><b> Description </b> - short description about item. It could also contain option's values and descriptions.</li>
<li><b> Default </b> - value which will be written to OTP</li>
<li><b> Number of Options </b> - this column contains a number of options written in the next columns. Each option contains its description placed in a separate column as follows: option 1 | description 1 | option 2 | description 2 | ... <pre class="fragment">read_otp_file &lt;file&gt;
</pre></li>
</ul>
<p>Reads data from the OTP as defined in <code>file</code> (cells with default value provided are read) contents of each cell is printed to stdout. </p><pre class="fragment">boot &lt;binary_file&gt;
</pre><p>Boot application binary using the 1st stage bootloader (ROM booter) and then exit. If the application is too big (more than 64kB) and serial interface is used, then the 'run' command should be executed instead. </p><pre class="fragment">run &lt;binary_file&gt;
</pre><p>Run application binary using the 2nd stage bootloader (uartboot) and then exit. It supports bigger application binaries than 'boot' commands. The limitation is the 'BUFFER' section size in the 'uartboot' application. </p><pre class="fragment">get_product_info
</pre><p>Returns device classification and production information. The product information can serve as a unique identifier that is readable and not editable by the application. The information is a combination of device classification attributes (family, variant, chip ID, version) as stored in designated device registers, production layout (package, wafer number, die coordinates) and testing information as stored in the device's OTP memory.</p>
<p>**_NOTE:_** The testing timestamp value is printed in raw hex format and equals to the seconds passed since Jan 1, 2009, 00:00:00 (UTC). </p><pre class="fragment">write_oqspi &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the FLASH at <code>address</code>. If <code>size</code> is omitted, the complete file is written. </p><pre class="fragment">write_oqspi_bytes &lt;address&gt; &lt;data1&gt; [&lt;data2&gt; [...]]
</pre><p>Writes bytes specified on command line into the FLASH at <code>address</code>. </p><pre class="fragment">read_oqspi &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from the FLASH memory, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">erase_oqspi &lt;address&gt; &lt;size&gt;
</pre><p>Erases <code>size</code> bytes of the FLASH, starting at <code>address</code>. Note: The actual area erased may be bigger, due to the size of the erase block. </p><pre class="fragment">chip_erase_oqspi [&lt;address&gt;]
</pre><p>Completely erases the OQSPI flash device starting at <code>address</code>. Note: if no address is given, the flash memory connected to the OQSPI controller is erased. </p><pre class="fragment">copy_oqspi &lt;address_ram&gt; &lt;address_oqspi&gt; &lt;size&gt;
</pre><p>Copies <code>size</code> bytes from the RAM memory, starting at <code>address_ram</code> to FLASH at <code>address_oqspi</code>. This is an advanced command an is not needed by end user. </p><pre class="fragment">is_empty_oqspi [&lt;start_address&gt; &lt;size&gt;]
</pre><p>Checks if the FLASH contains only 0xFF values. If no arguments are specified, starting address is 0 and size is 8MB. Command prints whether flash is empty and, if not, the offset of first non empty byte. </p><pre class="fragment">read_flash_info
</pre><p>Reads manufacturer ID as well as device type and density of all the available flash memories.</p>
<h2><a class="anchor" id="autotoc_md459"></a>
General options</h2>
<pre class="fragment">-h
</pre><p>Prints help screen and exits. </p><pre class="fragment">--save-ini
</pre><p>Saves CLI programmer configuration to the <code>cli_programmer.ini</code> file and exits. </p><pre class="fragment">-b &lt;file&gt;
</pre><p>Filename of 2nd stage bootloader or application binary. In GDB Server interface mode, this could be also the 'attach' keyword. This keyword omits platform reset and loading of bootloader binary. </p><pre class="fragment">--trc &lt;cmd&gt;
</pre><p>Target reset command. May be used if there is a need to replace the default localhost reset command. This option shouldn't be used with the '&ndash;check-booter-load' option - in such a case, it is ignored.</p>
<h2><a class="anchor" id="autotoc_md460"></a>
GDB server specific options</h2>
<pre class="fragment">-p &lt;port_num&gt;
</pre><p>TCP port number that GDB server listens to. The Default value is 2331. </p><pre class="fragment">-r &lt;host&gt;
</pre><p>GNU server host. The default is `localhost`. </p><pre class="fragment">--no-kill [mode]
</pre><p>Don't stop running GDB Server instances. Available modes: \'0\': Stop GDB Server instances during initialization and closing \'1\': Don't stop GDB Server during initialization \'2\': Don't stop GDB Server during closing \'3\' or none: Don't stop any GDB Server instance (default)</p>
<pre class="fragment">--gdb-cmd &lt;cmd&gt;
</pre><p>GDB server command used for executing and passing the right parameters to GDB server. Without this parameter, no GDB server instance will be started or stopped. As GDB server command line can be quite long, it is recommended that it is stored in cli_programmer.ini file using &ndash;save-ini command line option. </p><pre class="fragment">--check-booter-load
</pre><p>Don't force bootloader loading if it is running on the platform already. This option shouldn't be used with the '&ndash;trc' option - in such a case, the '&ndash;trc' option is ignored.</p>
<h2><a class="anchor" id="autotoc_md461"></a>
Serial port specific options</h2>
<pre class="fragment">-s &lt;baudrate&gt;
</pre><p>Baud rate used for UART by uartboot. The parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). This can be 9600, 19200, 57600, 115200, 230400, 500000, 1000000 (default). </p><pre class="fragment">-i &lt;baudrate&gt;
</pre><p>Initial baud rate used for uploading the uartboot or a user supplied binary. This depends on the rate used by the bootloader of the device. The default behavior is to use the value passed by '-s' or its default, if the parameter is not given. The argument is ignored by the <code>boot</code> command. '-s' option should be used in this case. </p><pre class="fragment">--tx-port &lt;port_num&gt;
</pre><p>GPIO port used for UART Tx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 0. The argument is ignored when the <code>boot</code> command is given. <br  />
 </p><pre class="fragment">--tx-pin &lt;pin_num&gt;
</pre><p>GPIO pin used for UART Tx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 8. The argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">--rx-port &lt;port_num&gt;
</pre><p>GPIO port used for UART Rx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 2. The argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">--rx-pin &lt;pin_num&gt;
</pre><p>GPIO pin used for UART Rx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 1. The argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">-w &lt;timeout&gt;
</pre><p>Serial port communication timeout is used only during download of uartboot binary. If the device does not respond during this time, cli_programmer exits with timeout error.</p>
<h2><a class="anchor" id="autotoc_md462"></a>
Configuration file</h2>
<p>When cli_programmer is executed, it first tries to read cli_programmer.ini file which may contain various cli_programmer options. Instead of creating this file manually, user should use &ndash;save-ini command line option. Format of cli_programmer.ini adheres to standard Windows ini file syntax. The cli_programmer looks for ini file in the following locations:</p>
<ul>
<li>current directory</li>
<li>home directory</li>
<li>cli_programmer executable directory</li>
</ul>
<h1><a class="anchor" id="autotoc_md463"></a>
Usage examples</h1>
<p>Read data from FLASH/RAM to local file. </p><pre class="fragment">cli_programmer COM40 read_qspi 0x0 data_o 0x100
</pre><p>Upload custom binary <code>test_api.bin</code> to RAM and execute it. </p><pre class="fragment">cli_programmer -b test_api.bin COM40 boot
</pre><p>Modify FLASH/RAM at specified location with arguments passed in command line. </p><pre class="fragment">cli_programmer COM40 write_qspi_bytes 0x80000 0x11 0x22 0x33
</pre><p>Run a few commands with uartboot, using UART Tx/Rx P0_9/P2_2 at baud rate 115200 (initial rate for uartboot uploading is 9600). </p><pre class="fragment">cli_programmer -i 9600 -s 115200 --tx-port 0 --tx-pin 9 --rx-port 2 --rx-pin 2 COM40 write_qspi 0x0 data_i
cli_programmer -i 9600 -s 115200 --tx-port 0 --tx-pin 9 --rx-port 2 --rx-pin 2 COM40 read_qspi 0x0 data_o 0x100
</pre><p>Read FLASH/RAM contents (10 bytes at address 0x0). </p><pre class="fragment">cli_programmer gdbserver read_qspi 0 -- 10
</pre><p>Write settings to the <code>cli_programmer.ini</code> file. Long bootloader path is passed with -b option and command line to start GDB server is passed with &ndash;gdb-cmd. In this example GDB server command line contains arguments and path to executable has space so whole command line is put in quotes and quotes required by Windows path are additionally escaped. </p><pre class="fragment">cli_programmer -b c:\users\user\sdk\bsp\system\loaders\uartboot\Release\uartboot.bin --save-ini --gdb-cmd "\"C:\Program Files (x86)\SEGGER\JLink_V722b\JLinkGDBServerCL.exe\" -if SWD -device Cortex-M33 -singlerun -silent -speed auto"
</pre><p>Write OTP address 0x07f80128 with the following contents: B0:0x00, B1:0x01, B2:0x02, B3:0x03, B4:0x04, B5:0x05, B6:0x06, B7:0x07 </p><pre class="fragment"> cli_programmer gdbserver write_otp 0x07f80128 2 0x03020100 0x07060504
</pre><p>Read OTP address 0x07f80128. </p><pre class="fragment"> cli_programmer gdbserver read_otp 0x07f80128 2

 If written with the contents from above write example, it should return
 0025   00 01 02 03 04 05 06 07   ........
</pre><h1><a class="anchor" id="autotoc_md464"></a>
Building cli_programmer</h1>
<ul>
<li>'cli_programmer' makes use of the 'libprogrammer' library which implements the underlying functionality on the host side. 'cli_programmer' can be linked either statically or dynamically with 'libprogrammer'.</li>
<li>'cli_programmer' uses 'uartboot' application which acts as a secondary bootloader which cli_programmer downloads to the target for servicing the requested command's operations.</li>
<li>The project and the relevant source code of the CLI are located under <code>utilities/cli_programmer/cli</code> folder</li>
<li>The project and the relevant source code of the <code>uartboot</code> are located under <code>sdk/bsp/system/loaders/uartboot</code> folder</li>
<li>Build configurations:<ul>
<li>Release_static_linux - Release version linked with a static version of libprogrammer - recommended for Linux. It also builds uartboot project and includes it in cli_programmer executable.</li>
<li>Release_static_win32 - Release 32bit version for Windows linked with a static version of libprogrammer.</li>
<li>Release_static_win64 - Release 64bit version for Windows linked with a static version of libprogrammer.</li>
</ul>
</li>
<li>Build instructions:<ul>
<li>Import <code>libprogrammer</code>, <code>cli_programmer</code> and <code>uartboot</code> into SmartSnippets Studio.</li>
<li>Build <code>libprogrammer</code> , <code>cli_programmer</code> and <code>uartboot</code>.</li>
<li>Run <code>cli_programmer</code> with proper parameters, as described in <code>Usage</code> and <code>Commands and arguments</code> sections.</li>
</ul>
</li>
</ul>
<blockquote class="doxtable">
<p>Notes:</p><ul>
<li>A prebuilt version of <code>cli_programmer</code> can be found under SDK's <code>binaries</code> folder.</li>
<li>Building <code>cli_programmer</code> updates SDK's <code>binaries</code> folder (the new binaries are copied there).</li>
<li>Linux <code>cli_programmer</code> binaries built using the dynamic build configurations search for the library </li>
</ul>
</blockquote>
<p>file <code>libprogrammer.so</code> explicitly in the <code>binaries</code> folder. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:40 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
