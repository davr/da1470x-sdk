<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: eMMC Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">eMMC Driver<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___d_r_i_v_e_r_s.html">Drivers</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___m_e_m_o_r_y.html">Memory Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>embedded Multi-Media Card (eMMC) Low Level Driver  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__emmc_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__emmc_8h.html">hw_emmc.h</a></td></tr>
<tr class="memdesc:hw__emmc_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the embedded Multi-Media Card (eMMC) Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__emmc__card__access__t.html">hw_emmc_card_access_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">eMMC card access data structure  <a href="structhw__emmc__card__access__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__emmc__context__data__t.html">hw_emmc_context_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">eMMC saved data/context structure  <a href="structhw__emmc__context__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__hw__emmc__prg__csd__t.html">_hw_emmc_prg_csd_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSD programmable part structure, bits 8:15.  <a href="struct__hw__emmc__prg__csd__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga80bf3132358b4e102ebbdfc466d5c1f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga80bf3132358b4e102ebbdfc466d5c1f7">HW_EMMC_ACTIVE_NORMAL_INTERRUPTS_MASK</a></td></tr>
<tr class="separator:ga80bf3132358b4e102ebbdfc466d5c1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d3786c309cf7a35996822a60190929"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gac7d3786c309cf7a35996822a60190929">HW_EMMC_NON_IMPL_NORMAL_INTERRUPTS_MASK</a></td></tr>
<tr class="separator:gac7d3786c309cf7a35996822a60190929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a0c07ec13df90a42f7cc19cfe6bf8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga76a0c07ec13df90a42f7cc19cfe6bf8b">HW_EMMC_ACTIVE_ERROR_INTERRUPTS_MASK</a></td></tr>
<tr class="separator:ga76a0c07ec13df90a42f7cc19cfe6bf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2084d20dac8e0bcb1d66e8d78147ed75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga2084d20dac8e0bcb1d66e8d78147ed75">HW_EMMC_NON_IMPL_ERROR_INTERRUPTS_MASK</a></td></tr>
<tr class="separator:ga2084d20dac8e0bcb1d66e8d78147ed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7656a53420393598b03c8865fa3177"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga8b7656a53420393598b03c8865fa3177">HW_EMMC_HC_TIMEOUT_ERASE_FACTOR_MS</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="separator:ga8b7656a53420393598b03c8865fa3177"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac00380a314ec1503b5e9ba74fca8bb2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gac00380a314ec1503b5e9ba74fca8bb2d">HW_EMMC_CARD_CMD_CLASS</a> { <br />
&#160;&#160;<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da81e14ddaad8ddb40611f018e70a782cc">HW_EMMC_CARD_CMD_CLASS_0_BASIC</a> = (1 &lt;&lt; 0), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da3b9d06a267f2d428b04531cb580a1848">HW_EMMC_CARD_CMD_CLASS_1_STREAM_RD</a> = (1 &lt;&lt; 1), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da8e3e9334eb0feaafde4a50e78ccc404e">HW_EMMC_CARD_CMD_CLASS_2_BLK_RD</a> = (1 &lt;&lt; 2), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da9a2cbdf054ff02d52384e3a263c6f9b1">HW_EMMC_CARD_CMD_CLASS_3_STREAM_WR</a> = (1 &lt;&lt; 3), 
<br />
&#160;&#160;<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da6bb63efaa85cc9a8da28ae08043249a9">HW_EMMC_CARD_CMD_CLASS_4_BLK_WR</a> = (1 &lt;&lt; 4), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da29197a769a9ebd29f6a666a3ca81aeeb">HW_EMMC_CARD_CMD_CLASS_5_ERASE</a> = (1 &lt;&lt; 5), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da226ed3beb5ae3ee764de735f428fcc9c">HW_EMMC_CARD_CMD_CLASS_6_WP</a> = (1 &lt;&lt; 6), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da5035cfbc0de3c527659c286945b143ba">HW_EMMC_CARD_CMD_CLASS_7_LOCK</a> = (1 &lt;&lt; 7), 
<br />
&#160;&#160;<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da6867948f076af19cd638dbfc9526070c">HW_EMMC_CARD_CMD_CLASS_8_APP</a> = (1 &lt;&lt; 8), 
<a class="el" href="group___h_w___e_m_m_c.html#ggac00380a314ec1503b5e9ba74fca8bb2da3bc3a8ff21a2216a41271bee68fb85e9">HW_EMMC_CARD_CMD_CLASS_9_IO</a> = (1 &lt;&lt; 9)
<br />
 }</td></tr>
<tr class="memdesc:gac00380a314ec1503b5e9ba74fca8bb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported card command classes.  <a href="group___h_w___e_m_m_c.html#gac00380a314ec1503b5e9ba74fca8bb2d">More...</a><br /></td></tr>
<tr class="separator:gac00380a314ec1503b5e9ba74fca8bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0167059c1ec8872e4c9ca3bd805d7d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga0167059c1ec8872e4c9ca3bd805d7d93">hw_emmc_enable</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const <a class="el" href="structhw__sdhc__pdctrl__reg__config__t.html">hw_sdhc_pdctrl_reg_config_t</a> *config)</td></tr>
<tr class="memdesc:ga0167059c1ec8872e4c9ca3bd805d7d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Host Controller (HC)  <a href="group___h_w___e_m_m_c.html#ga0167059c1ec8872e4c9ca3bd805d7d93">More...</a><br /></td></tr>
<tr class="separator:ga0167059c1ec8872e4c9ca3bd805d7d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0ae985a98b362c57b4d989ff22021c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gacb0ae985a98b362c57b4d989ff22021c">hw_emmc_disable</a> (const <a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gacb0ae985a98b362c57b4d989ff22021c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Host Controller (HC)  <a href="group___h_w___e_m_m_c.html#gacb0ae985a98b362c57b4d989ff22021c">More...</a><br /></td></tr>
<tr class="separator:gacb0ae985a98b362c57b4d989ff22021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71ea286fd9fd9eef8e0ab25ae358032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gab71ea286fd9fd9eef8e0ab25ae358032">hw_emmc_hw_reset_card</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t rst_pulse_us)</td></tr>
<tr class="memdesc:gab71ea286fd9fd9eef8e0ab25ae358032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware reset the eMMC card.  <a href="group___h_w___e_m_m_c.html#gab71ea286fd9fd9eef8e0ab25ae358032">More...</a><br /></td></tr>
<tr class="separator:gab71ea286fd9fd9eef8e0ab25ae358032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9c8066f2d33c043dd9af9652167fb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4">hw_emmc_init</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const <a class="el" href="structhw__sdhc__config__t.html">hw_sdhc_config_t</a> *config, <a class="el" href="group___h_w___s_d_h_c.html#gaa5bdf0ce65ec1315d33582ef70ce5808">hw_sdhc_event_callback_t</a> cb, const <a class="el" href="structhw__emmc__context__data__t.html">hw_emmc_context_data_t</a> **ptr_emmc_context)</td></tr>
<tr class="memdesc:ga1d9c8066f2d33c043dd9af9652167fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">eMMC initialization  <a href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4">More...</a><br /></td></tr>
<tr class="separator:ga1d9c8066f2d33c043dd9af9652167fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae216f26d6d559d11e790e12c674f3074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gae216f26d6d559d11e790e12c674f3074">hw_emmc_deinit</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gae216f26d6d559d11e790e12c674f3074"><td class="mdescLeft">&#160;</td><td class="mdescRight">eMMC de-initialization  <a href="group___h_w___e_m_m_c.html#gae216f26d6d559d11e790e12c674f3074">More...</a><br /></td></tr>
<tr class="separator:gae216f26d6d559d11e790e12c674f3074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ca471744d2e01d8788f171a644e661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga64ca471744d2e01d8788f171a644e661">hw_emmc_is_busy</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:ga64ca471744d2e01d8788f171a644e661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy.  <a href="group___h_w___e_m_m_c.html#ga64ca471744d2e01d8788f171a644e661">More...</a><br /></td></tr>
<tr class="separator:ga64ca471744d2e01d8788f171a644e661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f473adb742fb6a7a1fe26e817b2a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga08f473adb742fb6a7a1fe26e817b2a17">hw_emmc_set_data_bus_width</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, <a class="el" href="group___h_w___s_d_h_c.html#ga7c4eb21ec1769b6938b16eab15e2372d">HW_SDHC_BUS_WIDTH</a> bus_width)</td></tr>
<tr class="memdesc:ga08f473adb742fb6a7a1fe26e817b2a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data bus width using SWITCH command (CMD6)  <a href="group___h_w___e_m_m_c.html#ga08f473adb742fb6a7a1fe26e817b2a17">More...</a><br /></td></tr>
<tr class="separator:ga08f473adb742fb6a7a1fe26e817b2a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cba6431a9b8f3904b8744cda7ec21d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga16cba6431a9b8f3904b8744cda7ec21d">hw_emmc_set_speed_mode</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint8_t speed_mode)</td></tr>
<tr class="memdesc:ga16cba6431a9b8f3904b8744cda7ec21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data bus speed using SWITCH command (CMD6)  <a href="group___h_w___e_m_m_c.html#ga16cba6431a9b8f3904b8744cda7ec21d">More...</a><br /></td></tr>
<tr class="separator:ga16cba6431a9b8f3904b8744cda7ec21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6e17c12d45de3f1268c53deb4ef27a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga0e6e17c12d45de3f1268c53deb4ef27a">hw_emmc_setup_data_bus</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const <a class="el" href="structhw__sdhc__bus__config__t.html">hw_sdhc_bus_config_t</a> *bus_config)</td></tr>
<tr class="memdesc:ga0e6e17c12d45de3f1268c53deb4ef27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data bus width, speed mode, speed/frequency, drive strength.  <a href="group___h_w___e_m_m_c.html#ga0e6e17c12d45de3f1268c53deb4ef27a">More...</a><br /></td></tr>
<tr class="separator:ga0e6e17c12d45de3f1268c53deb4ef27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2e6140574b006c9265616c69ea804b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga9e2e6140574b006c9265616c69ea804b">hw_emmc_data_xfer</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const <a class="el" href="structhw__sdhc__data__transfer__config__t.html">hw_sdhc_data_transfer_config_t</a> *config)</td></tr>
<tr class="memdesc:ga9e2e6140574b006c9265616c69ea804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue CMD with Data Transfer (Non-DMA/PIO, SDMA, ADMA2)  <a href="group___h_w___e_m_m_c.html#ga9e2e6140574b006c9265616c69ea804b">More...</a><br /></td></tr>
<tr class="separator:ga9e2e6140574b006c9265616c69ea804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc52e076d7497120c9f0e6653b9fecd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gabc52e076d7497120c9f0e6653b9fecd1">hw_emmc_abort_xfer</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, <a class="el" href="group___h_w___s_d_h_c.html#ga4f8ec08c73664aa4547459662dba029a">HW_SDHC_ABORT_METHOD</a> abort_method, uint32_t tout_ms)</td></tr>
<tr class="memdesc:gabc52e076d7497120c9f0e6653b9fecd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transfer abort.  <a href="group___h_w___e_m_m_c.html#gabc52e076d7497120c9f0e6653b9fecd1">More...</a><br /></td></tr>
<tr class="separator:gabc52e076d7497120c9f0e6653b9fecd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0396258eade32055aa87a34e2b35d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaeb0396258eade32055aa87a34e2b35d7">hw_emmc_error_recovery</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t tout_ms)</td></tr>
<tr class="memdesc:gaeb0396258eade32055aa87a34e2b35d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transfer error recovery.  <a href="group___h_w___e_m_m_c.html#gaeb0396258eade32055aa87a34e2b35d7">More...</a><br /></td></tr>
<tr class="separator:gaeb0396258eade32055aa87a34e2b35d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45bccd4efce7f468a3711a89dcd079b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gae45bccd4efce7f468a3711a89dcd079b">hw_emmc_get_card_cid</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gae45bccd4efce7f468a3711a89dcd079b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Card Identification Register (CID) using the command SEND_CID (CMD10) and update the driver emmc_context, accordingly. The pointer to emmc_context is returned at <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>.  <a href="group___h_w___e_m_m_c.html#gae45bccd4efce7f468a3711a89dcd079b">More...</a><br /></td></tr>
<tr class="separator:gae45bccd4efce7f468a3711a89dcd079b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0806a561e7e672c08bfa0613788b7f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga0806a561e7e672c08bfa0613788b7f28">hw_emmc_program_cid</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const <a class="el" href="structhw__sdhc__emmc__cid__t.html">hw_sdhc_emmc_cid_t</a> *prg_cid)</td></tr>
<tr class="memdesc:ga0806a561e7e672c08bfa0613788b7f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program the Card Identification Register (CID), using the command PROGRAM_CID (CMD26)  <a href="group___h_w___e_m_m_c.html#ga0806a561e7e672c08bfa0613788b7f28">More...</a><br /></td></tr>
<tr class="separator:ga0806a561e7e672c08bfa0613788b7f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46c8958495a598846d50eed7cf9b8f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gac46c8958495a598846d50eed7cf9b8f6">hw_emmc_get_card_csd</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gac46c8958495a598846d50eed7cf9b8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Card Specific Data Register (CSD) using the command SEND_CSD (CMD9) and update the driver emmc_context, accordingly. The pointer to emmc_context is returned at <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>.  <a href="group___h_w___e_m_m_c.html#gac46c8958495a598846d50eed7cf9b8f6">More...</a><br /></td></tr>
<tr class="separator:gac46c8958495a598846d50eed7cf9b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab81acddafe08f1ae5a56b6123b53d65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gab81acddafe08f1ae5a56b6123b53d65e">hw_emmc_program_csd</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const hw_emmc_prg_csd_t prg_csd)</td></tr>
<tr class="memdesc:gab81acddafe08f1ae5a56b6123b53d65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program the programmable part of Card Specific Data Register (CSD), using the command PROGRAM_CSD (CMD27) The programmable bits of CSD are 8 to 15.  <a href="group___h_w___e_m_m_c.html#gab81acddafe08f1ae5a56b6123b53d65e">More...</a><br /></td></tr>
<tr class="separator:gab81acddafe08f1ae5a56b6123b53d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55c1e668ca760654dddd551cfd3b479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaf55c1e668ca760654dddd551cfd3b479">hw_emmc_get_card_ext_csd</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gaf55c1e668ca760654dddd551cfd3b479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Extended Card Specific Data Register (EXT_CSD) using the command SEND_EXT_CSD (CMD8) and update the driver emmc_context, accordingly. The pointer to emmc_context is returned at <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>.  <a href="group___h_w___e_m_m_c.html#gaf55c1e668ca760654dddd551cfd3b479">More...</a><br /></td></tr>
<tr class="separator:gaf55c1e668ca760654dddd551cfd3b479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe7a4dbf666caaf8d428829cf715920a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gafe7a4dbf666caaf8d428829cf715920a">hw_emmc_get_card_status_register</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t *status_reg)</td></tr>
<tr class="memdesc:gafe7a4dbf666caaf8d428829cf715920a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get card status register using the command SEND_STATUS (CMD13)  <a href="group___h_w___e_m_m_c.html#gafe7a4dbf666caaf8d428829cf715920a">More...</a><br /></td></tr>
<tr class="separator:gafe7a4dbf666caaf8d428829cf715920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6013e5c767f97a60fbf5bfccc5153537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga6013e5c767f97a60fbf5bfccc5153537">hw_emmc_sleep</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t tout_ms)</td></tr>
<tr class="memdesc:ga6013e5c767f97a60fbf5bfccc5153537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch an eMMC card to Sleep state.  <a href="group___h_w___e_m_m_c.html#ga6013e5c767f97a60fbf5bfccc5153537">More...</a><br /></td></tr>
<tr class="separator:ga6013e5c767f97a60fbf5bfccc5153537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ec3ecfa5298e6e8ad92acf4a1b8be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaa9ec3ecfa5298e6e8ad92acf4a1b8be1">hw_emmc_awake</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t tout_ms)</td></tr>
<tr class="memdesc:gaa9ec3ecfa5298e6e8ad92acf4a1b8be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch an eMMC card from Sleep to Transfer state.  <a href="group___h_w___e_m_m_c.html#gaa9ec3ecfa5298e6e8ad92acf4a1b8be1">More...</a><br /></td></tr>
<tr class="separator:gaa9ec3ecfa5298e6e8ad92acf4a1b8be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4e26c34473a7dd11f236aa5fcbe5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gafe4e26c34473a7dd11f236aa5fcbe5a8">hw_emmc_start_hc_clocks</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gafe4e26c34473a7dd11f236aa5fcbe5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Host Controller internal and SD Bus clocks.  <a href="group___h_w___e_m_m_c.html#gafe4e26c34473a7dd11f236aa5fcbe5a8">More...</a><br /></td></tr>
<tr class="separator:gafe4e26c34473a7dd11f236aa5fcbe5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450b2cb82aeac1f4b0eae1857b990145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga450b2cb82aeac1f4b0eae1857b990145">hw_emmc_stop_hc_clocks</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:ga450b2cb82aeac1f4b0eae1857b990145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop Host Controller internal and SD Bus clocks.  <a href="group___h_w___e_m_m_c.html#ga450b2cb82aeac1f4b0eae1857b990145">More...</a><br /></td></tr>
<tr class="separator:ga450b2cb82aeac1f4b0eae1857b990145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad928a0b1eb0dfe630477a1bcec34b93d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gad928a0b1eb0dfe630477a1bcec34b93d">hw_emmc_erase_groups</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t start_erase_group, uint32_t end_erase_group, uint32_t tout_ms)</td></tr>
<tr class="memdesc:gad928a0b1eb0dfe630477a1bcec34b93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified erase groups using CMD35, 36 and 38.  <a href="group___h_w___e_m_m_c.html#gad928a0b1eb0dfe630477a1bcec34b93d">More...</a><br /></td></tr>
<tr class="separator:gad928a0b1eb0dfe630477a1bcec34b93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256ccc6f2d37e4f8db0da552783e79fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga256ccc6f2d37e4f8db0da552783e79fa">hw_emmc_erase_groups_secure</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t start_erase_group, uint32_t end_erase_group, uint32_t tout_ms)</td></tr>
<tr class="memdesc:ga256ccc6f2d37e4f8db0da552783e79fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure Erase the specified erase groups using CMD35, 36 and 38.  <a href="group___h_w___e_m_m_c.html#ga256ccc6f2d37e4f8db0da552783e79fa">More...</a><br /></td></tr>
<tr class="separator:ga256ccc6f2d37e4f8db0da552783e79fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeace3e329a641e929623ab3ae921ea35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaeace3e329a641e929623ab3ae921ea35">hw_emmc_trim_blocks</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t start_addr, uint32_t end_addr, uint32_t tout_ms)</td></tr>
<tr class="memdesc:gaeace3e329a641e929623ab3ae921ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim (erase) the specified card sectors/blocks using CMD35, 36 and 38.  <a href="group___h_w___e_m_m_c.html#gaeace3e329a641e929623ab3ae921ea35">More...</a><br /></td></tr>
<tr class="separator:gaeace3e329a641e929623ab3ae921ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62422cba847d2fe49a9a6ba8e2e8d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaa62422cba847d2fe49a9a6ba8e2e8d1e">hw_emmc_trim_mark_blocks_secure</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t start_addr, uint32_t end_addr, uint32_t tout_ms)</td></tr>
<tr class="memdesc:gaa62422cba847d2fe49a9a6ba8e2e8d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the specified card sectors/blocks for Secure Trim (erase) using CMD35, 36 and 38 This is the Secure Trim Step 1.  <a href="group___h_w___e_m_m_c.html#gaa62422cba847d2fe49a9a6ba8e2e8d1e">More...</a><br /></td></tr>
<tr class="separator:gaa62422cba847d2fe49a9a6ba8e2e8d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18598e4e77e198fb6487a1986c45080d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga18598e4e77e198fb6487a1986c45080d">hw_emmc_trim_blocks_secure</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, uint32_t tout_ms)</td></tr>
<tr class="memdesc:ga18598e4e77e198fb6487a1986c45080d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure Trim (erase) the specified card sectors/blocks using CMD35, 36 and 38 This is the Secure Trim Step 2.  <a href="group___h_w___e_m_m_c.html#ga18598e4e77e198fb6487a1986c45080d">More...</a><br /></td></tr>
<tr class="separator:ga18598e4e77e198fb6487a1986c45080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba8c097adc17f81b6c0bf9d0f422f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga2ba8c097adc17f81b6c0bf9d0f422f91">hw_emmc_card_set_password</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const uint8_t *pwd, uint8_t len, bool lock)</td></tr>
<tr class="memdesc:ga2ba8c097adc17f81b6c0bf9d0f422f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a password that can be used to lock the card.  <a href="group___h_w___e_m_m_c.html#ga2ba8c097adc17f81b6c0bf9d0f422f91">More...</a><br /></td></tr>
<tr class="separator:ga2ba8c097adc17f81b6c0bf9d0f422f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd146f4c64bbf0c4fc63c349438836a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gadd146f4c64bbf0c4fc63c349438836a1">hw_emmc_card_clr_password</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const uint8_t *pwd, uint8_t len)</td></tr>
<tr class="memdesc:gadd146f4c64bbf0c4fc63c349438836a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the password that has been set to lock the card.  <a href="group___h_w___e_m_m_c.html#gadd146f4c64bbf0c4fc63c349438836a1">More...</a><br /></td></tr>
<tr class="separator:gadd146f4c64bbf0c4fc63c349438836a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68ce4dda534589f454f0b12f6599800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gae68ce4dda534589f454f0b12f6599800">hw_emmc_card_replace_password</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const uint8_t *old_pwd, uint8_t old_len, const uint8_t *new_pwd, uint8_t new_len, bool lock)</td></tr>
<tr class="memdesc:gae68ce4dda534589f454f0b12f6599800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the password that has been set to lock the card with a new one.  <a href="group___h_w___e_m_m_c.html#gae68ce4dda534589f454f0b12f6599800">More...</a><br /></td></tr>
<tr class="separator:gae68ce4dda534589f454f0b12f6599800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d033d576092d513cba40098f56f3b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga7d033d576092d513cba40098f56f3b8c">hw_emmc_card_lock</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const uint8_t *pwd, uint8_t len)</td></tr>
<tr class="memdesc:ga7d033d576092d513cba40098f56f3b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the card using the password that has been already set.  <a href="group___h_w___e_m_m_c.html#ga7d033d576092d513cba40098f56f3b8c">More...</a><br /></td></tr>
<tr class="separator:ga7d033d576092d513cba40098f56f3b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0af7f0cd8b11941be9aaf068782c695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaf0af7f0cd8b11941be9aaf068782c695">hw_emmc_card_unlock</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id, const uint8_t *pwd, uint8_t len)</td></tr>
<tr class="memdesc:gaf0af7f0cd8b11941be9aaf068782c695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the card using the password that has been already set.  <a href="group___h_w___e_m_m_c.html#gaf0af7f0cd8b11941be9aaf068782c695">More...</a><br /></td></tr>
<tr class="separator:gaf0af7f0cd8b11941be9aaf068782c695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaececba012bad5aee756a1794d9263916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaececba012bad5aee756a1794d9263916">hw_emmc_card_force_erase</a> (<a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a> id)</td></tr>
<tr class="memdesc:gaececba012bad5aee756a1794d9263916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the card data content along with the password content (Forced Erase)  <a href="group___h_w___e_m_m_c.html#gaececba012bad5aee756a1794d9263916">More...</a><br /></td></tr>
<tr class="separator:gaececba012bad5aee756a1794d9263916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b3665ef2dcc19a8dbecc5edfebd4925"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga9b3665ef2dcc19a8dbecc5edfebd4925">hw_emmc_get_erase_group_size</a> (void)</td></tr>
<tr class="memdesc:ga9b3665ef2dcc19a8dbecc5edfebd4925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the erase group size, based on ERASE_GROUP_DEF = EXT_CSD[175].  <a href="group___h_w___e_m_m_c.html#ga9b3665ef2dcc19a8dbecc5edfebd4925">More...</a><br /></td></tr>
<tr class="separator:ga9b3665ef2dcc19a8dbecc5edfebd4925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a141199f74dff3faa146b2bf5349a8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga77a141199f74dff3faa146b2bf5349a8">hw_emmc_get_wp_group_size</a> (void)</td></tr>
<tr class="memdesc:ga77a141199f74dff3faa146b2bf5349a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the write protect group size, based on ERASE_GROUP_DEF = EXT_CSD[175].  <a href="group___h_w___e_m_m_c.html#ga77a141199f74dff3faa146b2bf5349a8">More...</a><br /></td></tr>
<tr class="separator:ga77a141199f74dff3faa146b2bf5349a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba66192a223e6e87c31200c2e0b52d4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga0ba66192a223e6e87c31200c2e0b52d4">hw_emmc_get_erase_timeout_ms</a> (void)</td></tr>
<tr class="memdesc:ga0ba66192a223e6e87c31200c2e0b52d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the erase timeout in msec of one logical erase group, based on ERASE_GROUP_DEF = EXT_CSD[175].  <a href="group___h_w___e_m_m_c.html#ga0ba66192a223e6e87c31200c2e0b52d4">More...</a><br /></td></tr>
<tr class="separator:ga0ba66192a223e6e87c31200c2e0b52d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa234e0570d5db2da8883921bce77048a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gaa234e0570d5db2da8883921bce77048a">hw_emmc_get_sec_erase_timeout_ms</a> (void)</td></tr>
<tr class="memdesc:gaa234e0570d5db2da8883921bce77048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the secure erase timeout in msec of one logical erase group, based on ERASE_GROUP_DEF = EXT_CSD[175].  <a href="group___h_w___e_m_m_c.html#gaa234e0570d5db2da8883921bce77048a">More...</a><br /></td></tr>
<tr class="separator:gaa234e0570d5db2da8883921bce77048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e4cf6cbf6c4360ebe85433c18c47ab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#ga98e4cf6cbf6c4360ebe85433c18c47ab">hw_emmc_get_trim_timeout_ms</a> (void)</td></tr>
<tr class="memdesc:ga98e4cf6cbf6c4360ebe85433c18c47ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the trim timeout in msec of one logical erase group.  <a href="group___h_w___e_m_m_c.html#ga98e4cf6cbf6c4360ebe85433c18c47ab">More...</a><br /></td></tr>
<tr class="separator:ga98e4cf6cbf6c4360ebe85433c18c47ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ce6cdfd76430592aebc9823622e2c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___e_m_m_c.html#gad1ce6cdfd76430592aebc9823622e2c5">hw_emmc_get_sec_trim_timeout_ms</a> (void)</td></tr>
<tr class="memdesc:gad1ce6cdfd76430592aebc9823622e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the secure trim timeout in msec of one logical erase group.  <a href="group___h_w___e_m_m_c.html#gad1ce6cdfd76430592aebc9823622e2c5">More...</a><br /></td></tr>
<tr class="separator:gad1ce6cdfd76430592aebc9823622e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>embedded Multi-Media Card (eMMC) Low Level Driver </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga76a0c07ec13df90a42f7cc19cfe6bf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76a0c07ec13df90a42f7cc19cfe6bf8b">&#9670;&nbsp;</a></span>HW_EMMC_ACTIVE_ERROR_INTERRUPTS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_EMMC_ACTIVE_ERROR_INTERRUPTS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gad64513d546ff37ecf97e5c3ef2df9adc">REG_MSK</a>(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, RESP_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, ADMA_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, AUTO_CMD_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, CUR_LMT_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, DATA_END_BIT_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, DATA_CRC_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, DATA_TOUT_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, CMD_IDX_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, CMD_END_BIT_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, CMD_CRC_ERR_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, CMD_TOUT_ERR_STAT_EN)</div>
</div><!-- fragment --><p>This macro defines the mask with active and implemented error interrupts </p>

</div>
</div>
<a id="ga80bf3132358b4e102ebbdfc466d5c1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80bf3132358b4e102ebbdfc466d5c1f7">&#9670;&nbsp;</a></span>HW_EMMC_ACTIVE_NORMAL_INTERRUPTS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_EMMC_ACTIVE_NORMAL_INTERRUPTS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gad64513d546ff37ecf97e5c3ef2df9adc">REG_MSK</a>(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, BUF_RD_READY_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, BUF_WR_READY_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, DMA_INTERRUPT_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, BGAP_EVENT_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, XFER_COMPLETE_STAT_EN) | \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, CMD_COMPLETE_STAT_EN)</div>
</div><!-- fragment --><p>This macro defines the mask with active and implemented normal interrupts</p>
<p>Note: these are mandatory interrupts </p>

</div>
</div>
<a id="ga8b7656a53420393598b03c8865fa3177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b7656a53420393598b03c8865fa3177">&#9670;&nbsp;</a></span>HW_EMMC_HC_TIMEOUT_ERASE_FACTOR_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_EMMC_HC_TIMEOUT_ERASE_FACTOR_MS&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Factor used to calculate the High Capacity (HC) erase/trim timeout, in ms </p>

</div>
</div>
<a id="ga2084d20dac8e0bcb1d66e8d78147ed75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2084d20dac8e0bcb1d66e8d78147ed75">&#9670;&nbsp;</a></span>HW_EMMC_NON_IMPL_ERROR_INTERRUPTS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_EMMC_NON_IMPL_ERROR_INTERRUPTS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gad64513d546ff37ecf97e5c3ef2df9adc">REG_MSK</a>(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, VENDOR_ERR_STAT_EN3) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, VENDOR_ERR_STAT_EN2) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, VENDOR_ERR_STAT_EN1) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, BOOT_ACK_ERR_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_ERROR_INT_STAT_EN_R_REG, TUNING_ERR_STAT_EN)</div>
</div><!-- fragment --><p>This macro defines the mask with non-implemented/supported/applicable error interrupts </p>

</div>
</div>
<a id="gac7d3786c309cf7a35996822a60190929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7d3786c309cf7a35996822a60190929">&#9670;&nbsp;</a></span>HW_EMMC_NON_IMPL_NORMAL_INTERRUPTS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_EMMC_NON_IMPL_NORMAL_INTERRUPTS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gad64513d546ff37ecf97e5c3ef2df9adc">REG_MSK</a>(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, CQE_EVENT_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, FX_EVENT_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, RE_TUNE_EVENT_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, INT_C_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, INT_B_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, INT_A_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, CARD_INTERRUPT_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, CARD_REMOVAL_STAT_EN) \</div>
<div class="line">                                                        REG_MSK(EMMC, EMMC_NORMAL_INT_STAT_EN_R_REG, CARD_INSERTION_STAT_EN)</div>
</div><!-- fragment --><p>This macro defines the mask with non-implemented/supported/applicable normal interrupts </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac00380a314ec1503b5e9ba74fca8bb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00380a314ec1503b5e9ba74fca8bb2d">&#9670;&nbsp;</a></span>HW_EMMC_CARD_CMD_CLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___e_m_m_c.html#gac00380a314ec1503b5e9ba74fca8bb2d">HW_EMMC_CARD_CMD_CLASS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported card command classes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da81e14ddaad8ddb40611f018e70a782cc"></a>HW_EMMC_CARD_CMD_CLASS_0_BASIC&#160;</td><td class="fielddoc"><p>Class 0: Basic </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da3b9d06a267f2d428b04531cb580a1848"></a>HW_EMMC_CARD_CMD_CLASS_1_STREAM_RD&#160;</td><td class="fielddoc"><p>Class 1: Stream read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da8e3e9334eb0feaafde4a50e78ccc404e"></a>HW_EMMC_CARD_CMD_CLASS_2_BLK_RD&#160;</td><td class="fielddoc"><p>Class 2: Block read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da9a2cbdf054ff02d52384e3a263c6f9b1"></a>HW_EMMC_CARD_CMD_CLASS_3_STREAM_WR&#160;</td><td class="fielddoc"><p>Class 3: Stream write </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da6bb63efaa85cc9a8da28ae08043249a9"></a>HW_EMMC_CARD_CMD_CLASS_4_BLK_WR&#160;</td><td class="fielddoc"><p>Class 4: Block write </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da29197a769a9ebd29f6a666a3ca81aeeb"></a>HW_EMMC_CARD_CMD_CLASS_5_ERASE&#160;</td><td class="fielddoc"><p>Class 5: Erase </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da226ed3beb5ae3ee764de735f428fcc9c"></a>HW_EMMC_CARD_CMD_CLASS_6_WP&#160;</td><td class="fielddoc"><p>Class 6: Write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da5035cfbc0de3c527659c286945b143ba"></a>HW_EMMC_CARD_CMD_CLASS_7_LOCK&#160;</td><td class="fielddoc"><p>Class 7: Lock card </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da6867948f076af19cd638dbfc9526070c"></a>HW_EMMC_CARD_CMD_CLASS_8_APP&#160;</td><td class="fielddoc"><p>Class 8: Application specific </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac00380a314ec1503b5e9ba74fca8bb2da3bc3a8ff21a2216a41271bee68fb85e9"></a>HW_EMMC_CARD_CMD_CLASS_9_IO&#160;</td><td class="fielddoc"><p>Class 9: I/O mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabc52e076d7497120c9f0e6653b9fecd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc52e076d7497120c9f0e6653b9fecd1">&#9670;&nbsp;</a></span>hw_emmc_abort_xfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_abort_xfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga4f8ec08c73664aa4547459662dba029a">HW_SDHC_ABORT_METHOD</a>&#160;</td>
          <td class="paramname"><em>abort_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data transfer abort. </p>
<dl class="section note"><dt>Note</dt><dd>If called when no data transfer is active then return HW_SDHC_STATUS_SUCCESS</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abort_method</td><td>Abort method: synchronous or asynchronous </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout for the active data transfer, in ms</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gaa9ec3ecfa5298e6e8ad92acf4a1b8be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ec3ecfa5298e6e8ad92acf4a1b8be1">&#9670;&nbsp;</a></span>hw_emmc_awake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_awake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch an eMMC card from Sleep to Transfer state. </p>
<dl class="section note"><dt>Note</dt><dd>If the card is in Sleep state, it reacts only to the commands RESET (CMD0) and AWAKE (CMD5)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout for state transition, in ms If the value is 0, the maximum timeout value is used as defined in EXT_CSD[217] = S_A_TIMEOUT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gadd146f4c64bbf0c4fc63c349438836a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd146f4c64bbf0c4fc63c349438836a1">&#9670;&nbsp;</a></span>hw_emmc_card_clr_password()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_card_clr_password </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the password that has been set to lock the card. </p>
<p>The password length of an eMMC card is 1 to 16 bytes. The user should use the correct password for this operation. The card status bit HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED is checked before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pwd</td><td>pointer to the password bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>password length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An attempt to use password protection features (CMD42) on a card having password permanently disabled will fail and the LOCK_UNLOCK_FAILED (bit 24) error bit will be set in the status register. The password protection feature can be disabled permanently by setting the permanent password disable bit (PERM_PSWD_DIS bit in the EXT_CSD byte [171]). </dd></dl>

</div>
</div>
<a id="gaececba012bad5aee756a1794d9263916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaececba012bad5aee756a1794d9263916">&#9670;&nbsp;</a></span>hw_emmc_card_force_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_card_force_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all the card data content along with the password content (Forced Erase) </p>
<p>An attempt to force erase an unlocked card will fail and HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED bit will be set in the status register. This operation can be used in case that the user forgot the password and the card is locked. The card status bit HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED is checked before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An attempt to use password protection features (CMD42) on a card having password permanently disabled will fail and the LOCK_UNLOCK_FAILED (bit 24) error bit will be set in the status register. The password protection feature can be disabled permanently by setting the permanent password disable bit (PERM_PSWD_DIS bit in the EXT_CSD byte [171]). </dd></dl>

</div>
</div>
<a id="ga7d033d576092d513cba40098f56f3b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d033d576092d513cba40098f56f3b8c">&#9670;&nbsp;</a></span>hw_emmc_card_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_card_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the card using the password that has been already set. </p>
<p>The password length of an eMMC card is 1 to 16 bytes. The user should use the correct password to lock the card. The card status bits HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED and HW_SDHC_CARD_STATUS_CARD_IS_LOCKED are checked before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pwd</td><td>pointer to the password bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>password length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An attempt to use password protection features (CMD42) on a card having password permanently disabled will fail and the LOCK_UNLOCK_FAILED (bit 24) error bit will be set in the status register. The password protection feature can be disabled permanently by setting the permanent password disable bit (PERM_PSWD_DIS bit in the EXT_CSD byte [171]). </dd></dl>

</div>
</div>
<a id="gae68ce4dda534589f454f0b12f6599800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae68ce4dda534589f454f0b12f6599800">&#9670;&nbsp;</a></span>hw_emmc_card_replace_password()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_card_replace_password </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>old_pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>old_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>new_pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>new_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the password that has been set to lock the card with a new one. </p>
<p>The password length of an eMMC card is 1 to 16 bytes. The user can replace the password and lock the card using a single command. The card status bits HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED and HW_SDHC_CARD_STATUS_CARD_IS_LOCKED are checked before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_pwd</td><td>pointer to the old/current password bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_len</td><td>old/current password length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_pwd</td><td>pointer to the new password bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_len</td><td>new password length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>select to lock the card or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An attempt to use password protection features (CMD42) on a card having password permanently disabled will fail and the LOCK_UNLOCK_FAILED (bit 24) error bit will be set in the status register. The password protection feature can be disabled permanently by setting the permanent password disable bit (PERM_PSWD_DIS bit in the EXT_CSD byte [171]). </dd></dl>

</div>
</div>
<a id="ga2ba8c097adc17f81b6c0bf9d0f422f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba8c097adc17f81b6c0bf9d0f422f91">&#9670;&nbsp;</a></span>hw_emmc_card_set_password()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_card_set_password </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a password that can be used to lock the card. </p>
<p>The password length of an eMMC card is 1 to 16 bytes. The user can set the password and lock the card using a single command. The card status bits HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED and HW_SDHC_CARD_STATUS_CARD_IS_LOCKED are checked before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pwd</td><td>pointer to the password bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>password length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>select to lock the card or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An attempt to use password protection features (CMD42) on a card having password permanently disabled will fail and the LOCK_UNLOCK_FAILED (bit 24) error bit will be set in the status register. The password protection feature can be disabled permanently by setting the permanent password disable bit (PERM_PSWD_DIS bit in the EXT_CSD byte [171]). </dd></dl>

</div>
</div>
<a id="gaf0af7f0cd8b11941be9aaf068782c695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0af7f0cd8b11941be9aaf068782c695">&#9670;&nbsp;</a></span>hw_emmc_card_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_card_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the card using the password that has been already set. </p>
<p>The password length of an eMMC card is 1 to 16 bytes. The user should use the correct password to unlock the card. The card status bits HW_SDHC_CARD_STATUS_LOCK_UNLOCK_FAILED and HW_SDHC_CARD_STATUS_CARD_IS_LOCKED are checked before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pwd</td><td>pointer to the password bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>password length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An attempt to use password protection features (CMD42) on a card having password permanently disabled will fail and the LOCK_UNLOCK_FAILED (bit 24) error bit will be set in the status register. The password protection feature can be disabled permanently by setting the permanent password disable bit (PERM_PSWD_DIS bit in the EXT_CSD byte [171]). </dd></dl>

</div>
</div>
<a id="ga9e2e6140574b006c9265616c69ea804b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2e6140574b006c9265616c69ea804b">&#9670;&nbsp;</a></span>hw_emmc_data_xfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_data_xfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhw__sdhc__data__transfer__config__t.html">hw_sdhc_data_transfer_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue CMD with Data Transfer (Non-DMA/PIO, SDMA, ADMA2) </p>
<dl class="section note"><dt>Note</dt><dd>PIO: Programmed I/O </dd>
<dd>
SDMA: Single operation DMA </dd>
<dd>
ADMA2: Advanced DMA</dd></dl>
<p>To check whether a data xfer command is sent (CMD8, 17, 18, 24, 25), the following register fields should be read: EMMC_NORMAL_INT_STAT_R_REG.BUF_RD_READY/BUF_WR_READY = 1 EMMC_NORMAL_INT_STAT_R_REG.CMD_COMPLETE = 1 EMMC_PSTATE_REG.BUF_RD_ENABLE/BUF_WR_ENABLE = 1 EMMC_PSTATE_REG.RD_XFER_ACTIVE/WR_XFER_ACTIVE = 1</p>
<p>If CMD_COMPLETE is reset then BUF_RD_READY/BUF_WR_READY are also reset. This should be avoided in order to start the following data xfer successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">config</td><td>Data transfer configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Parameter config should be valid until the transaction is complete, since it contains the data read or written. </dd></dl>

</div>
</div>
<a id="gae216f26d6d559d11e790e12c674f3074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae216f26d6d559d11e790e12c674f3074">&#9670;&nbsp;</a></span>hw_emmc_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eMMC de-initialization </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gacb0ae985a98b362c57b4d989ff22021c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb0ae985a98b362c57b4d989ff22021c">&#9670;&nbsp;</a></span>hw_emmc_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_disable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Host Controller (HC) </p>
<p>Set CLK_PDCTRL_REG: disable the HC clock</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called after HC de-initialization</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga0167059c1ec8872e4c9ca3bd805d7d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0167059c1ec8872e4c9ca3bd805d7d93">&#9670;&nbsp;</a></span>hw_emmc_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhw__sdhc__pdctrl__reg__config__t.html">hw_sdhc_pdctrl_reg_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Host Controller (HC) </p>
<p>Check the status of External Memory Controller Power Domain Set CLK_PDCTRL_REG: clock divider, invert RX/TX clock, enable the HC clock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gad928a0b1eb0dfe630477a1bcec34b93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad928a0b1eb0dfe630477a1bcec34b93d">&#9670;&nbsp;</a></span>hw_emmc_erase_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_erase_groups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_erase_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_erase_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the specified erase groups using CMD35, 36 and 38. </p>
<p>The supported Card Command Classes (CCC) are coded in the CSD register of each card, providing the host with information on how to access the card. A card supports erase commands if it is Class 5, i.e. bit 5 of CSD:CCC is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_erase_group</td><td>start erase group, valid values = 0..(SEC_COUNT/erase_group_size)-1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_erase_group</td><td>end erase group, valid values = 0..(SEC_COUNT/erase_group_size)-1 The start group cannot be greater than the end group SEC_COUNT = EXT_CSD[215:212] = max sector count of the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout in msec, should be the multiple of the number of the erase groups involved If the value is 0, the maximum timeout value is used as defined in EXT_CSD</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga256ccc6f2d37e4f8db0da552783e79fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga256ccc6f2d37e4f8db0da552783e79fa">&#9670;&nbsp;</a></span>hw_emmc_erase_groups_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_erase_groups_secure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_erase_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_erase_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Secure Erase the specified erase groups using CMD35, 36 and 38. </p>
<p>The supported Card Command Classes (CCC) are coded in the CSD register of each card, providing the host with information on how to access the card. A card supports erase commands if it is Class 5, i.e. bit 5 of CSD:CCC is set.</p>
<p>Moreover, the BIT0 of EXT_CSD[231] = SEC_FEATURE_SUPPORT should be already set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_erase_group</td><td>start erase group, valid values = 0..(SEC_COUNT/erase_group_size)-1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_erase_group</td><td>end erase group, valid values = 0..(SEC_COUNT/erase_group_size)-1 The start group cannot be greater than the end group SEC_COUNT = EXT_CSD[215:212] = max sector count of the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout in msec, should be the multiple of the number of the erase groups involved If the value is 0, the maximum timeout value is used as defined in EXT_CSD</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gaeb0396258eade32055aa87a34e2b35d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0396258eade32055aa87a34e2b35d7">&#9670;&nbsp;</a></span>hw_emmc_error_recovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_error_recovery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data transfer error recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout, in ms</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Instead of HW_SDHC_STATUS_RECOVERABLE_ERROR, return HW_SDHC_STATUS_SUCCESS to be consistent with other API functions return values </dd></dl>

</div>
</div>
<a id="gae45bccd4efce7f468a3711a89dcd079b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae45bccd4efce7f468a3711a89dcd079b">&#9670;&nbsp;</a></span>hw_emmc_get_card_cid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_get_card_cid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Card Identification Register (CID) using the command SEND_CID (CMD10) and update the driver emmc_context, accordingly. The pointer to emmc_context is returned at <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>. </p>
<p>CID register is 16 bytes long, including the CRC7 field Although the card sends CRC7, the host controller does not include it in the command response Thus, the command response is 15 bytes long</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="group___h_w___e_m_m_c.html#ga0806a561e7e672c08bfa0613788b7f28" title="Program the Card Identification Register (CID), using the command PROGRAM_CID (CMD26)">hw_emmc_program_cid()</a> programs a new value of the CID register, and updates the driver emmc_context, accordingly. </dd></dl>

</div>
</div>
<a id="gac46c8958495a598846d50eed7cf9b8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac46c8958495a598846d50eed7cf9b8f6">&#9670;&nbsp;</a></span>hw_emmc_get_card_csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_get_card_csd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Card Specific Data Register (CSD) using the command SEND_CSD (CMD9) and update the driver emmc_context, accordingly. The pointer to emmc_context is returned at <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>. </p>
<p>CSD register is 16 bytes long, including the CRC7 field Although the card sends CRC7, the host controller does not include it in the command response Thus, the command response is 15 bytes long</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="group___h_w___e_m_m_c.html#gab81acddafe08f1ae5a56b6123b53d65e" title="Program the programmable part of Card Specific Data Register (CSD), using the command PROGRAM_CSD (CM...">hw_emmc_program_csd()</a> programs a new value of the CSD register, and updates the driver emmc_context, accordingly. </dd></dl>

</div>
</div>
<a id="gaf55c1e668ca760654dddd551cfd3b479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf55c1e668ca760654dddd551cfd3b479">&#9670;&nbsp;</a></span>hw_emmc_get_card_ext_csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_get_card_ext_csd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Extended Card Specific Data Register (EXT_CSD) using the command SEND_EXT_CSD (CMD8) and update the driver emmc_context, accordingly. The pointer to emmc_context is returned at <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>. </p>
<p>EXT_CSD register is 512 bytes long</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gafe7a4dbf666caaf8d428829cf715920a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe7a4dbf666caaf8d428829cf715920a">&#9670;&nbsp;</a></span>hw_emmc_get_card_status_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_get_card_status_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>status_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get card status register using the command SEND_STATUS (CMD13) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status_reg</td><td>Pointer to card status register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga9b3665ef2dcc19a8dbecc5edfebd4925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b3665ef2dcc19a8dbecc5edfebd4925">&#9670;&nbsp;</a></span>hw_emmc_get_erase_group_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hw_emmc_get_erase_group_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the erase group size, based on ERASE_GROUP_DEF = EXT_CSD[175]. </p>
<p>If ERASE_GROUP_DEF == 1 then HC_ERASE_GRP_SIZE = EXT_CSD[224] is used (if non-zero), which defines the erase-unit size for high-capacity memory, else the default unit is used.</p>
<p>This function should be called after CSD and EXT_CSD are read/updated. More specifically, after <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a> or any EXT_CSD modification using CMD6 (SWITCH).</p>
<dl class="section return"><dt>Returns</dt><dd>size in sectors, non-zero value </dd></dl>

</div>
</div>
<a id="ga0ba66192a223e6e87c31200c2e0b52d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ba66192a223e6e87c31200c2e0b52d4">&#9670;&nbsp;</a></span>hw_emmc_get_erase_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hw_emmc_get_erase_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the erase timeout in msec of one logical erase group, based on ERASE_GROUP_DEF = EXT_CSD[175]. </p>
<p>If ERASE_GROUP_DEF == 1 then ERASE_TIMEOUT_MULT = EXT_CSD[223] is used (if non-zero) to calculate the erase timeout for high-capacity memory, else the default value is used.</p>
<p>This function should be called after CSD and EXT_CSD are read/updated. More specifically, after <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a> or any EXT_CSD modification using CMD6 (SWITCH).</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero value </dd></dl>

</div>
</div>
<a id="gaa234e0570d5db2da8883921bce77048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa234e0570d5db2da8883921bce77048a">&#9670;&nbsp;</a></span>hw_emmc_get_sec_erase_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hw_emmc_get_sec_erase_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the secure erase timeout in msec of one logical erase group, based on ERASE_GROUP_DEF = EXT_CSD[175]. </p>
<p>If ERASE_GROUP_DEF == 1 then SEC_ERASE_MULT = EXT_CSD[230] is used (if defined) to calculate the secure erase timeout for high-capacity memory, else the default value is used.</p>
<p>This function should be called after CSD and EXT_CSD are read/updated. More specifically, after <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a> or any EXT_CSD modification using CMD6 (SWITCH).</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero value </dd></dl>

</div>
</div>
<a id="gad1ce6cdfd76430592aebc9823622e2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ce6cdfd76430592aebc9823622e2c5">&#9670;&nbsp;</a></span>hw_emmc_get_sec_trim_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hw_emmc_get_sec_trim_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the secure trim timeout in msec of one logical erase group. </p>
<p>Use SEC_TRIM_MULT = EXT_CSD[229] and ERASE_TIMEOUT_MULT = EXT_CSD[223] (if defined) to calculate the secure trim timeout. It is the same value for both default and high-capacity memories.</p>
<p>This function should be called after CSD and EXT_CSD are read. More specifically, after <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero value </dd></dl>

</div>
</div>
<a id="ga98e4cf6cbf6c4360ebe85433c18c47ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e4cf6cbf6c4360ebe85433c18c47ab">&#9670;&nbsp;</a></span>hw_emmc_get_trim_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hw_emmc_get_trim_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the trim timeout in msec of one logical erase group. </p>
<p>Use TRIM_MULT = EXT_CSD[232] (if defined) to calculate the trim timeout. It is the same value for both default and high-capacity memories.</p>
<p>This function should be called after CSD and EXT_CSD are read. More specifically, after <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero value </dd></dl>

</div>
</div>
<a id="ga77a141199f74dff3faa146b2bf5349a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a141199f74dff3faa146b2bf5349a8">&#9670;&nbsp;</a></span>hw_emmc_get_wp_group_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hw_emmc_get_wp_group_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the write protect group size, based on ERASE_GROUP_DEF = EXT_CSD[175]. </p>
<p>If ERASE_GROUP_DEF == 1 then HC_WP_GRP_SIZE = EXT_CSD[221] is used (if non-zero), which defines the write protect group size for high-capacity memory, else the default size is used.</p>
<p>This function should be called after CSD and EXT_CSD are read/updated. More specifically, after <a class="el" href="group___h_w___e_m_m_c.html#ga1d9c8066f2d33c043dd9af9652167fb4" title="eMMC initialization">hw_emmc_init()</a> or any EXT_CSD modification using CMD6 (SWITCH).</p>
<dl class="section return"><dt>Returns</dt><dd>size in sectors, non-zero value </dd></dl>

</div>
</div>
<a id="gab71ea286fd9fd9eef8e0ab25ae358032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab71ea286fd9fd9eef8e0ab25ae358032">&#9670;&nbsp;</a></span>hw_emmc_hw_reset_card()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_hw_reset_card </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rst_pulse_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware reset the eMMC card. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called after enabling the HC, since it uses HC registers </dd>
<dd>
By default HW reset is not enabled in an eMMC card and thus it is ignored by it EXT_CSD:RST_n_FUNCTION = 0x00</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rst_pulse_us</td><td>reset pulse width in us, min value = 1us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga1d9c8066f2d33c043dd9af9652167fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d9c8066f2d33c043dd9af9652167fb4">&#9670;&nbsp;</a></span>hw_emmc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhw__sdhc__config__t.html">hw_sdhc_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#gaa5bdf0ce65ec1315d33582ef70ce5808">hw_sdhc_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhw__emmc__context__data__t.html">hw_emmc_context_data_t</a> **&#160;</td>
          <td class="paramname"><em>ptr_emmc_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eMMC initialization </p>
<p>After initialization, Host Controller and Card should be ready to transfer data.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called after HC enable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function. If NULL then data transfers are blocking </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr_emmc_context</td><td>Pointer to the address of the emmc context data stored locally in the driver The returned pointer should be considered valid, only when HW_SDHC_STATUS_SUCCESS is returned and can be used for the lifetime of the driver</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga64ca471744d2e01d8788f171a644e661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ca471744d2e01d8788f171a644e661">&#9670;&nbsp;</a></span>hw_emmc_is_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_is_busy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if controller is busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if controller is not busy HW_SDHC_STATUS_ERROR_OPERATION_IN_PROGRESS if controller is busy Otherwise, an error id </dd></dl>

</div>
</div>
<a id="ga0806a561e7e672c08bfa0613788b7f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0806a561e7e672c08bfa0613788b7f28">&#9670;&nbsp;</a></span>hw_emmc_program_cid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_program_cid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhw__sdhc__emmc__cid__t.html">hw_sdhc_emmc_cid_t</a> *&#160;</td>
          <td class="paramname"><em>prg_cid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program the Card Identification Register (CID), using the command PROGRAM_CID (CMD26) </p>
<p>Prepare the buffer to program the CID (16 bytes):</p><ul>
<li>Reverse the order of the CID bytes so that the MSB is first</li>
<li>Calculate the new CRC7</li>
</ul>
<p>After programming the CID, the command SEND_STATUS (CMD13) is sent to check whether the card status bit CID/CSD_OVERWRITE is set</p>
<p>Local CID data is updated if the returned value is HW_SDHC_STATUS_SUCCESS. If <a class="el" href="group___h_w___e_m_m_c.html#gae45bccd4efce7f468a3711a89dcd079b" title="Read Card Identification Register (CID) using the command SEND_CID (CMD10) and update the driver emmc...">hw_emmc_get_card_cid()</a> was previously called, then the returned address (cid) points to the updated data as well.</p>
<dl class="section note"><dt>Note</dt><dd>Normally, the CID register has already been written by the manufacturer and can not be overwritten</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prg_cid</td><td>CID value to be programmed, byte order is reversed and CRC7 is added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gab81acddafe08f1ae5a56b6123b53d65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab81acddafe08f1ae5a56b6123b53d65e">&#9670;&nbsp;</a></span>hw_emmc_program_csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_program_csd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hw_emmc_prg_csd_t&#160;</td>
          <td class="paramname"><em>prg_csd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program the programmable part of Card Specific Data Register (CSD), using the command PROGRAM_CSD (CMD27) The programmable bits of CSD are 8 to 15. </p>
<p>Prepare the buffer to program the CSD (16 bytes):</p><ul>
<li>The read-only part of the CSD should match the card content</li>
<li>Reverse the order of the CSD bytes stored in the eMMC context so that the MSB is first</li>
<li>Set the programmable part</li>
<li>Calculate the new CRC7</li>
</ul>
<p>After programming the CSD, check if card status CID/CSD_OVERWRITE bit is set</p>
<p>Local CSD data is updated if the returned value is HW_SDHC_STATUS_SUCCESS. If <a class="el" href="group___h_w___e_m_m_c.html#gac46c8958495a598846d50eed7cf9b8f6" title="Read Card Specific Data Register (CSD) using the command SEND_CSD (CMD9) and update the driver emmc_c...">hw_emmc_get_card_csd()</a> was previously called, then the returned address (csd) points to the updated data as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prg_csd</td><td>programmable part of CSD to be programmed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga08f473adb742fb6a7a1fe26e817b2a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08f473adb742fb6a7a1fe26e817b2a17">&#9670;&nbsp;</a></span>hw_emmc_set_data_bus_width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_set_data_bus_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga7c4eb21ec1769b6938b16eab15e2372d">HW_SDHC_BUS_WIDTH</a>&#160;</td>
          <td class="paramname"><em>bus_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data bus width using SWITCH command (CMD6) </p>
<p>Command SEND_STATUS (CMD13) is also called to check the value of card status bit 7 (SWITCH_ERROR) If the operation does not fail, the emmc_context is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_width</td><td>bus width value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga16cba6431a9b8f3904b8744cda7ec21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16cba6431a9b8f3904b8744cda7ec21d">&#9670;&nbsp;</a></span>hw_emmc_set_speed_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_set_speed_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>speed_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data bus speed using SWITCH command (CMD6) </p>
<p>Command SEND_STATUS (CMD13) is also called to check the value of card status bit 7 (SWITCH_ERROR) If the operation does not fail, the emmc_context is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed_mode</td><td>speed mode value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga0e6e17c12d45de3f1268c53deb4ef27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e6e17c12d45de3f1268c53deb4ef27a">&#9670;&nbsp;</a></span>hw_emmc_setup_data_bus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_setup_data_bus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhw__sdhc__bus__config__t.html">hw_sdhc_bus_config_t</a> *&#160;</td>
          <td class="paramname"><em>bus_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data bus width, speed mode, speed/frequency, drive strength. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_config</td><td>Data bus configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga6013e5c767f97a60fbf5bfccc5153537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6013e5c767f97a60fbf5bfccc5153537">&#9670;&nbsp;</a></span>hw_emmc_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch an eMMC card to Sleep state. </p>
<dl class="section note"><dt>Note</dt><dd>If the card is not in Standby state, try to switch to Standby state and then execute the sleep command If the card cannot switch to Standby state (at previous step) then return an error</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout for state transition, in ms If the value is 0, the maximum timeout value is used as defined in EXT_CSD[217] = S_A_TIMEOUT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gafe4e26c34473a7dd11f236aa5fcbe5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe4e26c34473a7dd11f236aa5fcbe5a8">&#9670;&nbsp;</a></span>hw_emmc_start_hc_clocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_start_hc_clocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start Host Controller internal and SD Bus clocks. </p>
<dl class="section note"><dt>Note</dt><dd>Can be used with awake command after a sleep</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga450b2cb82aeac1f4b0eae1857b990145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga450b2cb82aeac1f4b0eae1857b990145">&#9670;&nbsp;</a></span>hw_emmc_stop_hc_clocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_stop_hc_clocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop Host Controller internal and SD Bus clocks. </p>
<dl class="section note"><dt>Note</dt><dd>Can be used with sleep command for low power consumption</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gaeace3e329a641e929623ab3ae921ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeace3e329a641e929623ab3ae921ea35">&#9670;&nbsp;</a></span>hw_emmc_trim_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_trim_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim (erase) the specified card sectors/blocks using CMD35, 36 and 38. </p>
<p>The supported Card Command Classes (CCC) are coded in the CSD register of each card, providing the host with information on how to access the card. A card supports erase commands if it is Class 5, i.e. bit 5 of CSD:CCC is set.</p>
<p>Moreover, the BIT4 of EXT_CSD[231] = SEC_FEATURE_SUPPORT should be already set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_addr</td><td>start address in sectors/blocks, valid values = 0..SEC_COUNT-1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_addr</td><td>end address in sectors/blocks, valid values = 0..SEC_COUNT-1 start_addr cannot be greater than the end_addr SEC_COUNT = EXT_CSD[215:212] = max sector count of the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout in msec, should be the multiple of the number of the erase groups involved If the value is 0, the maximum timeout value is used as defined in EXT_CSD</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="ga18598e4e77e198fb6487a1986c45080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18598e4e77e198fb6487a1986c45080d">&#9670;&nbsp;</a></span>hw_emmc_trim_blocks_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_trim_blocks_secure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Secure Trim (erase) the specified card sectors/blocks using CMD35, 36 and 38 This is the Secure Trim Step 2. </p>
<p>The supported Card Command Classes (CCC) are coded in the CSD register of each card, providing the host with information on how to access the card. A card supports erase commands if it is Class 5, i.e. bit 5 of CSD:CCC is set.</p>
<p>Moreover, the BIT0 and BIT4 of EXT_CSD[231] = SEC_FEATURE_SUPPORT should be already set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout in msec, should be the multiple of the number of the erase groups involved The value cannot be 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
<a id="gaa62422cba847d2fe49a9a6ba8e2e8d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62422cba847d2fe49a9a6ba8e2e8d1e">&#9670;&nbsp;</a></span>hw_emmc_trim_mark_blocks_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___s_d_h_c.html#ga43065846673170f731a9b1babb869aff">HW_SDHC_STATUS</a> hw_emmc_trim_mark_blocks_secure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___s_d_h_c.html#ga0e5b3498231519f279bc2ec676337a97">HW_SDHC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the specified card sectors/blocks for Secure Trim (erase) using CMD35, 36 and 38 This is the Secure Trim Step 1. </p>
<p>The supported Card Command Classes (CCC) are coded in the CSD register of each card, providing the host with information on how to access the card. A card supports erase commands if it is Class 5, i.e. bit 5 of CSD:CCC is set.</p>
<p>Moreover, the BIT0 and BIT4 of EXT_CSD[231] = SEC_FEATURE_SUPPORT should be already set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>SDHC controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_addr</td><td>start address in sectors/blocks, valid values = 0..SEC_COUNT-1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_addr</td><td>end address in sectors/blocks, valid values = 0..SEC_COUNT-1 start_addr cannot be greater than the end_addr SEC_COUNT = EXT_CSD[215:212] = max sector count of the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout_ms</td><td>timeout in msec, should be the multiple of the number of the erase groups involved If the value is 0, the maximum timeout value is used as defined in EXT_CSD</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HW_SDHC_STATUS_SUCCESS if OK. Otherwise, an error id. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup___b_s_p___d_e_f_i_n_i_t_i_o_n_s_html_gad64513d546ff37ecf97e5c3ef2df9adc"><div class="ttname"><a href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gad64513d546ff37ecf97e5c3ef2df9adc">REG_MSK</a></div><div class="ttdeci">#define REG_MSK(base, reg, field)</div><div class="ttdoc">Access register field mask.</div><div class="ttdef"><b>Definition:</b> sdk_defs.h:645</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:41 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
