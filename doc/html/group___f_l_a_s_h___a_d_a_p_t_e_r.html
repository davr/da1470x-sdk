<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: QSPI Flash Adapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">QSPI Flash Adapter<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___a_d_a_p_t_e_r_s.html">System Adapters</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>QSPI flash adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb">AD_FLASH_ALWAYS_FLUSH_CACHE</a>&#160;&#160;&#160;((uint32_t)-1)</td></tr>
<tr class="separator:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga502c902619ade1fd5c7f02538ae3cdc8">ad_flash_init</a> (void)</td></tr>
<tr class="memdesc:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize flash access.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga502c902619ade1fd5c7f02538ae3cdc8">More...</a><br /></td></tr>
<tr class="separator:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4df7b1a1a2c426240ee5d60d6437d880">ad_flash_read</a> (uint32_t addr, uint8_t *buf, size_t len)</td></tr>
<tr class="memdesc:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read flash memory.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4df7b1a1a2c426240ee5d60d6437d880">More...</a><br /></td></tr>
<tr class="separator:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32898eb36d9af7b716badc7f9909ae9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf32898eb36d9af7b716badc7f9909ae9">ad_flash_write</a> (uint32_t addr, const uint8_t *buf, size_t size)</td></tr>
<tr class="memdesc:gaf32898eb36d9af7b716badc7f9909ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write flash memory.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf32898eb36d9af7b716badc7f9909ae9">More...</a><br /></td></tr>
<tr class="separator:gaf32898eb36d9af7b716badc7f9909ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga6bc8fadbe7293f7adf1478a480d2f25d">ad_flash_erase_region</a> (uint32_t addr, size_t size)</td></tr>
<tr class="memdesc:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase flash region.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga6bc8fadbe7293f7adf1478a480d2f25d">More...</a><br /></td></tr>
<tr class="separator:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55347a10455406fd8765691489f3b841"><td class="memItemLeft" align="right" valign="top">const __STATIC_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga55347a10455406fd8765691489f3b841">ad_flash_get_ptr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga55347a10455406fd8765691489f3b841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get physical pointer for a virtual address in a memory device's contents.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga55347a10455406fd8765691489f3b841">More...</a><br /></td></tr>
<tr class="separator:ga55347a10455406fd8765691489f3b841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf815e083ba566721b2073b399d4f34d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf815e083ba566721b2073b399d4f34d4">ad_flash_update_possible</a> (uint32_t addr, const uint8_t *data_to_write, size_t size)</td></tr>
<tr class="memdesc:gaf815e083ba566721b2073b399d4f34d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if update without erase is possible.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf815e083ba566721b2073b399d4f34d4">More...</a><br /></td></tr>
<tr class="separator:gaf815e083ba566721b2073b399d4f34d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e2372a758d46c511356ce05920d1c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gad3e2372a758d46c511356ce05920d1c3">ad_flash_erase_size</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gad3e2372a758d46c511356ce05920d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash erase size.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gad3e2372a758d46c511356ce05920d1c3">More...</a><br /></td></tr>
<tr class="separator:gad3e2372a758d46c511356ce05920d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f73fc8cad96267323754fae67314e19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4f73fc8cad96267323754fae67314e19">ad_flash_chip_erase_by_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga4f73fc8cad96267323754fae67314e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase specific flash starting at <code>addr</code>.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4f73fc8cad96267323754fae67314e19">More...</a><br /></td></tr>
<tr class="separator:ga4f73fc8cad96267323754fae67314e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599410ebcbd4ed9926998fc5bd786521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521">ad_flash_lock</a> (void)</td></tr>
<tr class="memdesc:ga599410ebcbd4ed9926998fc5bd786521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock access to entire flash.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521">More...</a><br /></td></tr>
<tr class="separator:ga599410ebcbd4ed9926998fc5bd786521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gafcf216c3b8d8a1cfefb1a08ab428a2d4">ad_flash_unlock</a> (void)</td></tr>
<tr class="memdesc:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock access to entire flash.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gafcf216c3b8d8a1cfefb1a08ab428a2d4">More...</a><br /></td></tr>
<tr class="separator:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa461b05c8ba275de7a21a628f562bc61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61">ad_flash_skip_cache_flushing</a> (uint32_t base, uint32_t size)</td></tr>
<tr class="memdesc:gaa461b05c8ba275de7a21a628f562bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control cache flushing on modifications (writes or erases) to flash.  <a href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61">More...</a><br /></td></tr>
<tr class="separator:gaa461b05c8ba275de7a21a628f562bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>QSPI flash adapter. </p>
<dl class="section note"><dt>Note</dt><dd>For DA1469x devices two address sub-regions are defined: Address region 1: 0..QSPI_MEM2_VIRTUAL_BASE_ADDR-1 Address region 2: starting at QSPI_MEM2_VIRTUAL_BASE_ADDR Any address in region 1 is mapped to QSPIC1. Any address in region 2 is mapped to QSPIC2. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gabb0ff70d27cb795c678201fa6eabb6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb0ff70d27cb795c678201fa6eabb6cb">&#9670;&nbsp;</a></span>AD_FLASH_ALWAYS_FLUSH_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AD_FLASH_ALWAYS_FLUSH_CACHE&#160;&#160;&#160;((uint32_t)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special base address that can be used with </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61" title="Control cache flushing on modifications (writes or erases) to flash.">ad_flash_skip_cache_flushing</a> to return to default cache flushing mode: all flash writes/erases trigger cache flushing. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4f73fc8cad96267323754fae67314e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f73fc8cad96267323754fae67314e19">&#9670;&nbsp;</a></span>ad_flash_chip_erase_by_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_flash_chip_erase_by_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase specific flash starting at <code>addr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Start address of the flash memory to be erased</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if <code>addr</code> is wrong; true otherwise </dd></dl>

</div>
</div>
<a id="ga6bc8fadbe7293f7adf1478a480d2f25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc8fadbe7293f7adf1478a480d2f25d">&#9670;&nbsp;</a></span>ad_flash_erase_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_flash_erase_region </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase flash region. </p>
<dl class="section note"><dt>Note</dt><dd>: All sectors that have offset in range of &lt;addr, addr + size) will be erased. If addr is not sector aligned preceding data on sector that addr belong to will also be erased. If addr + size is not sector aligned whole sector will also be erased.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="gad3e2372a758d46c511356ce05920d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3e2372a758d46c511356ce05920d1c3">&#9670;&nbsp;</a></span>ad_flash_erase_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_erase_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flash erase size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address of memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum size that can be erased </dd></dl>

</div>
</div>
<a id="ga55347a10455406fd8765691489f3b841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55347a10455406fd8765691489f3b841">&#9670;&nbsp;</a></span>ad_flash_get_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const __STATIC_INLINE void* ad_flash_get_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get physical pointer for a virtual address in a memory device's contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>virtual address in a memory device</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if addr cannot be mapped to a memory device </td></tr>
    <tr><td class="paramname">pointer</td><td>that can be used to directly access the data pointed to by virtual addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga502c902619ade1fd5c7f02538ae3cdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga502c902619ade1fd5c7f02538ae3cdc8">&#9670;&nbsp;</a></span>ad_flash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize flash access. </p>
<p>This function must be called before any other ad_flash_* function </p>

</div>
</div>
<a id="ga599410ebcbd4ed9926998fc5bd786521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599410ebcbd4ed9926998fc5bd786521">&#9670;&nbsp;</a></span>ad_flash_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock access to entire flash. </p>
<p>Function gets flash for exclusive usage </p>

</div>
</div>
<a id="ga4df7b1a1a2c426240ee5d60d6437d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df7b1a1a2c426240ee5d60d6437d880">&#9670;&nbsp;</a></span>ad_flash_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read flash memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read </dd></dl>

</div>
</div>
<a id="gaa461b05c8ba275de7a21a628f562bc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa461b05c8ba275de7a21a628f562bc61">&#9670;&nbsp;</a></span>ad_flash_skip_cache_flushing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_skip_cache_flushing </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control cache flushing on modifications (writes or erases) to flash. </p>
<p>This function can be used to enable or disable the triggering of cache flushing when writes or erases occur in a specific flash region. Only one such flash region can be defined.</p>
<p>This feature is useful when the programmer knows in advance that a big flash region is going to be updated (e.g. firmware update). However, flash reads from that region should be avoided, as they might lead to cache incoherency.</p>
<dl class="section note"><dt>Note</dt><dd>The effect of this function is at ad_flash_* layer and higher. For example, direct use of the hw_qspi_* API will not be affected by the use of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Starting offset of the flash region that should not trigger a cache flushing. If </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb">AD_FLASH_ALWAYS_FLUSH_CACHE</a> is passed, selective cache flushing is disabled, regardless of the value of size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the flash region that should not trigger cache flushing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafcf216c3b8d8a1cfefb1a08ab428a2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf216c3b8d8a1cfefb1a08ab428a2d4">&#9670;&nbsp;</a></span>ad_flash_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock access to entire flash. </p>
<p>Function release lock taken by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521" title="Lock access to entire flash.">ad_flash_lock()</a> </dd></dl>

</div>
</div>
<a id="gaf815e083ba566721b2073b399d4f34d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf815e083ba566721b2073b399d4f34d4">&#9670;&nbsp;</a></span>ad_flash_update_possible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_flash_update_possible </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if update without erase is possible. </p>
<p>Update is possible when only "0s" have to be written.</p>
<p>This function test if its possible to write to flash without erase. If function returns size, data did not change no erase needed. If non negative value means that write can be performed some bits will be cleared on write Negative value erase is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_to_write</td><td>data to write to flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 - erase is needed &gt;= number of bytes that do not need to be written (same) 0 means that write should start from offset 0 but no erase is needed. </dd></dl>

</div>
</div>
<a id="gaf32898eb36d9af7b716badc7f9909ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf32898eb36d9af7b716badc7f9909ae9">&#9670;&nbsp;</a></span>ad_flash_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write flash memory. </p>
<p>This function allows to write any number of bytes to flash. Memory should be erased before.</p>
<dl class="section note"><dt>Note</dt><dd>: User can pass buf pointing to QSPI mapped memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in flash to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:42 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
