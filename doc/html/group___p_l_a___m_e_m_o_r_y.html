<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: Memory Devices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Memory Devices<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___b_s_p.html">BSP (Board Support Package)</a> &raquo; <a class="el" href="group___p_l_a___b_s_p___s_y_s_t_e_m.html">System Configuration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Configuration values for the various supported QSPI, OQSPI and PSRAM devices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:oqspi__automode_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__automode_8h.html">oqspi_automode.h</a></td></tr>
<tr class="memdesc:oqspi__automode_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI flash memory automode API header file. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__common_8h.html">oqspi_common.h</a></td></tr>
<tr class="memdesc:oqspi__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI flash driver common definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__gigadevice__quad_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__gigadevice__quad_8h.html">oqspi_gigadevice_quad.h</a></td></tr>
<tr class="memdesc:oqspi__gigadevice__quad_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains macros and functions used by the OQSPIC flash drivers of the quad Gigadevice flash memories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__macronix__octa_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__macronix__octa_8h.html">oqspi_macronix_octa.h</a></td></tr>
<tr class="memdesc:oqspi__macronix__octa_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header contains macros and functions used by the OQSPIC flash drivers of the octa Macronix flash memories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__macronix__quad_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__macronix__quad_8h.html">oqspi_macronix_quad.h</a></td></tr>
<tr class="memdesc:oqspi__macronix__quad_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header contains macros and functions used by the OQSPIC flash drivers of the quad Macronix flash memories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__mx25u6432_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__mx25u6432_8h.html">oqspi_mx25u6432.h</a></td></tr>
<tr class="memdesc:oqspi__mx25u6432_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI flash driver for Macronix MX25U6432. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__w25q64jwim_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__w25q64jwim_8h.html">oqspi_w25q64jwim.h</a></td></tr>
<tr class="memdesc:oqspi__w25q64jwim_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI flash driver for Winbond W25Q64JWIM. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__winbond__quad_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__winbond__quad_8h.html">oqspi_winbond_quad.h</a></td></tr>
<tr class="memdesc:oqspi__winbond__quad_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header contains macros and functions used by the OQSPIC flash drivers of the quad Winbond flash memories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oqspi__xxx_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oqspi__xxx_8h.html">oqspi_xxx.h</a></td></tr>
<tr class="memdesc:oqspi__xxx_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI flash driver template. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:psram__aps6404jsq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psram__aps6404jsq_8h.html">psram_aps6404jsq.h</a></td></tr>
<tr class="memdesc:psram__aps6404jsq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI ram driver for aps6404jsq. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__apmemory_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__apmemory_8h.html">qspi_apmemory.h</a></td></tr>
<tr class="memdesc:qspi__apmemory_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI driver for AP Memory PSRAMs - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__at25sl128_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__at25sl128_8h.html">qspi_at25sl128.h</a></td></tr>
<tr class="memdesc:qspi__at25sl128_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver for flash ADESTO AT25SL128. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__automode_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__automode_8h.html">qspi_automode.h</a></td></tr>
<tr class="memdesc:qspi__automode_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access QSPI device when running in auto mode. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__common_8h.html">qspi_common.h</a></td></tr>
<tr class="memdesc:qspi__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver common definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__gigadevice_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__gigadevice_8h.html">qspi_gigadevice.h</a></td></tr>
<tr class="memdesc:qspi__gigadevice_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Gigadevice flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__macronix_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__macronix_8h.html">qspi_macronix.h</a></td></tr>
<tr class="memdesc:qspi__macronix_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Macronix flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__w25q256jw_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__w25q256jw_8h.html">qspi_w25q256jw.h</a></td></tr>
<tr class="memdesc:qspi__w25q256jw_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the Winbond W25Q256JW. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__winbond_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__winbond_8h.html">qspi_winbond.h</a></td></tr>
<tr class="memdesc:qspi__winbond_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Winbond flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi___x_x_x__template_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi___x_x_x__template_8h.html">qspi_XXX_template.h</a></td></tr>
<tr class="memdesc:qspi___x_x_x__template_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver for flash XXXX. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjedec__id__t.html">jedec_id_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JEDEC ID struct.  <a href="structjedec__id__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoqspi__callback__t.html">oqspi_callback_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI memory callbacks struct.  <a href="structoqspi__callback__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoqspi__delay__t.html">oqspi_delay_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI memory delays.  <a href="structoqspi__delay__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoqspi__flash__config__t.html">oqspi_flash_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OQSPI memory configuration structure.  <a href="structoqspi__flash__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__flash__config.html">qspi_flash_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Flash configuration structure.  <a href="structqspi__flash__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacb6745c33d23a6ee71eeaea8b9dda828">ADESTO_ID</a>&#160;&#160;&#160;0x1F</td></tr>
<tr class="memdesc:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="group___p_l_a___m_e_m_o_r_y.html#gacb6745c33d23a6ee71eeaea8b9dda828">More...</a><br /></td></tr>
<tr class="separator:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad120f9c1bc5fee08c9020c07a4ecabf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad120f9c1bc5fee08c9020c07a4ecabf9">AT25SL_TYPE</a>&#160;&#160;&#160;0x42</td></tr>
<tr class="memdesc:gad120f9c1bc5fee08c9020c07a4ecabf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="group___p_l_a___m_e_m_o_r_y.html#gad120f9c1bc5fee08c9020c07a4ecabf9">More...</a><br /></td></tr>
<tr class="separator:gad120f9c1bc5fee08c9020c07a4ecabf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68cd85bb475a4ed71d2ab5acb5f1308"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae68cd85bb475a4ed71d2ab5acb5f1308">AT25SL128_SIZE</a>&#160;&#160;&#160;0x18</td></tr>
<tr class="memdesc:gae68cd85bb475a4ed71d2ab5acb5f1308"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash density JEDEC ID.  <a href="group___p_l_a___m_e_m_o_r_y.html#gae68cd85bb475a4ed71d2ab5acb5f1308">More...</a><br /></td></tr>
<tr class="separator:gae68cd85bb475a4ed71d2ab5acb5f1308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230871cbef94a3328fdcda1f87dd2bde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga230871cbef94a3328fdcda1f87dd2bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash vendor JEDEC ID.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">More...</a><br /></td></tr>
<tr class="separator:ga230871cbef94a3328fdcda1f87dd2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4a1a837d547365760bd32ebc664e84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga8e4a1a837d547365760bd32ebc664e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">More...</a><br /></td></tr>
<tr class="separator:ga8e4a1a837d547365760bd32ebc664e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash density JEDEC ID.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">More...</a><br /></td></tr>
<tr class="separator:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaaca7b42888b10ca3e05786453609d0d3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structqspi__flash__config.html">qspi_flash_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a></td></tr>
<tr class="memdesc:gaaca7b42888b10ca3e05786453609d0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Flash configuration structure.  <a href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">More...</a><br /></td></tr>
<tr class="separator:gaaca7b42888b10ca3e05786453609d0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff8d6ffabcec232ccf0b5586d5bf9b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaff8d6ffabcec232ccf0b5586d5bf9b8c">oqspi_automode_write_flash_page</a> (uint32_t addr, const uint8_t *buf, uint32_t size)</td></tr>
<tr class="memdesc:gaff8d6ffabcec232ccf0b5586d5bf9b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write flash memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#gaff8d6ffabcec232ccf0b5586d5bf9b8c">More...</a><br /></td></tr>
<tr class="separator:gaff8d6ffabcec232ccf0b5586d5bf9b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ebeb4103a06e184e19831a59a29449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga18ebeb4103a06e184e19831a59a29449">oqspi_automode_erase_flash_sector</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga18ebeb4103a06e184e19831a59a29449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase Flash Sector.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga18ebeb4103a06e184e19831a59a29449">More...</a><br /></td></tr>
<tr class="separator:ga18ebeb4103a06e184e19831a59a29449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d958df868082054a0b921c2e6f17c2"><td class="memItemLeft" align="right" valign="top"><a id="gab9d958df868082054a0b921c2e6f17c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gab9d958df868082054a0b921c2e6f17c2">oqspi_automode_erase_chip</a> (void)</td></tr>
<tr class="memdesc:gab9d958df868082054a0b921c2e6f17c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase whole chip. <br /></td></tr>
<tr class="separator:gab9d958df868082054a0b921c2e6f17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995856a882a5546d6b8372ce0f6d4f75"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga995856a882a5546d6b8372ce0f6d4f75">oqspi_automode_read</a> (uint32_t addr, uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:ga995856a882a5546d6b8372ce0f6d4f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga995856a882a5546d6b8372ce0f6d4f75">More...</a><br /></td></tr>
<tr class="separator:ga995856a882a5546d6b8372ce0f6d4f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8c2e976a5ed2fa866dba217bc9861e"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gabd8c2e976a5ed2fa866dba217bc9861e">oqspi_automode_get_physical_addr</a> (uint32_t virtual_addr)</td></tr>
<tr class="memdesc:gabd8c2e976a5ed2fa866dba217bc9861e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the OQSPI flash memory physical address of the corresponding virtual address.  <a href="group___p_l_a___m_e_m_o_r_y.html#gabd8c2e976a5ed2fa866dba217bc9861e">More...</a><br /></td></tr>
<tr class="separator:gabd8c2e976a5ed2fa866dba217bc9861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1172f202a975e37bbd70bdb4e8ff3547"><td class="memItemLeft" align="right" valign="top"><a id="ga1172f202a975e37bbd70bdb4e8ff3547"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga1172f202a975e37bbd70bdb4e8ff3547">oqspi_automode_flash_power_up</a> (void)</td></tr>
<tr class="memdesc:ga1172f202a975e37bbd70bdb4e8ff3547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power up flash. <br /></td></tr>
<tr class="separator:ga1172f202a975e37bbd70bdb4e8ff3547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572a10b53e6ea6d20fbb0f1337c9abf5"><td class="memItemLeft" align="right" valign="top"><a id="ga572a10b53e6ea6d20fbb0f1337c9abf5"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga572a10b53e6ea6d20fbb0f1337c9abf5">oqspi_automode_flash_power_down</a> (void)</td></tr>
<tr class="memdesc:ga572a10b53e6ea6d20fbb0f1337c9abf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OQSPI Flash into power down mode. <br /></td></tr>
<tr class="separator:ga572a10b53e6ea6d20fbb0f1337c9abf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4613328037d0bf28756b4093b04124d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga4613328037d0bf28756b4093b04124d7">oqspi_automode_init</a> (void)</td></tr>
<tr class="memdesc:ga4613328037d0bf28756b4093b04124d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init OQSPI controller.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga4613328037d0bf28756b4093b04124d7">More...</a><br /></td></tr>
<tr class="separator:ga4613328037d0bf28756b4093b04124d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce76a5b2ac628cd82be85868090333e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga3ce76a5b2ac628cd82be85868090333e">oqspi_automode_sys_clock_cfg</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:ga3ce76a5b2ac628cd82be85868090333e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Flash and OQSPI controller for system clock frequency.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga3ce76a5b2ac628cd82be85868090333e">More...</a><br /></td></tr>
<tr class="separator:ga3ce76a5b2ac628cd82be85868090333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac601ca1301923c53e43ddc56926a8c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac601ca1301923c53e43ddc56926a8c43">oqspi_is_valid_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gac601ca1301923c53e43ddc56926a8c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verified that passed address is valid and physically available.  <a href="group___p_l_a___m_e_m_o_r_y.html#gac601ca1301923c53e43ddc56926a8c43">More...</a><br /></td></tr>
<tr class="separator:gac601ca1301923c53e43ddc56926a8c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7971303b85f46c90e0f5b4682ad193"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga7b7971303b85f46c90e0f5b4682ad193">oqspi_get_device_size</a> (void)</td></tr>
<tr class="memdesc:ga7b7971303b85f46c90e0f5b4682ad193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum available memory size for selected controller id.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga7b7971303b85f46c90e0f5b4682ad193">More...</a><br /></td></tr>
<tr class="separator:ga7b7971303b85f46c90e0f5b4682ad193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ff5823dca26ca180cec9422df56c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga03ff5823dca26ca180cec9422df56c47">oqspi_get_config</a> (<a class="el" href="structjedec__id__t.html">jedec_id_t</a> *jedec)</td></tr>
<tr class="memdesc:ga03ff5823dca26ca180cec9422df56c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the JEDEC ID parameters of the OQSPI flash driver.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga03ff5823dca26ca180cec9422df56c47">More...</a><br /></td></tr>
<tr class="separator:ga03ff5823dca26ca180cec9422df56c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe2afb9cee8db383caea119e3c9efb95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gabe2afb9cee8db383caea119e3c9efb95">oqspi_read_flash_jedec_id</a> (<a class="el" href="structjedec__id__t.html">jedec_id_t</a> *jedec)</td></tr>
<tr class="memdesc:gabe2afb9cee8db383caea119e3c9efb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the JEDEC ID parameters (manufacturer ID, type, density).  <a href="group___p_l_a___m_e_m_o_r_y.html#gabe2afb9cee8db383caea119e3c9efb95">More...</a><br /></td></tr>
<tr class="separator:gabe2afb9cee8db383caea119e3c9efb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f">qspi_automode_write_flash_page</a> (uint32_t addr, const uint8_t *buf, uint32_t size)</td></tr>
<tr class="memdesc:ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write flash memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f">More...</a><br /></td></tr>
<tr class="separator:ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd4cecdf5349007b99b3e17e4306f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gafcd4cecdf5349007b99b3e17e4306f36">qspi_automode_erase_flash_sector</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gafcd4cecdf5349007b99b3e17e4306f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase flash sector.  <a href="group___p_l_a___m_e_m_o_r_y.html#gafcd4cecdf5349007b99b3e17e4306f36">More...</a><br /></td></tr>
<tr class="separator:gafcd4cecdf5349007b99b3e17e4306f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9defebf9434bef90daeb8bd682c9e0de"><td class="memItemLeft" align="right" valign="top"><a id="ga9defebf9434bef90daeb8bd682c9e0de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9defebf9434bef90daeb8bd682c9e0de">qspi_automode_erase_chip</a> (void)</td></tr>
<tr class="memdesc:ga9defebf9434bef90daeb8bd682c9e0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase whole chip. <br /></td></tr>
<tr class="separator:ga9defebf9434bef90daeb8bd682c9e0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0f9c255d029a1e872e1562fe44abcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gadf0f9c255d029a1e872e1562fe44abcc">qspi_automode_erase_chip_by_id</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gadf0f9c255d029a1e872e1562fe44abcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase specific flash.  <a href="group___p_l_a___m_e_m_o_r_y.html#gadf0f9c255d029a1e872e1562fe44abcc">More...</a><br /></td></tr>
<tr class="separator:gadf0f9c255d029a1e872e1562fe44abcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f21b8d5ce8231d137b0ef88c8f17a4f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9f21b8d5ce8231d137b0ef88c8f17a4f">qspi_automode_read</a> (uint32_t addr, uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:ga9f21b8d5ce8231d137b0ef88c8f17a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga9f21b8d5ce8231d137b0ef88c8f17a4f">More...</a><br /></td></tr>
<tr class="separator:ga9f21b8d5ce8231d137b0ef88c8f17a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949df4486361e3c5d2ec9165a94fb7e8"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga949df4486361e3c5d2ec9165a94fb7e8">qspi_automode_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga949df4486361e3c5d2ec9165a94fb7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of memory.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga949df4486361e3c5d2ec9165a94fb7e8">More...</a><br /></td></tr>
<tr class="separator:ga949df4486361e3c5d2ec9165a94fb7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495dbcef4585cf6f54afca7604f62714"><td class="memItemLeft" align="right" valign="top"><a id="ga495dbcef4585cf6f54afca7604f62714"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga495dbcef4585cf6f54afca7604f62714">qspi_automode_flash_power_up</a> (void)</td></tr>
<tr class="memdesc:ga495dbcef4585cf6f54afca7604f62714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power up flash. <br /></td></tr>
<tr class="separator:ga495dbcef4585cf6f54afca7604f62714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="memItemLeft" align="right" valign="top"><a id="gad6d2b2e94eb5fe018bb212a76ddaee5d"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad6d2b2e94eb5fe018bb212a76ddaee5d">qspi_automode_flash_power_down</a> (void)</td></tr>
<tr class="memdesc:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set QSPI Flash into power down mode. <br /></td></tr>
<tr class="separator:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="memItemLeft" align="right" valign="top"><a id="gae257d1ee1830c6eef0ee9914f5c77fa6"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae257d1ee1830c6eef0ee9914f5c77fa6">qspi_automode_init</a> (void)</td></tr>
<tr class="memdesc:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init QSPI controller. <br /></td></tr>
<tr class="separator:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75fa38c03d4c4039b77840fb83b8e52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga75fa38c03d4c4039b77840fb83b8e52c">qspi_check_program_erase_in_progress</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga75fa38c03d4c4039b77840fb83b8e52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a program or sector erase operation is in progress.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga75fa38c03d4c4039b77840fb83b8e52c">More...</a><br /></td></tr>
<tr class="separator:ga75fa38c03d4c4039b77840fb83b8e52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f86c4e1d8c661aaa22cd24538498843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9f86c4e1d8c661aaa22cd24538498843">qspi_resume</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga9f86c4e1d8c661aaa22cd24538498843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a Flash program or sector erase operation.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga9f86c4e1d8c661aaa22cd24538498843">More...</a><br /></td></tr>
<tr class="separator:ga9f86c4e1d8c661aaa22cd24538498843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga98a2cc464c5ddb81b4307df949e8e79b">flash_erase_sector_manual_mode</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sector of the Flash in manual mode.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga98a2cc464c5ddb81b4307df949e8e79b">More...</a><br /></td></tr>
<tr class="separator:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cbbef4f3da5e08c1a1faeed8a53f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac3cbbef4f3da5e08c1a1faeed8a53f4c">flash_program_page_manual_mode</a> (uint32_t addr, const uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:gac3cbbef4f3da5e08c1a1faeed8a53f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program data into a page of the Flash in manual mode.  <a href="group___p_l_a___m_e_m_o_r_y.html#gac3cbbef4f3da5e08c1a1faeed8a53f4c">More...</a><br /></td></tr>
<tr class="separator:gac3cbbef4f3da5e08c1a1faeed8a53f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga0fd4f0b2853539e49bb3f3d6004c52b6">qspi_automode_sys_clock_cfg</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Flash and QSPI controller for system clock frequency.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga0fd4f0b2853539e49bb3f3d6004c52b6">More...</a><br /></td></tr>
<tr class="separator:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea5cb64307997d2a58cebd6b194a54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga4ea5cb64307997d2a58cebd6b194a54b">qspi_is_valid_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga4ea5cb64307997d2a58cebd6b194a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verified if passed adder is valid and physically available.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga4ea5cb64307997d2a58cebd6b194a54b">More...</a><br /></td></tr>
<tr class="separator:ga4ea5cb64307997d2a58cebd6b194a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd9a4eeedddc07c207e02ca25bba65c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga1dd9a4eeedddc07c207e02ca25bba65c">qspi_get_device_size</a> (const <a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga1dd9a4eeedddc07c207e02ca25bba65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum available memory size for selected controller id.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga1dd9a4eeedddc07c207e02ca25bba65c">More...</a><br /></td></tr>
<tr class="separator:ga1dd9a4eeedddc07c207e02ca25bba65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3f7ee153ed47cc1d02ca05756487b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2b3f7ee153ed47cc1d02ca05756487b8">qspi_get_config</a> (const <a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t *manufacturer_id, uint8_t *device_type, uint8_t *density)</td></tr>
<tr class="memdesc:ga2b3f7ee153ed47cc1d02ca05756487b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration parameters for selected controller id.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga2b3f7ee153ed47cc1d02ca05756487b8">More...</a><br /></td></tr>
<tr class="separator:ga2b3f7ee153ed47cc1d02ca05756487b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62058beff3233ef58137cf10709d5982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga62058beff3233ef58137cf10709d5982">qspi_read_flash_jedec_id</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t *manufacturer_id, uint8_t *device_type, uint8_t *density)</td></tr>
<tr class="memdesc:ga62058beff3233ef58137cf10709d5982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the JEDEC manufacturer ID, device type and device density using command 0x9F.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga62058beff3233ef58137cf10709d5982">More...</a><br /></td></tr>
<tr class="separator:ga62058beff3233ef58137cf10709d5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7737effb2912aa041f355c7bcd567123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga7737effb2912aa041f355c7bcd567123">qspi_is_ram_device</a> (const <a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga7737effb2912aa041f355c7bcd567123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that connected device is an external RAM.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga7737effb2912aa041f355c7bcd567123">More...</a><br /></td></tr>
<tr class="separator:ga7737effb2912aa041f355c7bcd567123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc4aba657d85110b228f069e6a9b55f"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga1dc4aba657d85110b228f069e6a9b55f">flash_w25q_wre_volatile</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga1dc4aba657d85110b228f069e6a9b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable volatile writes to Status Register bits.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga1dc4aba657d85110b228f069e6a9b55f">More...</a><br /></td></tr>
<tr class="separator:ga1dc4aba657d85110b228f069e6a9b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf549372bb57f0afa525c903a091169e1"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaf549372bb57f0afa525c903a091169e1">flash_w25q_write_status_register_2</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t value)</td></tr>
<tr class="memdesc:gaf549372bb57f0afa525c903a091169e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the Status Register 2 of the Flash.  <a href="group___p_l_a___m_e_m_o_r_y.html#gaf549372bb57f0afa525c903a091169e1">More...</a><br /></td></tr>
<tr class="separator:gaf549372bb57f0afa525c903a091169e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c7e73735115eff9ad6a926ec9a38f4e"><td class="memItemLeft" align="right" valign="top"><a id="ga4c7e73735115eff9ad6a926ec9a38f4e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga4c7e73735115eff9ad6a926ec9a38f4e">flash_XXX_is_suspended</a> (void)</td></tr>
<tr class="memdesc:ga4c7e73735115eff9ad6a926ec9a38f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns true if the flash is in write/erase suspend mode. <br /></td></tr>
<tr class="separator:ga4c7e73735115eff9ad6a926ec9a38f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84493442a9b2278e1b8442cd31e7733b"><td class="memItemLeft" align="right" valign="top"><a id="ga84493442a9b2278e1b8442cd31e7733b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga84493442a9b2278e1b8442cd31e7733b">flash_XXX_initialize</a> (uint8_t device_type, uint8_t device_density)</td></tr>
<tr class="memdesc:ga84493442a9b2278e1b8442cd31e7733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called to initialize the flash. <br /></td></tr>
<tr class="separator:ga84493442a9b2278e1b8442cd31e7733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ae33918050d0f1b1aaaf0dcb996a17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga58ae33918050d0f1b1aaaf0dcb996a17">flash_XXX_deactivate_command_entry_mode</a> (void)</td></tr>
<tr class="memdesc:ga58ae33918050d0f1b1aaaf0dcb996a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called to put the flash OUT of command entry mode.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga58ae33918050d0f1b1aaaf0dcb996a17">More...</a><br /></td></tr>
<tr class="separator:ga58ae33918050d0f1b1aaaf0dcb996a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08612f2868e8c19042cced1ea6f1408"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">flash_XXX_sys_clock_cfg</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:gae08612f2868e8c19042cced1ea6f1408"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called each time the system clock is changed.  <a href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">More...</a><br /></td></tr>
<tr class="separator:gae08612f2868e8c19042cced1ea6f1408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7ed880e0f577fc1cf08ccb9d4370b7"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">flash_XXX_get_dummy_bytes</a> (void)</td></tr>
<tr class="memdesc:gaca7ed880e0f577fc1cf08ccb9d4370b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This must return the number of dummy bytes required.  <a href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">More...</a><br /></td></tr>
<tr class="separator:gaca7ed880e0f577fc1cf08ccb9d4370b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf990f6d8a2939c4d90eb6353852d6b9e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaf990f6d8a2939c4d90eb6353852d6b9e">flash_at25sl128_config</a></td></tr>
<tr class="memdesc:gaf990f6d8a2939c4d90eb6353852d6b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct configures the system for the specific flash.  <a href="group___p_l_a___m_e_m_o_r_y.html#gaf990f6d8a2939c4d90eb6353852d6b9e">More...</a><br /></td></tr>
<tr class="separator:gaf990f6d8a2939c4d90eb6353852d6b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c46b9d7b4d8c90d1c413d36444e4db9"><td class="memItemLeft" align="right" valign="top"><a id="ga2c46b9d7b4d8c90d1c413d36444e4db9"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2c46b9d7b4d8c90d1c413d36444e4db9">w25q_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga2c46b9d7b4d8c90d1c413d36444e4db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga2c46b9d7b4d8c90d1c413d36444e4db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab3fff9d91d1281dc9ce0acd0879a8b"><td class="memItemLeft" align="right" valign="top"><a id="ga5ab3fff9d91d1281dc9ce0acd0879a8b"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga5ab3fff9d91d1281dc9ce0acd0879a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga5ab3fff9d91d1281dc9ce0acd0879a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167ea07e00ea5e4c507cb6bb7cd6f119"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga167ea07e00ea5e4c507cb6bb7cd6f119">flash_XXX_config</a></td></tr>
<tr class="memdesc:ga167ea07e00ea5e4c507cb6bb7cd6f119"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structs configures the system for the specific flash.  <a href="group___p_l_a___m_e_m_o_r_y.html#ga167ea07e00ea5e4c507cb6bb7cd6f119">More...</a><br /></td></tr>
<tr class="separator:ga167ea07e00ea5e4c507cb6bb7cd6f119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Configuration values for the various supported QSPI, OQSPI and PSRAM devices. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacb6745c33d23a6ee71eeaea8b9dda828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6745c33d23a6ee71eeaea8b9dda828">&#9670;&nbsp;</a></span>ADESTO_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADESTO_ID&#160;&#160;&#160;0x1F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the first byte returned by the 0x9F command </p>

</div>
</div>
<a id="gae68cd85bb475a4ed71d2ab5acb5f1308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae68cd85bb475a4ed71d2ab5acb5f1308">&#9670;&nbsp;</a></span>AT25SL128_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT25SL128_SIZE&#160;&#160;&#160;0x18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash density JEDEC ID. </p>
<p>This is the third byte returned by the 0x9F command </p>

</div>
</div>
<a id="gad120f9c1bc5fee08c9020c07a4ecabf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad120f9c1bc5fee08c9020c07a4ecabf9">&#9670;&nbsp;</a></span>AT25SL_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT25SL_TYPE&#160;&#160;&#160;0x42</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the second byte returned by the 0x9F command </p>

</div>
</div>
<a id="ga8e4a1a837d547365760bd32ebc664e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e4a1a837d547365760bd32ebc664e84">&#9670;&nbsp;</a></span>XXXXX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the second byte returned by the 0x9F command </p>

</div>
</div>
<a id="ga230871cbef94a3328fdcda1f87dd2bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga230871cbef94a3328fdcda1f87dd2bde">&#9670;&nbsp;</a></span>XXXXX_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX_ID&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash vendor JEDEC ID. </p>
<p>This is the first byte returned by the 0x9F command </p>

</div>
</div>
<a id="ga6f22a9fb53cdeabb03c8b173b93822ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f22a9fb53cdeabb03c8b173b93822ab">&#9670;&nbsp;</a></span>XXXXX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX_SIZE&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash density JEDEC ID. </p>
<p>This is the third byte returned by the 0x9F command </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaaca7b42888b10ca3e05786453609d0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca7b42888b10ca3e05786453609d0d3">&#9670;&nbsp;</a></span>qspi_flash_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structqspi__flash__config.html">qspi_flash_config</a>  <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI Flash configuration structure. </p>
<p>This struct is used to define a driver for a specific QSPI device.</p>
<dl class="section note"><dt>Note</dt><dd>The struct instance must be declared as static const for this to work </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga98a2cc464c5ddb81b4307df949e8e79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a2cc464c5ddb81b4307df949e8e79b">&#9670;&nbsp;</a></span>flash_erase_sector_manual_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_erase_sector_manual_mode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a sector of the Flash in manual mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the sector to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not block until the Flash has processed the command! The QSPI controller is left to manual mode after the call to this function. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a id="gac3cbbef4f3da5e08c1a1faeed8a53f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3cbbef4f3da5e08c1a1faeed8a53f4c">&#9670;&nbsp;</a></span>flash_program_page_manual_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t flash_program_page_manual_mode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program data into a page of the Flash in manual mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the Flash where the data will be written. It may be anywhere in a page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the beginning of the buffer that contains the data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The boundary of the page where addr belongs to, will not be crossed! The caller should issue another <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac3cbbef4f3da5e08c1a1faeed8a53f4c" title="Program data into a page of the Flash in manual mode.">flash_program_page_manual_mode()</a> call in order to write the remaining data to the next page. The QSPI controller is left to manual mode after the call to this function. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a id="ga1dc4aba657d85110b228f069e6a9b55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dc4aba657d85110b228f069e6a9b55f">&#9670;&nbsp;</a></span>flash_w25q_wre_volatile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a> void flash_w25q_wre_volatile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable volatile writes to Status Register bits. </p>
<p>When this command is issued, any writes to any of the Status Registers of the Flash are done as volatile writes. This command is valid only when the Write Status Register command follows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. </dd></dl>

</div>
</div>
<a id="gaf549372bb57f0afa525c903a091169e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf549372bb57f0afa525c903a091169e1">&#9670;&nbsp;</a></span>flash_w25q_write_status_register_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void flash_w25q_write_status_register_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the Status Register 2 of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. No verification that the value has been actually written is done though. It is up to the caller to decide whether such verification is needed or not and execute it on its own. </dd></dl>

</div>
</div>
<a id="ga58ae33918050d0f1b1aaaf0dcb996a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ae33918050d0f1b1aaaf0dcb996a17">&#9670;&nbsp;</a></span>flash_XXX_deactivate_command_entry_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void flash_XXX_deactivate_command_entry_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called to put the flash OUT of command entry mode. </p>
<p>Usually, this is left empty, unless something special needs to be done (Basic work is done by the central flash driver). </p>

</div>
</div>
<a id="gaca7ed880e0f577fc1cf08ccb9d4370b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca7ed880e0f577fc1cf08ccb9d4370b7">&#9670;&nbsp;</a></span>flash_XXX_get_dummy_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_XXX_get_dummy_bytes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This must return the number of dummy bytes required. </p>
<p>In most cases, this can return a static value (usually 2). Sometimes, however, the dummy bytes must change (e.g. according to the system clock frequency). </p>

</div>
</div>
<a id="gae08612f2868e8c19042cced1ea6f1408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08612f2868e8c19042cced1ea6f1408">&#9670;&nbsp;</a></span>flash_XXX_sys_clock_cfg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_XXX_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called each time the system clock is changed. </p>
<p>This can be used e.g. to change the qspi controller divider or modify the flash dummy bytes, if e.g. the flash cannot cope with the higher clock frequency. </p>

</div>
</div>
<a id="ga18ebeb4103a06e184e19831a59a29449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ebeb4103a06e184e19831a59a29449">&#9670;&nbsp;</a></span>oqspi_automode_erase_flash_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void oqspi_automode_erase_flash_sector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase Flash Sector. </p>
<p>The sector will be erased either in auto or in manual access mode depending on dgconfigOQSPI_ERASE_IN_AUTOMODE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the sector to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be used when the flash background operations are enabled. Consider using sys_background_flash_ops_erase_sector() instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___s_e_t_t_i_n_g_s.html#ga4ca080d7cbebf78c87c82ddbdc223810" title="Select whether the Octa SPI Flash memory will be erased in Auto or in Manual Access Mode.">dgconfigOQSPI_ERASE_IN_AUTOMODE</a> </dd></dl>

</div>
</div>
<a id="gabd8c2e976a5ed2fa866dba217bc9861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8c2e976a5ed2fa866dba217bc9861e">&#9670;&nbsp;</a></span>oqspi_automode_get_physical_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* oqspi_automode_get_physical_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>virtual_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the OQSPI flash memory physical address of the corresponding virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtual_addr</td><td>The OQSPI flash memory virtual address for which the physical address will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OQSPI flash memory physical address of the corresponding virtual address. </dd></dl>

</div>
</div>
<a id="ga4613328037d0bf28756b4093b04124d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4613328037d0bf28756b4093b04124d7">&#9670;&nbsp;</a></span>oqspi_automode_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool oqspi_automode_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init OQSPI controller. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the OQSPIC initialization succeeds, otherwise false. </dd></dl>

</div>
</div>
<a id="ga995856a882a5546d6b8372ce0f6d4f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga995856a882a5546d6b8372ce0f6d4f75">&#9670;&nbsp;</a></span>oqspi_automode_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t oqspi_automode_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read </dd></dl>

</div>
</div>
<a id="ga3ce76a5b2ac628cd82be85868090333e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce76a5b2ac628cd82be85868090333e">&#9670;&nbsp;</a></span>oqspi_automode_sys_clock_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void oqspi_automode_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Flash and OQSPI controller for system clock frequency. </p>
<p>This function is used to change the Flash configuration of the OQSPI controller to work with the system clock frequency defined in sys_clk. Dummy clock cycles could be changed here to support higher clock frequencies. OQSPI controller clock divider could also be changed if the Flash maximum frequency is smaller than the system clock frequency. This function must be called before changing system clock frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk</td><td>System clock frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff8d6ffabcec232ccf0b5586d5bf9b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff8d6ffabcec232ccf0b5586d5bf9b8c">&#9670;&nbsp;</a></span>oqspi_automode_write_flash_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t oqspi_automode_write_flash_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write flash memory. </p>
<p>This function allows to write up to page size of data to flash. If size is greater than page size, flash can wrap data and overwrite content of page. It's possible to write less than page size. Memory should be erased before.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not pass buf pointing to OQSPI mapped memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in flash to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be used when the flash background operations are enabled. Consider using sys_background_flash_ops_write_page() instead. </dd></dl>

</div>
</div>
<a id="ga03ff5823dca26ca180cec9422df56c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03ff5823dca26ca180cec9422df56c47">&#9670;&nbsp;</a></span>oqspi_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool oqspi_get_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjedec__id__t.html">jedec_id_t</a> *&#160;</td>
          <td class="paramname"><em>jedec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the JEDEC ID parameters of the OQSPI flash driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">jedec</td><td>Pointer to a JEDEC ID structure where the JEDEC parameters will be returned (manufacturer ID, type, density)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is marked as present, false otherwise </dd></dl>

</div>
</div>
<a id="ga7b7971303b85f46c90e0f5b4682ad193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7971303b85f46c90e0f5b4682ad193">&#9670;&nbsp;</a></span>oqspi_get_device_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t oqspi_get_device_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum available memory size for selected controller id. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum memory size counted in bytes </dd></dl>

</div>
</div>
<a id="gac601ca1301923c53e43ddc56926a8c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac601ca1301923c53e43ddc56926a8c43">&#9670;&nbsp;</a></span>oqspi_is_valid_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool oqspi_is_valid_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verified that passed address is valid and physically available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe2afb9cee8db383caea119e3c9efb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe2afb9cee8db383caea119e3c9efb95">&#9670;&nbsp;</a></span>oqspi_read_flash_jedec_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool oqspi_read_flash_jedec_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjedec__id__t.html">jedec_id_t</a> *&#160;</td>
          <td class="paramname"><em>jedec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the JEDEC ID parameters (manufacturer ID, type, density). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">jedec</td><td>Pointer to a JEDEC ID structure where the JEDEC parameters will be returned (manufacturer ID, type, density)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if JEDEC ID has been successfully read, otherwise false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The criteria for successful JEDEC ID reading depend on whether one of the following compilation options are enabled or not.</dd></dl>
<ul>
<li>dg_configOQSPI_FLASH_AUTODETECT = 1: The read JEDEC ID is compared to the JEDEC IDs of all supported memories, and if one of them matches, the function returns true. On top of that, the oqspi_flash_config is equalized with the flash driver configuration structure of the detected memory. On the contrary, if none of the JEDEC IDs matches, the function returns false.</li>
<li>dg_configOQSPI_FLASH_CONFIG_VERIFY = 1: The read JEDEC ID is compared to the JEDEC ID of the memory, for which the application is built for, and if it matches, the function returns true. Otherwise, returns false.</li>
<li>dg_configOQSPI_FLASH_AUTODETECT = dg_configOQSPI_FLASH_CONFIG_VERIFY = 0 (default): Is checked that the first byte (manufacturer_id) of read JEDEC ID sequence does not equal to 0xFF and 0x00. If this condition is fulfilled, the JEDEC ID is considered valid and the function returns true. Otherwise, it returns false. Since the aforementioned condition is relatively weak, it is highly recommended to apply a thorougher check afterwards.</li>
</ul>
<p>Should also be noted that the aforementioned options are mutually exclusive, thus cannot be enabled both at the same time.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function will reset the connected OQSPI flash memory to make sure that the memory is in single bus mode.</dd>
<dd>
The function leaves the OQSPIC in auto access mode.</dd>
<dd>
The Read JEDEC ID command is limited at a specific OQSPIC clock frequency, thus if the first attempt fails, the function switches the OQSPIC clock divider to max (8) and tries again. However, it is responsibility of the caller to make sure that the system clock is set properly before calling this function. For instance, if the system clock is PLL160 the second attempt to read the jedec id will use OQSPI clock frequency = 160MHz / 8 = 20MHz. If the maximum allowed clock frequency is 8MHz, both attempts will fail. </dd></dl>

</div>
</div>
<a id="ga949df4486361e3c5d2ec9165a94fb7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga949df4486361e3c5d2ec9165a94fb7e8">&#9670;&nbsp;</a></span>qspi_automode_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* qspi_automode_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address in CPU address space where data is located </dd></dl>

</div>
</div>
<a id="gadf0f9c255d029a1e872e1562fe44abcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf0f9c255d029a1e872e1562fe44abcc">&#9670;&nbsp;</a></span>qspi_automode_erase_chip_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qspi_automode_erase_chip_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase specific flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the QSPI controller with <code>id</code> cannot be used or if a RAM device is connected to it; true otherwise </dd></dl>

</div>
</div>
<a id="gafcd4cecdf5349007b99b3e17e4306f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd4cecdf5349007b99b3e17e4306f36">&#9670;&nbsp;</a></span>qspi_automode_erase_flash_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qspi_automode_erase_flash_sector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase flash sector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f21b8d5ce8231d137b0ef88c8f17a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f21b8d5ce8231d137b0ef88c8f17a4f">&#9670;&nbsp;</a></span>qspi_automode_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_automode_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read </dd></dl>

</div>
</div>
<a id="ga0fd4f0b2853539e49bb3f3d6004c52b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd4f0b2853539e49bb3f3d6004c52b6">&#9670;&nbsp;</a></span>qspi_automode_sys_clock_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_automode_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Flash and QSPI controller for system clock frequency. </p>
<p>This function is used to change the Flash configuration of the QSPI controller to work with the system clock frequency defined in sys_clk. Dummy clock cycles could be changed here to support higher clock frequencies. QSPI controller clock divider could also be changed if the Flash maximum frequency is smaller than the system clock frequency. This function must be called before changing system clock frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk</td><td>System clock frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f">&#9670;&nbsp;</a></span>qspi_automode_write_flash_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_automode_write_flash_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write flash memory. </p>
<p>This function allows to write up to page size of data to flash. If size is greater than page size, flash can wrap data and overwrite content of page. It's possible to write less then page size. Memory should be erased before.</p>
<dl class="section note"><dt>Note</dt><dd>: Do not pass buf pointing to QSPI mapped memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in flash to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written </p>

</div>
</div>
<a id="ga75fa38c03d4c4039b77840fb83b8e52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75fa38c03d4c4039b77840fb83b8e52c">&#9670;&nbsp;</a></span>qspi_check_program_erase_in_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_check_program_erase_in_progress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a program or sector erase operation is in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the BUSY bit is set else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function checks the value of the BUSY bit in the Status Register 1 of the Flash. It is the responsibility of the caller to call the function in the right context. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a id="ga2b3f7ee153ed47cc1d02ca05756487b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b3f7ee153ed47cc1d02ca05756487b8">&#9670;&nbsp;</a></span>qspi_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qspi_get_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>manufacturer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>density</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configuration parameters for selected controller id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">manufacturer_id</td><td>Manufacturer ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device_type</td><td>Device type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">density</td><td>Device density</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is marked as present, false otherwise </dd></dl>

</div>
</div>
<a id="ga1dd9a4eeedddc07c207e02ca25bba65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd9a4eeedddc07c207e02ca25bba65c">&#9670;&nbsp;</a></span>qspi_get_device_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_get_device_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum available memory size for selected controller id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum memory size counted in bytes </dd></dl>

</div>
</div>
<a id="ga7737effb2912aa041f355c7bcd567123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7737effb2912aa041f355c7bcd567123">&#9670;&nbsp;</a></span>qspi_is_ram_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_is_ram_device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that connected device is an external RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connected device is RAM, false otherwise </dd></dl>

</div>
</div>
<a id="ga4ea5cb64307997d2a58cebd6b194a54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea5cb64307997d2a58cebd6b194a54b">&#9670;&nbsp;</a></span>qspi_is_valid_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_is_valid_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verified if passed adder is valid and physically available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62058beff3233ef58137cf10709d5982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62058beff3233ef58137cf10709d5982">&#9670;&nbsp;</a></span>qspi_read_flash_jedec_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_read_flash_jedec_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>manufacturer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>density</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the JEDEC manufacturer ID, device type and device density using command 0x9F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">manufacturer_id</td><td>Pointer to the variable where the manufacturer ID will be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device_type</td><td>Pointer to the variable where the device type will be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">density</td><td>Pointer to the variable where the device density will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if JEDEC Id has been read successfully, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this function will reset FLASH device connected to the specified QSPI controller </dd></dl>

</div>
</div>
<a id="ga9f86c4e1d8c661aaa22cd24538498843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f86c4e1d8c661aaa22cd24538498843">&#9670;&nbsp;</a></span>qspi_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a Flash program or sector erase operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>After the call to this function, the QSPI controller is set to manual mode and the Flash access to single mode. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf990f6d8a2939c4d90eb6353852d6b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf990f6d8a2939c4d90eb6353852d6b9e">&#9670;&nbsp;</a></span>flash_at25sl128_config</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a> flash_at25sl128_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This struct configures the system for the specific flash. </p>
<dl class="section note"><dt>Note</dt><dd>This struct MUST be const for this to work. Therefore, assignments must not change (must be read-only) </dd></dl>

</div>
</div>
<a id="ga167ea07e00ea5e4c507cb6bb7cd6f119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167ea07e00ea5e4c507cb6bb7cd6f119">&#9670;&nbsp;</a></span>flash_XXX_config</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a> flash_XXX_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .manufacturer_id                  = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a>,</div>
<div class="line">        .device_type                      = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a>,</div>
<div class="line">        .device_density                   = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a>,</div>
<div class="line">        .is_suspended                     = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga4c7e73735115eff9ad6a926ec9a38f4e">flash_XXX_is_suspended</a>,</div>
<div class="line">        .initialize                       = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga84493442a9b2278e1b8442cd31e7733b">flash_XXX_initialize</a>,</div>
<div class="line">        .sys_clk_cfg                      = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">flash_XXX_sys_clock_cfg</a>,</div>
<div class="line">        .get_dummy_bytes                  = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">flash_XXX_get_dummy_bytes</a>,</div>
<div class="line">        .break_seq_size                   = <a class="code" href="group___h_w___q_s_p_i.html#ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e">HW_QSPI_BREAK_SEQ_SIZE_1B</a>,</div>
<div class="line">        .address_size                     = <a class="code" href="group___h_w___q_s_p_i.html#gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8">HW_QSPI_ADDR_SIZE_24</a>,</div>
<div class="line">        .fast_read_opcode                 = CMD_FAST_READ_QUAD,</div>
<div class="line">        .page_program_opcode              = CMD_QUAD_PAGE_PROGRAM,</div>
<div class="line">        .page_qpi_program_opcode          = CMD_QPI_PAGE_PROGRAM,</div>
<div class="line">        .quad_page_program_address        = <span class="keyword">true</span>,</div>
<div class="line">        .erase_opcode                     = CMD_SECTOR_ERASE,</div>
<div class="line">        .read_erase_progress_opcode       = CMD_READ_STATUS_REGISTER,</div>
<div class="line">        .erase_suspend_opcode             = XXX_ERASE_PROGRAM_SUSPEND,</div>
<div class="line">        .erase_resume_opcode              = XXX_ERASE_PROGRAM_RESUME,</div>
<div class="line">        .erase_in_progress_bit            = FLASH_STATUS_BUSY_BIT,</div>
<div class="line">        .erase_in_progress_bit_high_level = <span class="keyword">true</span>,</div>
<div class="line">        .send_once                        = 1,</div>
<div class="line">        .extra_byte                       = 0xA0,</div>
<div class="line">        .ucode_wakeup                     = {<a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a>, <span class="keyword">sizeof</span>(<a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a>)},</div>
<div class="line">        .power_down_delay                 = XXX_POWER_DOWN_DELAY_US,</div>
<div class="line">        .power_up_delay                   = XXX_POWER_UP_DELAY_US,</div>
<div class="line">        .release_power_down_delay         = XXX_RELEASE_POWER_DOWN_DELAY_US,</div>
<div class="line">        .qpi_mode                         = <span class="keyword">false</span>,</div>
<div class="line">        .is_ram                           = <span class="keyword">false</span>,</div>
<div class="line">        .memory_size                      = MEMORY_SIZE_XXXMb,</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This structs configures the system for the specific flash. </p>
<dl class="section note"><dt>Note</dt><dd>This struct MUST be const for this to work. Therefore, assignments must not change (must be read-only) </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_gae08612f2868e8c19042cced1ea6f1408"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">flash_XXX_sys_clock_cfg</a></div><div class="ttdeci">static void flash_XXX_sys_clock_cfg(sys_clk_t sys_clk)</div><div class="ttdoc">This is called each time the system clock is changed.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:234</div></div>
<div class="ttc" id="agroup___h_w___q_s_p_i_html_gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8"><div class="ttname"><a href="group___h_w___q_s_p_i.html#gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8">HW_QSPI_ADDR_SIZE_24</a></div><div class="ttdef"><b>Definition:</b> hw_qspi.h:65</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_ga4c7e73735115eff9ad6a926ec9a38f4e"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga4c7e73735115eff9ad6a926ec9a38f4e">flash_XXX_is_suspended</a></div><div class="ttdeci">static bool flash_XXX_is_suspended(void)</div><div class="ttdoc">This returns true if the flash is in write/erase suspend mode.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:221</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_ga8e4a1a837d547365760bd32ebc664e84"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a></div><div class="ttdeci">#define XXXXX</div><div class="ttdoc">The Flash type JEDEC ID.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:38</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_ga84493442a9b2278e1b8442cd31e7733b"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga84493442a9b2278e1b8442cd31e7733b">flash_XXX_initialize</a></div><div class="ttdeci">static void flash_XXX_initialize(uint8_t device_type, uint8_t device_density)</div><div class="ttdoc">This is called to initialize the flash.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:229</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_ga5ab3fff9d91d1281dc9ce0acd0879a8b"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a></div><div class="ttdeci">const uint32_t XXX_ucode_wakeup[]</div><div class="ttdoc">uCode for handling the QSPI FLASH exit from the &quot;Continuous Read Mode&quot;.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:121</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_gaca7ed880e0f577fc1cf08ccb9d4370b7"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">flash_XXX_get_dummy_bytes</a></div><div class="ttdeci">static uint8_t flash_XXX_get_dummy_bytes(void)</div><div class="ttdoc">This must return the number of dummy bytes required.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:245</div></div>
<div class="ttc" id="agroup___h_w___q_s_p_i_html_ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e"><div class="ttname"><a href="group___h_w___q_s_p_i.html#ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e">HW_QSPI_BREAK_SEQ_SIZE_1B</a></div><div class="ttdef"><b>Definition:</b> hw_qspi.h:162</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_ga6f22a9fb53cdeabb03c8b173b93822ab"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a></div><div class="ttdeci">#define XXXXX_SIZE</div><div class="ttdoc">The Flash density JEDEC ID.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:45</div></div>
<div class="ttc" id="agroup___p_l_a___m_e_m_o_r_y_html_ga230871cbef94a3328fdcda1f87dd2bde"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a></div><div class="ttdeci">#define XXXXX_ID</div><div class="ttdoc">The Flash vendor JEDEC ID.</div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:31</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:41 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
