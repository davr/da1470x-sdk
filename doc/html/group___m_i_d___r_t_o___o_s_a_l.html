<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: OS Abstraction Layer API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">OS Abstraction Layer API<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___r_t_o_s.html">RealTime OS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API and configuration for using an operating system with the SDK.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___m_i_d___r_t_o___o_s_a_l___m_s_g___q_u_e_u_e_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l___m_s_g___q_u_e_u_e_s.html">Message Queues</a></td></tr>
<tr class="memdesc:group___m_i_d___r_t_o___o_s_a_l___m_s_g___q_u_e_u_e_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message Queues for the Abstract OS concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___m_i_d___r_t_o___o_s_a_l___r_e_s___m_g_m_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l___r_e_s___m_g_m_t.html">Resource Management</a></td></tr>
<tr class="memdesc:group___m_i_d___r_t_o___o_s_a_l___r_e_s___m_g_m_t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource Management for the Abstract OS concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___m_i_d___r_t_o___o_s_a_l___d_g_c_o_r_o_u_t_i_n_e_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l___d_g_c_o_r_o_u_t_i_n_e_s.html">Dialog CoRoutines (based on FreeRTOS CoRoutines)</a></td></tr>
<tr class="memdesc:group___m_i_d___r_t_o___o_s_a_l___d_g_c_o_r_o_u_t_i_n_e_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only source code documentation available for this module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___m_i_d___r_t_o___o_s_a_l___f_r_e_e_r_t_o_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l___f_r_e_e_r_t_o_s.html">OSAL for FreeRTOS</a></td></tr>
<tr class="memdesc:group___m_i_d___r_t_o___o_s_a_l___f_r_e_e_r_t_o_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only source code documentation available for this module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:osal_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osal_8h.html">osal.h</a></td></tr>
<tr class="memdesc:osal_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS abstraction layer API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf02f894fd016f2e3a90d7e7c3d478f61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf02f894fd016f2e3a90d7e7c3d478f61">OS_USE_TICKLESS_IDLE</a>&#160;&#160;&#160;_OS_USE_TICKLESS_IDLE</td></tr>
<tr class="memdesc:gaf02f894fd016f2e3a90d7e7c3d478f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable use of low power tickless mode.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf02f894fd016f2e3a90d7e7c3d478f61">More...</a><br /></td></tr>
<tr class="separator:gaf02f894fd016f2e3a90d7e7c3d478f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089e39114539391536534d02dbd90c09"><td class="memItemLeft" align="right" valign="top"><a id="ga089e39114539391536534d02dbd90c09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga089e39114539391536534d02dbd90c09">OS_TOTAL_HEAP_SIZE</a>&#160;&#160;&#160;_OS_TOTAL_HEAP_SIZE</td></tr>
<tr class="memdesc:ga089e39114539391536534d02dbd90c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of heap memory available for the OS. <br /></td></tr>
<tr class="separator:ga089e39114539391536534d02dbd90c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b225206abfd5677eeb71c63d99775e"><td class="memItemLeft" align="right" valign="top"><a id="ga62b225206abfd5677eeb71c63d99775e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga62b225206abfd5677eeb71c63d99775e">OS_STACK_WORD_SIZE</a>&#160;&#160;&#160;_OS_STACK_WORD_SIZE</td></tr>
<tr class="memdesc:ga62b225206abfd5677eeb71c63d99775e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word size used for the items stored to the stack. <br /></td></tr>
<tr class="separator:ga62b225206abfd5677eeb71c63d99775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb682982f7f1c6fa9b75c07d368b2c6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gadb682982f7f1c6fa9b75c07d368b2c6a">OS_MINIMAL_TASK_STACK_SIZE</a>&#160;&#160;&#160;_OS_MINIMAL_TASK_STACK_SIZE</td></tr>
<tr class="memdesc:gadb682982f7f1c6fa9b75c07d368b2c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal stack size (in bytes) defined for an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gadb682982f7f1c6fa9b75c07d368b2c6a">More...</a><br /></td></tr>
<tr class="separator:gadb682982f7f1c6fa9b75c07d368b2c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88195b3d9664456c4b0cad3d4cc32090"><td class="memItemLeft" align="right" valign="top"><a id="ga88195b3d9664456c4b0cad3d4cc32090"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga88195b3d9664456c4b0cad3d4cc32090">OS_DAEMON_TASK_PRIORITY</a>&#160;&#160;&#160;_OS_DAEMON_TASK_PRIORITY</td></tr>
<tr class="memdesc:ga88195b3d9664456c4b0cad3d4cc32090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority of timer daemon OS task. <br /></td></tr>
<tr class="separator:ga88195b3d9664456c4b0cad3d4cc32090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369391e8f1ca8d80c3f9b0866b8fea31"><td class="memItemLeft" align="right" valign="top"><a id="ga369391e8f1ca8d80c3f9b0866b8fea31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga369391e8f1ca8d80c3f9b0866b8fea31">OS_TASK_PRIORITY_LOWEST</a>&#160;&#160;&#160;_OS_TASK_PRIORITY_LOWEST</td></tr>
<tr class="memdesc:ga369391e8f1ca8d80c3f9b0866b8fea31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest (idle) task priority. <br /></td></tr>
<tr class="separator:ga369391e8f1ca8d80c3f9b0866b8fea31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b7ebcd4846aef06e5dff1d322a8df1"><td class="memItemLeft" align="right" valign="top"><a id="gae4b7ebcd4846aef06e5dff1d322a8df1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae4b7ebcd4846aef06e5dff1d322a8df1">OS_TASK_PRIORITY_NORMAL</a>&#160;&#160;&#160;_OS_TASK_PRIORITY_NORMAL</td></tr>
<tr class="memdesc:gae4b7ebcd4846aef06e5dff1d322a8df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal task priority. <br /></td></tr>
<tr class="separator:gae4b7ebcd4846aef06e5dff1d322a8df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2defc66ba5b2d058d240f5adacad286"><td class="memItemLeft" align="right" valign="top"><a id="gaa2defc66ba5b2d058d240f5adacad286"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa2defc66ba5b2d058d240f5adacad286">OS_TASK_PRIORITY_HIGHEST</a>&#160;&#160;&#160;_OS_TASK_PRIORITY_HIGHEST</td></tr>
<tr class="memdesc:gaa2defc66ba5b2d058d240f5adacad286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest task priority. <br /></td></tr>
<tr class="separator:gaa2defc66ba5b2d058d240f5adacad286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c5e718403b3f2e04584a295b0ef670"><td class="memItemLeft" align="right" valign="top"><a id="ga71c5e718403b3f2e04584a295b0ef670"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga71c5e718403b3f2e04584a295b0ef670">OS_TASK</a>&#160;&#160;&#160;_OS_TASK</td></tr>
<tr class="memdesc:ga71c5e718403b3f2e04584a295b0ef670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task handle type. <br /></td></tr>
<tr class="separator:ga71c5e718403b3f2e04584a295b0ef670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a8dd41592f3ebf585666b331bc2a11"><td class="memItemLeft" align="right" valign="top"><a id="gae3a8dd41592f3ebf585666b331bc2a11"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae3a8dd41592f3ebf585666b331bc2a11">OS_TASK_STATUS</a>&#160;&#160;&#160;_OS_TASK_STATUS</td></tr>
<tr class="memdesc:gae3a8dd41592f3ebf585666b331bc2a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task status type. <br /></td></tr>
<tr class="separator:gae3a8dd41592f3ebf585666b331bc2a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b65fd99a07242a1ea9daa644835356"><td class="memItemLeft" align="right" valign="top"><a id="gaf5b65fd99a07242a1ea9daa644835356"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf5b65fd99a07242a1ea9daa644835356">OS_TASK_CREATE_SUCCESS</a>&#160;&#160;&#160;_OS_TASK_CREATE_SUCCESS</td></tr>
<tr class="memdesc:gaf5b65fd99a07242a1ea9daa644835356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task created successfully. <br /></td></tr>
<tr class="separator:gaf5b65fd99a07242a1ea9daa644835356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e79a0d42b36fcef7ee7a3b195d9aec"><td class="memItemLeft" align="right" valign="top"><a id="ga12e79a0d42b36fcef7ee7a3b195d9aec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga12e79a0d42b36fcef7ee7a3b195d9aec">OS_TASK_NOTIFY_SUCCESS</a>&#160;&#160;&#160;_OS_TASK_NOTIFY_SUCCESS</td></tr>
<tr class="memdesc:ga12e79a0d42b36fcef7ee7a3b195d9aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task notified successfully. <br /></td></tr>
<tr class="separator:ga12e79a0d42b36fcef7ee7a3b195d9aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ab1bb4d86c387e00d570baecc0df2f"><td class="memItemLeft" align="right" valign="top"><a id="gae1ab1bb4d86c387e00d570baecc0df2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae1ab1bb4d86c387e00d570baecc0df2f">OS_TASK_NOTIFY_FAIL</a>&#160;&#160;&#160;_OS_TASK_NOTIFY_FAIL</td></tr>
<tr class="memdesc:gae1ab1bb4d86c387e00d570baecc0df2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task failed to be notified. <br /></td></tr>
<tr class="separator:gae1ab1bb4d86c387e00d570baecc0df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2328791dfdb65f2b97226b48bccd22da"><td class="memItemLeft" align="right" valign="top"><a id="ga2328791dfdb65f2b97226b48bccd22da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2328791dfdb65f2b97226b48bccd22da">OS_TASK_NOTIFY_NO_WAIT</a>&#160;&#160;&#160;_OS_TASK_NOTIFY_NO_WAIT</td></tr>
<tr class="memdesc:ga2328791dfdb65f2b97226b48bccd22da"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-blocking and waiting for task to be notified. <br /></td></tr>
<tr class="separator:ga2328791dfdb65f2b97226b48bccd22da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba3a715ae4aa9783837809b9adc91b5"><td class="memItemLeft" align="right" valign="top"><a id="gafba3a715ae4aa9783837809b9adc91b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafba3a715ae4aa9783837809b9adc91b5">OS_TASK_NOTIFY_FOREVER</a>&#160;&#160;&#160;_OS_TASK_NOTIFY_FOREVER</td></tr>
<tr class="memdesc:gafba3a715ae4aa9783837809b9adc91b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time (in OS ticks) to block while waiting for task to be notified. <br /></td></tr>
<tr class="separator:gafba3a715ae4aa9783837809b9adc91b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08cf45e28d18efbd11022b402c411be0"><td class="memItemLeft" align="right" valign="top"><a id="ga08cf45e28d18efbd11022b402c411be0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga08cf45e28d18efbd11022b402c411be0">OS_TASK_NOTIFY_NONE</a>&#160;&#160;&#160;_OS_TASK_NOTIFY_NONE</td></tr>
<tr class="memdesc:ga08cf45e28d18efbd11022b402c411be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask value to notify NO other task. <br /></td></tr>
<tr class="separator:ga08cf45e28d18efbd11022b402c411be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c3983898306d370308a4346297d5f6"><td class="memItemLeft" align="right" valign="top"><a id="ga38c3983898306d370308a4346297d5f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga38c3983898306d370308a4346297d5f6">OS_TASK_NOTIFY_ALL_BITS</a>&#160;&#160;&#160;_OS_TASK_NOTIFY_ALL_BITS</td></tr>
<tr class="memdesc:ga38c3983898306d370308a4346297d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask value to update all notification bits. <br /></td></tr>
<tr class="separator:ga38c3983898306d370308a4346297d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c5dbeb29689cc25989a6d2a9d6c576"><td class="memItemLeft" align="right" valign="top"><a id="gae7c5dbeb29689cc25989a6d2a9d6c576"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae7c5dbeb29689cc25989a6d2a9d6c576">OS_MUTEX</a>&#160;&#160;&#160;_OS_MUTEX</td></tr>
<tr class="memdesc:gae7c5dbeb29689cc25989a6d2a9d6c576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex handle type. <br /></td></tr>
<tr class="separator:gae7c5dbeb29689cc25989a6d2a9d6c576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5a5d2964add6351fb62756f07e1a36"><td class="memItemLeft" align="right" valign="top"><a id="gaaa5a5d2964add6351fb62756f07e1a36"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaaa5a5d2964add6351fb62756f07e1a36">OS_MUTEX_CREATE_SUCCESS</a>&#160;&#160;&#160;_OS_MUTEX_CREATE_SUCCESS</td></tr>
<tr class="memdesc:gaaa5a5d2964add6351fb62756f07e1a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex created successfully. <br /></td></tr>
<tr class="separator:gaaa5a5d2964add6351fb62756f07e1a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c295a966bce5d380ff8444dc55f36f8"><td class="memItemLeft" align="right" valign="top"><a id="ga5c295a966bce5d380ff8444dc55f36f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga5c295a966bce5d380ff8444dc55f36f8">OS_MUTEX_CREATE_FAIL</a>&#160;&#160;&#160;_OS_MUTEX_CREATE_FAIL</td></tr>
<tr class="memdesc:ga5c295a966bce5d380ff8444dc55f36f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex failed to be created. <br /></td></tr>
<tr class="separator:ga5c295a966bce5d380ff8444dc55f36f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5893744c78917098de907860aebf782"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa5893744c78917098de907860aebf782">OS_MUTEX_CREATE_FAILED</a>&#160;&#160;&#160;((void)OS_MUTEX_CREATE_FAILED,  <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga5c295a966bce5d380ff8444dc55f36f8">OS_MUTEX_CREATE_FAIL</a>)</td></tr>
<tr class="memdesc:gaa5893744c78917098de907860aebf782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex failed to be created.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa5893744c78917098de907860aebf782">More...</a><br /></td></tr>
<tr class="separator:gaa5893744c78917098de907860aebf782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1295bacee71ac4b9c203a5a75996cbed"><td class="memItemLeft" align="right" valign="top"><a id="ga1295bacee71ac4b9c203a5a75996cbed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1295bacee71ac4b9c203a5a75996cbed">OS_MUTEX_TAKEN</a>&#160;&#160;&#160;_OS_MUTEX_TAKEN</td></tr>
<tr class="memdesc:ga1295bacee71ac4b9c203a5a75996cbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex acquired successfully. <br /></td></tr>
<tr class="separator:ga1295bacee71ac4b9c203a5a75996cbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dffb51e6c8c8472f5437bbb97c0154a"><td class="memItemLeft" align="right" valign="top"><a id="ga3dffb51e6c8c8472f5437bbb97c0154a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3dffb51e6c8c8472f5437bbb97c0154a">OS_MUTEX_NOT_TAKEN</a>&#160;&#160;&#160;_OS_MUTEX_NOT_TAKEN</td></tr>
<tr class="memdesc:ga3dffb51e6c8c8472f5437bbb97c0154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex failed to be acquired. <br /></td></tr>
<tr class="separator:ga3dffb51e6c8c8472f5437bbb97c0154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda922731ba83a589b281c6bcd75a45e"><td class="memItemLeft" align="right" valign="top"><a id="gadda922731ba83a589b281c6bcd75a45e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gadda922731ba83a589b281c6bcd75a45e">OS_MUTEX_NO_WAIT</a>&#160;&#160;&#160;_OS_MUTEX_NO_WAIT</td></tr>
<tr class="memdesc:gadda922731ba83a589b281c6bcd75a45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-blocking and waiting for mutex to be acquired. <br /></td></tr>
<tr class="separator:gadda922731ba83a589b281c6bcd75a45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf2ff448812aaef4ee8ddf78876aa32"><td class="memItemLeft" align="right" valign="top"><a id="gaecf2ff448812aaef4ee8ddf78876aa32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaecf2ff448812aaef4ee8ddf78876aa32">OS_MUTEX_FOREVER</a>&#160;&#160;&#160;_OS_MUTEX_FOREVER</td></tr>
<tr class="memdesc:gaecf2ff448812aaef4ee8ddf78876aa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time to block while waiting for mutex to be acquired. <br /></td></tr>
<tr class="separator:gaecf2ff448812aaef4ee8ddf78876aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad244a641778a6203198d210e367949ab"><td class="memItemLeft" align="right" valign="top"><a id="gad244a641778a6203198d210e367949ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gad244a641778a6203198d210e367949ab">OS_EVENT</a>&#160;&#160;&#160;_OS_EVENT</td></tr>
<tr class="memdesc:gad244a641778a6203198d210e367949ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handle type. <br /></td></tr>
<tr class="separator:gad244a641778a6203198d210e367949ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abfd99a5172291c7d6b505b94b67afc"><td class="memItemLeft" align="right" valign="top"><a id="ga7abfd99a5172291c7d6b505b94b67afc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7abfd99a5172291c7d6b505b94b67afc">OS_EVENT_CREATE_SUCCESS</a>&#160;&#160;&#160;_OS_EVENT_CREATE_SUCCESS</td></tr>
<tr class="memdesc:ga7abfd99a5172291c7d6b505b94b67afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event created successfully. <br /></td></tr>
<tr class="separator:ga7abfd99a5172291c7d6b505b94b67afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0781087ee54e5d1a007f6a6a7926ed79"><td class="memItemLeft" align="right" valign="top"><a id="ga0781087ee54e5d1a007f6a6a7926ed79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0781087ee54e5d1a007f6a6a7926ed79">OS_EVENT_CREATE_FAIL</a>&#160;&#160;&#160;_OS_EVENT_CREATE_FAIL</td></tr>
<tr class="memdesc:ga0781087ee54e5d1a007f6a6a7926ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event failed to be created. <br /></td></tr>
<tr class="separator:ga0781087ee54e5d1a007f6a6a7926ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c70e9ad6357b14cac5ab193f4038043"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8c70e9ad6357b14cac5ab193f4038043">OS_EVENT_CREATE_FAILED</a>&#160;&#160;&#160;((void)OS_EVENT_CREATE_FAILED,  <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0781087ee54e5d1a007f6a6a7926ed79">OS_EVENT_CREATE_FAIL</a>)</td></tr>
<tr class="memdesc:ga8c70e9ad6357b14cac5ab193f4038043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event failed to be created.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8c70e9ad6357b14cac5ab193f4038043">More...</a><br /></td></tr>
<tr class="separator:ga8c70e9ad6357b14cac5ab193f4038043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bc13753fcade3195404ba55c39ee90"><td class="memItemLeft" align="right" valign="top"><a id="gae8bc13753fcade3195404ba55c39ee90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae8bc13753fcade3195404ba55c39ee90">OS_EVENT_SIGNALED</a>&#160;&#160;&#160;_OS_EVENT_SIGNALED</td></tr>
<tr class="memdesc:gae8bc13753fcade3195404ba55c39ee90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event signaled. <br /></td></tr>
<tr class="separator:gae8bc13753fcade3195404ba55c39ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b2f280de2c4ce32e921cec1c6194cf"><td class="memItemLeft" align="right" valign="top"><a id="ga40b2f280de2c4ce32e921cec1c6194cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga40b2f280de2c4ce32e921cec1c6194cf">OS_EVENT_NOT_SIGNALED</a>&#160;&#160;&#160;_OS_EVENT_NOT_SIGNALED</td></tr>
<tr class="memdesc:ga40b2f280de2c4ce32e921cec1c6194cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event not signaled. <br /></td></tr>
<tr class="separator:ga40b2f280de2c4ce32e921cec1c6194cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad5f0dc087a1e67f3893164ff2c557c2"><td class="memItemLeft" align="right" valign="top"><a id="gaad5f0dc087a1e67f3893164ff2c557c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaad5f0dc087a1e67f3893164ff2c557c2">OS_EVENT_NO_WAIT</a>&#160;&#160;&#160;_OS_EVENT_NO_WAIT</td></tr>
<tr class="memdesc:gaad5f0dc087a1e67f3893164ff2c557c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-blocking and waiting for event to be signaled. <br /></td></tr>
<tr class="separator:gaad5f0dc087a1e67f3893164ff2c557c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4be29bf41911882b3eb153c75bf77e"><td class="memItemLeft" align="right" valign="top"><a id="ga3d4be29bf41911882b3eb153c75bf77e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3d4be29bf41911882b3eb153c75bf77e">OS_EVENT_FOREVER</a>&#160;&#160;&#160;_OS_EVENT_FOREVER</td></tr>
<tr class="memdesc:ga3d4be29bf41911882b3eb153c75bf77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time (in OS ticks) to block while waiting for event to be signaled. <br /></td></tr>
<tr class="separator:ga3d4be29bf41911882b3eb153c75bf77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a854fc0a25eee6d01b90858b2af1be"><td class="memItemLeft" align="right" valign="top"><a id="gab1a854fc0a25eee6d01b90858b2af1be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab1a854fc0a25eee6d01b90858b2af1be">OS_EVENT_GROUP</a>&#160;&#160;&#160;_OS_EVENT_GROUP</td></tr>
<tr class="memdesc:gab1a854fc0a25eee6d01b90858b2af1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event group handle type. <br /></td></tr>
<tr class="separator:gab1a854fc0a25eee6d01b90858b2af1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa523f4383a8174639e1fc3d0446ad551"><td class="memItemLeft" align="right" valign="top"><a id="gaa523f4383a8174639e1fc3d0446ad551"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa523f4383a8174639e1fc3d0446ad551">OS_EVENT_GROUP_OK</a>&#160;&#160;&#160;_OS_EVENT_GROUP_OK</td></tr>
<tr class="memdesc:gaa523f4383a8174639e1fc3d0446ad551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event group attribute is set. <br /></td></tr>
<tr class="separator:gaa523f4383a8174639e1fc3d0446ad551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8d6b3c5307444bbc803706e5ad83e3"><td class="memItemLeft" align="right" valign="top"><a id="ga5d8d6b3c5307444bbc803706e5ad83e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga5d8d6b3c5307444bbc803706e5ad83e3">OS_EVENT_GROUP_FAIL</a>&#160;&#160;&#160;_OS_EVENT_GROUP_FAIL</td></tr>
<tr class="memdesc:ga5d8d6b3c5307444bbc803706e5ad83e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event group attribute is cleared. <br /></td></tr>
<tr class="separator:ga5d8d6b3c5307444bbc803706e5ad83e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1fc282825f2e444d7ba557f0521de0"><td class="memItemLeft" align="right" valign="top"><a id="gaaf1fc282825f2e444d7ba557f0521de0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaaf1fc282825f2e444d7ba557f0521de0">OS_EVENT_GROUP_NO_WAIT</a>&#160;&#160;&#160;_OS_EVENT_GROUP_NO_WAIT</td></tr>
<tr class="memdesc:gaaf1fc282825f2e444d7ba557f0521de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-blocking and waiting for event group bits to be set. <br /></td></tr>
<tr class="separator:gaaf1fc282825f2e444d7ba557f0521de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a98d76578a1b65f019e6fbb5eea0bb"><td class="memItemLeft" align="right" valign="top"><a id="ga39a98d76578a1b65f019e6fbb5eea0bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga39a98d76578a1b65f019e6fbb5eea0bb">OS_EVENT_GROUP_FOREVER</a>&#160;&#160;&#160;_OS_EVENT_GROUP_FOREVER</td></tr>
<tr class="memdesc:ga39a98d76578a1b65f019e6fbb5eea0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time (in OS ticks) to block while waiting for event group bits to be set. <br /></td></tr>
<tr class="separator:ga39a98d76578a1b65f019e6fbb5eea0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9de6ba263085b8b217f87ab0bc41edf"><td class="memItemLeft" align="right" valign="top"><a id="gaa9de6ba263085b8b217f87ab0bc41edf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa9de6ba263085b8b217f87ab0bc41edf">OS_QUEUE</a>&#160;&#160;&#160;_OS_QUEUE</td></tr>
<tr class="memdesc:gaa9de6ba263085b8b217f87ab0bc41edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event group handle type. <br /></td></tr>
<tr class="separator:gaa9de6ba263085b8b217f87ab0bc41edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga983337229e3f4aa90eb9479c01022441"><td class="memItemLeft" align="right" valign="top"><a id="ga983337229e3f4aa90eb9479c01022441"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga983337229e3f4aa90eb9479c01022441">OS_QUEUE_OK</a>&#160;&#160;&#160;_OS_QUEUE_OK</td></tr>
<tr class="memdesc:ga983337229e3f4aa90eb9479c01022441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue operation completed successfully. <br /></td></tr>
<tr class="separator:ga983337229e3f4aa90eb9479c01022441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb3ced7e39cd5e1ca6d4c45f153cbc2"><td class="memItemLeft" align="right" valign="top"><a id="ga1bb3ced7e39cd5e1ca6d4c45f153cbc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1bb3ced7e39cd5e1ca6d4c45f153cbc2">OS_QUEUE_FULL</a>&#160;&#160;&#160;_OS_QUEUE_FULL</td></tr>
<tr class="memdesc:ga1bb3ced7e39cd5e1ca6d4c45f153cbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue operation failed; queue is full. <br /></td></tr>
<tr class="separator:ga1bb3ced7e39cd5e1ca6d4c45f153cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649aefc48b25fa31f54b59fe16fc501f"><td class="memItemLeft" align="right" valign="top"><a id="ga649aefc48b25fa31f54b59fe16fc501f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga649aefc48b25fa31f54b59fe16fc501f">OS_QUEUE_EMPTY</a>&#160;&#160;&#160;_OS_QUEUE_EMPTY</td></tr>
<tr class="memdesc:ga649aefc48b25fa31f54b59fe16fc501f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue operation failed; queue is empty. <br /></td></tr>
<tr class="separator:ga649aefc48b25fa31f54b59fe16fc501f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f866b7f641db644c2464a77d4f7354"><td class="memItemLeft" align="right" valign="top"><a id="ga17f866b7f641db644c2464a77d4f7354"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga17f866b7f641db644c2464a77d4f7354">OS_QUEUE_NO_WAIT</a>&#160;&#160;&#160;_OS_QUEUE_NO_WAIT</td></tr>
<tr class="memdesc:ga17f866b7f641db644c2464a77d4f7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-blocking and waiting for queue operation to complete. <br /></td></tr>
<tr class="separator:ga17f866b7f641db644c2464a77d4f7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef0323d885f0c7e40094aaf4002290f"><td class="memItemLeft" align="right" valign="top"><a id="ga7ef0323d885f0c7e40094aaf4002290f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7ef0323d885f0c7e40094aaf4002290f">OS_QUEUE_FOREVER</a>&#160;&#160;&#160;_OS_QUEUE_FOREVER</td></tr>
<tr class="memdesc:ga7ef0323d885f0c7e40094aaf4002290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time (in OS ticks) to block while waiting for queue operation to complete. <br /></td></tr>
<tr class="separator:ga7ef0323d885f0c7e40094aaf4002290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d395639a45fe25a8b3d5f4cbe4bb32"><td class="memItemLeft" align="right" valign="top"><a id="ga91d395639a45fe25a8b3d5f4cbe4bb32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga91d395639a45fe25a8b3d5f4cbe4bb32">OS_TIMER</a>&#160;&#160;&#160;_OS_TIMER</td></tr>
<tr class="memdesc:ga91d395639a45fe25a8b3d5f4cbe4bb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer handle type. <br /></td></tr>
<tr class="separator:ga91d395639a45fe25a8b3d5f4cbe4bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe8a016ab2b2067b128a1a41aecdbac"><td class="memItemLeft" align="right" valign="top"><a id="gafbe8a016ab2b2067b128a1a41aecdbac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafbe8a016ab2b2067b128a1a41aecdbac">OS_TIMER_SUCCESS</a>&#160;&#160;&#160;_OS_TIMER_SUCCESS</td></tr>
<tr class="memdesc:gafbe8a016ab2b2067b128a1a41aecdbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer operation completed successfully. <br /></td></tr>
<tr class="separator:gafbe8a016ab2b2067b128a1a41aecdbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853333f3206f8978a32f61f26384f46e"><td class="memItemLeft" align="right" valign="top"><a id="ga853333f3206f8978a32f61f26384f46e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga853333f3206f8978a32f61f26384f46e">OS_TIMER_FAIL</a>&#160;&#160;&#160;_OS_TIMER_FAIL</td></tr>
<tr class="memdesc:ga853333f3206f8978a32f61f26384f46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer operation failed. <br /></td></tr>
<tr class="separator:ga853333f3206f8978a32f61f26384f46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f2ec82c20179cd9595f7c1859be0b8"><td class="memItemLeft" align="right" valign="top"><a id="ga63f2ec82c20179cd9595f7c1859be0b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga63f2ec82c20179cd9595f7c1859be0b8">OS_TIMER_RELOAD</a>&#160;&#160;&#160;_OS_TIMER_RELOAD</td></tr>
<tr class="memdesc:ga63f2ec82c20179cd9595f7c1859be0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer is periodic. <br /></td></tr>
<tr class="separator:ga63f2ec82c20179cd9595f7c1859be0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4285966c018c74c0ee0f2d5486731f41"><td class="memItemLeft" align="right" valign="top"><a id="ga4285966c018c74c0ee0f2d5486731f41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4285966c018c74c0ee0f2d5486731f41">OS_TIMER_ONCE</a>&#160;&#160;&#160;_OS_TIMER_ONCE</td></tr>
<tr class="memdesc:ga4285966c018c74c0ee0f2d5486731f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer is one-shot. <br /></td></tr>
<tr class="separator:ga4285966c018c74c0ee0f2d5486731f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5c5b56b8768c8766e189a5ab0ce03d"><td class="memItemLeft" align="right" valign="top"><a id="ga0a5c5b56b8768c8766e189a5ab0ce03d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0a5c5b56b8768c8766e189a5ab0ce03d">OS_TIMER_NO_WAIT</a>&#160;&#160;&#160;_OS_TIMER_NO_WAIT</td></tr>
<tr class="memdesc:ga0a5c5b56b8768c8766e189a5ab0ce03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-blocking and waiting for timer operation to complete. <br /></td></tr>
<tr class="separator:ga0a5c5b56b8768c8766e189a5ab0ce03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87fe8b4a098a589fade092b0934dab4d"><td class="memItemLeft" align="right" valign="top"><a id="ga87fe8b4a098a589fade092b0934dab4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga87fe8b4a098a589fade092b0934dab4d">OS_TIMER_FOREVER</a>&#160;&#160;&#160;_OS_TIMER_FOREVER</td></tr>
<tr class="memdesc:ga87fe8b4a098a589fade092b0934dab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time (in OS ticks) to block while waiting for timer operation to complete. <br /></td></tr>
<tr class="separator:ga87fe8b4a098a589fade092b0934dab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16162572822162de27bf1389ad4063c8"><td class="memItemLeft" align="right" valign="top"><a id="ga16162572822162de27bf1389ad4063c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga16162572822162de27bf1389ad4063c8">OS_BASE_TYPE</a>&#160;&#160;&#160;_OS_BASE_TYPE</td></tr>
<tr class="memdesc:ga16162572822162de27bf1389ad4063c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type. <br /></td></tr>
<tr class="separator:ga16162572822162de27bf1389ad4063c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddbe02246001f083b49b7ec0dcdc0c5"><td class="memItemLeft" align="right" valign="top"><a id="gacddbe02246001f083b49b7ec0dcdc0c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gacddbe02246001f083b49b7ec0dcdc0c5">OS_UBASE_TYPE</a>&#160;&#160;&#160;_OS_UBASE_TYPE</td></tr>
<tr class="memdesc:gacddbe02246001f083b49b7ec0dcdc0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned base type. <br /></td></tr>
<tr class="separator:gacddbe02246001f083b49b7ec0dcdc0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5506797548c89cf151caf7b00ecdee0"><td class="memItemLeft" align="right" valign="top"><a id="gae5506797548c89cf151caf7b00ecdee0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae5506797548c89cf151caf7b00ecdee0">OS_OK</a>&#160;&#160;&#160;_OS_OK</td></tr>
<tr class="memdesc:gae5506797548c89cf151caf7b00ecdee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful operation. <br /></td></tr>
<tr class="separator:gae5506797548c89cf151caf7b00ecdee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2ebb447006820a2fc68e5b300d5f1a"><td class="memItemLeft" align="right" valign="top"><a id="ga6b2ebb447006820a2fc68e5b300d5f1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga6b2ebb447006820a2fc68e5b300d5f1a">OS_FAIL</a>&#160;&#160;&#160;_OS_FAIL</td></tr>
<tr class="memdesc:ga6b2ebb447006820a2fc68e5b300d5f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsuccessful operation. <br /></td></tr>
<tr class="separator:ga6b2ebb447006820a2fc68e5b300d5f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998ec127dfac549592d84afb2a9ac323"><td class="memItemLeft" align="right" valign="top"><a id="ga998ec127dfac549592d84afb2a9ac323"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga998ec127dfac549592d84afb2a9ac323">OS_TRUE</a>&#160;&#160;&#160;_OS_TRUE</td></tr>
<tr class="memdesc:ga998ec127dfac549592d84afb2a9ac323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean True. <br /></td></tr>
<tr class="separator:ga998ec127dfac549592d84afb2a9ac323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0edee36263795a0a1f30658d4c8a3f"><td class="memItemLeft" align="right" valign="top"><a id="ga5e0edee36263795a0a1f30658d4c8a3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga5e0edee36263795a0a1f30658d4c8a3f">OS_FALSE</a>&#160;&#160;&#160;_OS_FALSE</td></tr>
<tr class="memdesc:ga5e0edee36263795a0a1f30658d4c8a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean False. <br /></td></tr>
<tr class="separator:ga5e0edee36263795a0a1f30658d4c8a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168121420de49c097f3973fc0e8fefff"><td class="memItemLeft" align="right" valign="top"><a id="ga168121420de49c097f3973fc0e8fefff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga168121420de49c097f3973fc0e8fefff">OS_MAX_DELAY</a>&#160;&#160;&#160;_OS_MAX_DELAY</td></tr>
<tr class="memdesc:ga168121420de49c097f3973fc0e8fefff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum OS delay (in OS ticks) <br /></td></tr>
<tr class="separator:ga168121420de49c097f3973fc0e8fefff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e313a501f474c356c7caee8c1f07a6"><td class="memItemLeft" align="right" valign="top"><a id="gab4e313a501f474c356c7caee8c1f07a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4e313a501f474c356c7caee8c1f07a6">OS_TICK_TIME</a>&#160;&#160;&#160;_OS_TICK_TIME</td></tr>
<tr class="memdesc:gab4e313a501f474c356c7caee8c1f07a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS tick time (i.e. time expressed in OS ticks) data type. <br /></td></tr>
<tr class="separator:gab4e313a501f474c356c7caee8c1f07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3234325211ce4d7ac1fa68ced55f8cf0"><td class="memItemLeft" align="right" valign="top"><a id="ga3234325211ce4d7ac1fa68ced55f8cf0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3234325211ce4d7ac1fa68ced55f8cf0">OS_TICK_PERIOD</a>&#160;&#160;&#160;_OS_TICK_PERIOD</td></tr>
<tr class="memdesc:ga3234325211ce4d7ac1fa68ced55f8cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS tick period (in cycles of source clock used for the OS timer) <br /></td></tr>
<tr class="separator:ga3234325211ce4d7ac1fa68ced55f8cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9c4c46f8f9ff59d4f28571bbe30471"><td class="memItemLeft" align="right" valign="top"><a id="ga2d9c4c46f8f9ff59d4f28571bbe30471"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2d9c4c46f8f9ff59d4f28571bbe30471">OS_TICK_PERIOD_MS</a>&#160;&#160;&#160;_OS_TICK_PERIOD_MS</td></tr>
<tr class="memdesc:ga2d9c4c46f8f9ff59d4f28571bbe30471"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS tick period (in msec) <br /></td></tr>
<tr class="separator:ga2d9c4c46f8f9ff59d4f28571bbe30471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ff8327f2bc3495792a7b4f1beafecc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8ff8327f2bc3495792a7b4f1beafecc9">OS_PERIOD_MS</a>&#160;&#160;&#160;((void)OS_PERIOD_MS,            <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2d9c4c46f8f9ff59d4f28571bbe30471">OS_TICK_PERIOD_MS</a>)</td></tr>
<tr class="memdesc:ga8ff8327f2bc3495792a7b4f1beafecc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS tick period (in msec)  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8ff8327f2bc3495792a7b4f1beafecc9">More...</a><br /></td></tr>
<tr class="separator:ga8ff8327f2bc3495792a7b4f1beafecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30edd0f35bcc935893134cbfcf2dd005"><td class="memItemLeft" align="right" valign="top"><a id="ga30edd0f35bcc935893134cbfcf2dd005"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga30edd0f35bcc935893134cbfcf2dd005">OS_TICK_CLOCK_HZ</a>&#160;&#160;&#160;_OS_TICK_CLOCK_HZ</td></tr>
<tr class="memdesc:ga30edd0f35bcc935893134cbfcf2dd005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency (in Hz) of the source clock used for the OS timer. <br /></td></tr>
<tr class="separator:ga30edd0f35bcc935893134cbfcf2dd005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf506bff5b51e8404ab109eb2a30c2682"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf506bff5b51e8404ab109eb2a30c2682">OS_TASK_ARG_TYPE</a>&#160;&#160;&#160;_OS_TASK_ARG_TYPE</td></tr>
<tr class="memdesc:gaf506bff5b51e8404ab109eb2a30c2682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type of OS task function (i.e. OS_TASK_FUNCTION) argument.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf506bff5b51e8404ab109eb2a30c2682">More...</a><br /></td></tr>
<tr class="separator:gaf506bff5b51e8404ab109eb2a30c2682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab513d4f9267b0e69d5d4ed45a1fed038"><td class="memItemLeft" align="right" valign="top"><a id="gab513d4f9267b0e69d5d4ed45a1fed038"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab513d4f9267b0e69d5d4ed45a1fed038">OS_TASK_BEGIN</a>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="memdesc:gab513d4f9267b0e69d5d4ed45a1fed038"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS task function begin point of execution. <br /></td></tr>
<tr class="separator:gab513d4f9267b0e69d5d4ed45a1fed038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a6b6136020dc5186af2aec740d55ee"><td class="memItemLeft" align="right" valign="top"><a id="ga63a6b6136020dc5186af2aec740d55ee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga63a6b6136020dc5186af2aec740d55ee">OS_TASK_END</a>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="memdesc:ga63a6b6136020dc5186af2aec740d55ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS task function end point of execution. <br /></td></tr>
<tr class="separator:ga63a6b6136020dc5186af2aec740d55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914bc8dfdd39ca3b9caecb795ae583d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga914bc8dfdd39ca3b9caecb795ae583d7">OS_TASK_FUNCTION</a>(func,  arg)&#160;&#160;&#160;_OS_TASK_FUNCTION(func, arg)</td></tr>
<tr class="memdesc:ga914bc8dfdd39ca3b9caecb795ae583d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare an OS task function.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga914bc8dfdd39ca3b9caecb795ae583d7">More...</a><br /></td></tr>
<tr class="separator:ga914bc8dfdd39ca3b9caecb795ae583d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4dc3ac5452db5e59431f9e36d681191"><td class="memItemLeft" align="right" valign="top"><a id="gad4dc3ac5452db5e59431f9e36d681191"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gad4dc3ac5452db5e59431f9e36d681191">OS_TASK_SCHEDULER_RUN</a>()&#160;&#160;&#160;_OS_TASK_SCHEDULER_RUN()</td></tr>
<tr class="memdesc:gad4dc3ac5452db5e59431f9e36d681191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the OS task scheduler. <br /></td></tr>
<tr class="separator:gad4dc3ac5452db5e59431f9e36d681191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a68360ed332a7a45f9a44af68f56ac9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8a68360ed332a7a45f9a44af68f56ac9">OS_TIME_TO_TICKS</a>(time_in_ms)&#160;&#160;&#160;_OS_TIME_TO_TICKS(time_in_ms)</td></tr>
<tr class="memdesc:ga8a68360ed332a7a45f9a44af68f56ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a time in milliseconds to a time in ticks.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8a68360ed332a7a45f9a44af68f56ac9">More...</a><br /></td></tr>
<tr class="separator:ga8a68360ed332a7a45f9a44af68f56ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1a837adbf0d7c4cd6f4c86c5012563"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga6a1a837adbf0d7c4cd6f4c86c5012563">OS_GET_CURRENT_TASK</a>()&#160;&#160;&#160;_OS_GET_CURRENT_TASK()</td></tr>
<tr class="memdesc:ga6a1a837adbf0d7c4cd6f4c86c5012563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current OS task handle.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga6a1a837adbf0d7c4cd6f4c86c5012563">More...</a><br /></td></tr>
<tr class="separator:ga6a1a837adbf0d7c4cd6f4c86c5012563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a5564afaf810733986c2326a323be2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf2a5564afaf810733986c2326a323be2">OS_TASK_CREATE</a>(name,  task_func,  arg,  stack_size,  priority,  task)</td></tr>
<tr class="memdesc:gaf2a5564afaf810733986c2326a323be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf2a5564afaf810733986c2326a323be2">More...</a><br /></td></tr>
<tr class="separator:gaf2a5564afaf810733986c2326a323be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a73ccb253999f6d79b6985c097fb4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga24a73ccb253999f6d79b6985c097fb4e">OS_TASK_DELETE</a>(task)&#160;&#160;&#160;_OS_TASK_DELETE(task)</td></tr>
<tr class="memdesc:ga24a73ccb253999f6d79b6985c097fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga24a73ccb253999f6d79b6985c097fb4e">More...</a><br /></td></tr>
<tr class="separator:ga24a73ccb253999f6d79b6985c097fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8dafae5ca6f00ee8ce776ae1212fd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabd8dafae5ca6f00ee8ce776ae1212fd5">OS_TASK_PRIORITY_GET</a>(task)&#160;&#160;&#160;_OS_TASK_PRIORITY_GET(task)</td></tr>
<tr class="memdesc:gabd8dafae5ca6f00ee8ce776ae1212fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gabd8dafae5ca6f00ee8ce776ae1212fd5">More...</a><br /></td></tr>
<tr class="separator:gabd8dafae5ca6f00ee8ce776ae1212fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8861b855a72140a44005066c682be830"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8861b855a72140a44005066c682be830">OS_TASK_PRIORITY_GET_FROM_ISR</a>(task)&#160;&#160;&#160;_OS_TASK_PRIORITY_GET_FROM_ISR(task)</td></tr>
<tr class="memdesc:ga8861b855a72140a44005066c682be830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of an OS task from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8861b855a72140a44005066c682be830">More...</a><br /></td></tr>
<tr class="separator:ga8861b855a72140a44005066c682be830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bb1b8afdd47bf1031e94aceaf19865"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga02bb1b8afdd47bf1031e94aceaf19865">OS_TASK_PRIORITY_SET</a>(task,  prio)&#160;&#160;&#160;_OS_TASK_PRIORITY_SET((task), (prio))</td></tr>
<tr class="memdesc:ga02bb1b8afdd47bf1031e94aceaf19865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga02bb1b8afdd47bf1031e94aceaf19865">More...</a><br /></td></tr>
<tr class="separator:ga02bb1b8afdd47bf1031e94aceaf19865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b95512f360b2980c30404776efc2a21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga9b95512f360b2980c30404776efc2a21">OS_TASK_YIELD</a>()&#160;&#160;&#160;_OS_TASK_YIELD()</td></tr>
<tr class="memdesc:ga9b95512f360b2980c30404776efc2a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The running OS task yields control to the scheduler.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga9b95512f360b2980c30404776efc2a21">More...</a><br /></td></tr>
<tr class="separator:ga9b95512f360b2980c30404776efc2a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558b8294bd6f926b449e6c0343160218"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga558b8294bd6f926b449e6c0343160218">OS_TASK_YIELD_FROM_ISR</a>()&#160;&#160;&#160;_OS_TASK_YIELD_FROM_ISR()</td></tr>
<tr class="memdesc:ga558b8294bd6f926b449e6c0343160218"><td class="mdescLeft">&#160;</td><td class="mdescRight">The running OS task yields control to the scheduler from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga558b8294bd6f926b449e6c0343160218">More...</a><br /></td></tr>
<tr class="separator:ga558b8294bd6f926b449e6c0343160218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f2215f0acf1afbe553051eda1972f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga00f2215f0acf1afbe553051eda1972f2">OS_TASK_NOTIFY</a>(task,  value,  action)&#160;&#160;&#160;_OS_TASK_NOTIFY((task), (value), (action))</td></tr>
<tr class="memdesc:ga00f2215f0acf1afbe553051eda1972f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task, updating its notification value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga00f2215f0acf1afbe553051eda1972f2">More...</a><br /></td></tr>
<tr class="separator:ga00f2215f0acf1afbe553051eda1972f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86995eac646484de40bc613d650aad5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga86995eac646484de40bc613d650aad5e">OS_TASK_NOTIFY_INDEXED</a>(task,  index,  value,  action)&#160;&#160;&#160;_OS_TASK_NOTIFY_INDEXED((task), (index), (value), (action))</td></tr>
<tr class="memdesc:ga86995eac646484de40bc613d650aad5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task, updating one notification index value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga86995eac646484de40bc613d650aad5e">More...</a><br /></td></tr>
<tr class="separator:ga86995eac646484de40bc613d650aad5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5eac367a1d83149f77bf4cd28d6a93e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf5eac367a1d83149f77bf4cd28d6a93e">OS_TASK_NOTIFY_AND_QUERY</a>(task,  value,  action,  prev_value)&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY((task), (value), (action), (prev_value))</td></tr>
<tr class="memdesc:gaf5eac367a1d83149f77bf4cd28d6a93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task, updating its notification value and returning previous value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf5eac367a1d83149f77bf4cd28d6a93e">More...</a><br /></td></tr>
<tr class="separator:gaf5eac367a1d83149f77bf4cd28d6a93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d92c8db6703066f78d0cc3a83635b8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8d92c8db6703066f78d0cc3a83635b8f">OS_TASK_NOTIFY_AND_QUERY_INDEXED</a>(task,  index,  value,  action,  prev_value)&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY_INDEXED((task), (index), (value), (action), (prev_value))</td></tr>
<tr class="memdesc:ga8d92c8db6703066f78d0cc3a83635b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task, updating a notification index value and returning previous value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8d92c8db6703066f78d0cc3a83635b8f">More...</a><br /></td></tr>
<tr class="separator:ga8d92c8db6703066f78d0cc3a83635b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c0bb07f14dea53797a0a922d27dbdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga41c0bb07f14dea53797a0a922d27dbdc">OS_TASK_NOTIFY_FROM_ISR</a>(task,  value,  action)&#160;&#160;&#160;_OS_TASK_NOTIFY_FROM_ISR((task), (value), (action))</td></tr>
<tr class="memdesc:ga41c0bb07f14dea53797a0a922d27dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task from ISR, updating its notification value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga41c0bb07f14dea53797a0a922d27dbdc">More...</a><br /></td></tr>
<tr class="separator:ga41c0bb07f14dea53797a0a922d27dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7630f7b69c9971fd3a8df91f065a92d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7630f7b69c9971fd3a8df91f065a92d3">OS_TASK_NOTIFY_INDEXED_FROM_ISR</a>(task,  index,  value,  action)&#160;&#160;&#160;_OS_TASK_NOTIFY_INDEXED_FROM_ISR((task), (index), (value), (action))</td></tr>
<tr class="memdesc:ga7630f7b69c9971fd3a8df91f065a92d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task from ISR, updating a notification index value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga7630f7b69c9971fd3a8df91f065a92d3">More...</a><br /></td></tr>
<tr class="separator:ga7630f7b69c9971fd3a8df91f065a92d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd241bf5e92f687315264e75fbe6d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafcd241bf5e92f687315264e75fbe6d84">OS_TASK_NOTIFY_AND_QUERY_FROM_ISR</a>(task,  value,  action,  prev_value)&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY_FROM_ISR((task), (value), (action), (prev_value))</td></tr>
<tr class="memdesc:gafcd241bf5e92f687315264e75fbe6d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task from ISR, updating its notification value and returning previous value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gafcd241bf5e92f687315264e75fbe6d84">More...</a><br /></td></tr>
<tr class="separator:gafcd241bf5e92f687315264e75fbe6d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87cf5f0d1af9f206309244c360aba310"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga87cf5f0d1af9f206309244c360aba310">OS_TASK_NOTIFY_AND_QUERY_INDEXED_FROM_ISR</a>(task,  index,  value,  action,  prev_value)&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY_INDEXED_FROM_ISR((task), (index), (value), (action), (prev_value))</td></tr>
<tr class="memdesc:ga87cf5f0d1af9f206309244c360aba310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to OS task from ISR, updating a notification index value and returning previous value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga87cf5f0d1af9f206309244c360aba310">More...</a><br /></td></tr>
<tr class="separator:ga87cf5f0d1af9f206309244c360aba310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922cdffae7bfcabc3e3a29e2521365b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga922cdffae7bfcabc3e3a29e2521365b4">OS_TASK_NOTIFY_GIVE</a>(task)&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE(task)</td></tr>
<tr class="memdesc:ga922cdffae7bfcabc3e3a29e2521365b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a notification event to OS task, incrementing its notification value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga922cdffae7bfcabc3e3a29e2521365b4">More...</a><br /></td></tr>
<tr class="separator:ga922cdffae7bfcabc3e3a29e2521365b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f3cea689385669347d3cc0cd3be330"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga79f3cea689385669347d3cc0cd3be330">OS_TASK_NOTIFY_GIVE_INDEXED</a>(task,  index)&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE_INDEXED((task), (index))</td></tr>
<tr class="memdesc:ga79f3cea689385669347d3cc0cd3be330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a notification event to OS task, incrementing a notification index value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga79f3cea689385669347d3cc0cd3be330">More...</a><br /></td></tr>
<tr class="separator:ga79f3cea689385669347d3cc0cd3be330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073a550e64dbb4b8b4acfd9c83370775"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga073a550e64dbb4b8b4acfd9c83370775">OS_TASK_NOTIFY_GIVE_FROM_ISR</a>(task)&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE_FROM_ISR(task)</td></tr>
<tr class="memdesc:ga073a550e64dbb4b8b4acfd9c83370775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a notification event to OS task from ISR, incrementing its notification value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga073a550e64dbb4b8b4acfd9c83370775">More...</a><br /></td></tr>
<tr class="separator:ga073a550e64dbb4b8b4acfd9c83370775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb236aaa2b6d31cfb8b94b1dbf031b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1fb236aaa2b6d31cfb8b94b1dbf031b0">OS_TASK_NOTIFY_GIVE_INDEXED_FROM_ISR</a>(task,  index)&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE_INDEXED_FROM_ISR((task), (index))</td></tr>
<tr class="memdesc:ga1fb236aaa2b6d31cfb8b94b1dbf031b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a notification event to OS task from ISR, incrementing a notification index value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga1fb236aaa2b6d31cfb8b94b1dbf031b0">More...</a><br /></td></tr>
<tr class="separator:ga1fb236aaa2b6d31cfb8b94b1dbf031b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a3bb58bc89af3bb73c75bb4fa8644e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e">OS_TASK_NOTIFY_TAKE</a>(clear_on_exit,  time_to_wait)&#160;&#160;&#160;_OS_TASK_NOTIFY_TAKE((clear_on_exit), (time_to_wait))</td></tr>
<tr class="memdesc:gaf7a3bb58bc89af3bb73c75bb4fa8644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task notification value on exit.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e">More...</a><br /></td></tr>
<tr class="separator:gaf7a3bb58bc89af3bb73c75bb4fa8644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fec959f7e36be1ddec7577263ca4ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac4fec959f7e36be1ddec7577263ca4ed">OS_TASK_NOTIFY_TAKE_INDEXED</a>(index,  clear_on_exit,  time_to_wait)&#160;&#160;&#160;_OS_TASK_NOTIFY_TAKE_INDEXED((index), (clear_on_exit), (time_to_wait))</td></tr>
<tr class="memdesc:gac4fec959f7e36be1ddec7577263ca4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the calling OS task to receive a notification event, clearing to zero or decrementing a task notification index value on exit.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gac4fec959f7e36be1ddec7577263ca4ed">More...</a><br /></td></tr>
<tr class="separator:gac4fec959f7e36be1ddec7577263ca4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a86269604f9ac15d5330e831bec448"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae0a86269604f9ac15d5330e831bec448">OS_TASK_NOTIFY_STATE_CLEAR</a>(task)&#160;&#160;&#160;_OS_TASK_NOTIFY_STATE_CLEAR(task)</td></tr>
<tr class="memdesc:gae0a86269604f9ac15d5330e831bec448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the notification state of an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gae0a86269604f9ac15d5330e831bec448">More...</a><br /></td></tr>
<tr class="separator:gae0a86269604f9ac15d5330e831bec448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c972de35e501963cd037ae79f80770"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga06c972de35e501963cd037ae79f80770">OS_TASK_NOTIFY_STATE_CLEAR_INDEXED</a>(task,  index)&#160;&#160;&#160;_OS_TASK_NOTIFY_STATE_CLEAR_INDEXED((task), (index))</td></tr>
<tr class="memdesc:ga06c972de35e501963cd037ae79f80770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a notification index state of an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga06c972de35e501963cd037ae79f80770">More...</a><br /></td></tr>
<tr class="separator:ga06c972de35e501963cd037ae79f80770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10720bf3b19b56bee2ba64a26e386d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa10720bf3b19b56bee2ba64a26e386d2">OS_TASK_NOTIFY_VALUE_CLEAR</a>(task,  bits_to_clear)&#160;&#160;&#160;_OS_TASK_NOTIFY_VALUE_CLEAR((task), (bits_to_clear))</td></tr>
<tr class="memdesc:gaa10720bf3b19b56bee2ba64a26e386d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear specific bits in the notification state of an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa10720bf3b19b56bee2ba64a26e386d2">More...</a><br /></td></tr>
<tr class="separator:gaa10720bf3b19b56bee2ba64a26e386d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79db09862be1de33b88733b7cc3fac71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga79db09862be1de33b88733b7cc3fac71">OS_TASK_NOTIFY_VALUE_CLEAR_INDEXED</a>(task,  index,  bits_to_clear)&#160;&#160;&#160;_OS_TASK_NOTIFY_VALUE_CLEAR_INDEXED((task), (index), (bits_to_clear))</td></tr>
<tr class="memdesc:ga79db09862be1de33b88733b7cc3fac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear specific bits in a notification index state of an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga79db09862be1de33b88733b7cc3fac71">More...</a><br /></td></tr>
<tr class="separator:ga79db09862be1de33b88733b7cc3fac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdd8702f6b22611d3cc340602a427d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafbdd8702f6b22611d3cc340602a427d8">OS_TASK_NOTIFY_WAIT</a>(entry_bits,  exit_bits,  value,  ticks_to_wait)&#160;&#160;&#160;_OS_TASK_NOTIFY_WAIT((entry_bits), (exit_bits), (value), (ticks_to_wait))</td></tr>
<tr class="memdesc:gafbdd8702f6b22611d3cc340602a427d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the calling OS task to receive a notification, updating task notification value on exit.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gafbdd8702f6b22611d3cc340602a427d8">More...</a><br /></td></tr>
<tr class="separator:gafbdd8702f6b22611d3cc340602a427d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd8c032f28cf08f205094e692b9b80c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafbd8c032f28cf08f205094e692b9b80c">OS_TASK_NOTIFY_WAIT_INDEXED</a>(index,  entry_bits,  exit_bits,  value,  ticks_to_wait)&#160;&#160;&#160;_OS_TASK_NOTIFY_WAIT_INDEXED((index), (entry_bits), (exit_bits), (value), (ticks_to_wait))</td></tr>
<tr class="memdesc:gafbd8c032f28cf08f205094e692b9b80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the calling OS task to receive a notification, updating a task notification index value on exit.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gafbd8c032f28cf08f205094e692b9b80c">More...</a><br /></td></tr>
<tr class="separator:gafbd8c032f28cf08f205094e692b9b80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00c9c3498aa76bf2a427f415a2ef5fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac00c9c3498aa76bf2a427f415a2ef5fa">OS_TASK_RESUME</a>(task)&#160;&#160;&#160;_OS_TASK_RESUME(task)</td></tr>
<tr class="memdesc:gac00c9c3498aa76bf2a427f415a2ef5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gac00c9c3498aa76bf2a427f415a2ef5fa">More...</a><br /></td></tr>
<tr class="separator:gac00c9c3498aa76bf2a427f415a2ef5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4dfac299a63b8d1205d72d7268370b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2a4dfac299a63b8d1205d72d7268370b">OS_TASK_RESUME_FROM_ISR</a>(task)&#160;&#160;&#160;_OS_TASK_RESUME_FROM_ISR(task)</td></tr>
<tr class="memdesc:ga2a4dfac299a63b8d1205d72d7268370b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume OS task from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga2a4dfac299a63b8d1205d72d7268370b">More...</a><br /></td></tr>
<tr class="separator:ga2a4dfac299a63b8d1205d72d7268370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84368282a0e802f529f1423988725fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa84368282a0e802f529f1423988725fe">OS_TASK_SUSPEND</a>(task)&#160;&#160;&#160;_OS_TASK_SUSPEND(task)</td></tr>
<tr class="memdesc:gaa84368282a0e802f529f1423988725fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa84368282a0e802f529f1423988725fe">More...</a><br /></td></tr>
<tr class="separator:gaa84368282a0e802f529f1423988725fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112a446b2367e0a86ea65e17b7b001ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga112a446b2367e0a86ea65e17b7b001ea">OS_MUTEX_CREATE</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_CREATE(mutex)</td></tr>
<tr class="memdesc:ga112a446b2367e0a86ea65e17b7b001ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS mutex.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga112a446b2367e0a86ea65e17b7b001ea">More...</a><br /></td></tr>
<tr class="separator:ga112a446b2367e0a86ea65e17b7b001ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbc523417b45470fffc0c5b009361b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fbc523417b45470fffc0c5b009361b7">OS_MUTEX_DELETE</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_DELETE(mutex)</td></tr>
<tr class="memdesc:ga7fbc523417b45470fffc0c5b009361b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS mutex.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fbc523417b45470fffc0c5b009361b7">More...</a><br /></td></tr>
<tr class="separator:ga7fbc523417b45470fffc0c5b009361b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f4dfba771ddb5c78b2e9cad9516258"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga28f4dfba771ddb5c78b2e9cad9516258">OS_MUTEX_PUT</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_PUT(mutex)</td></tr>
<tr class="memdesc:ga28f4dfba771ddb5c78b2e9cad9516258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release OS mutex.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga28f4dfba771ddb5c78b2e9cad9516258">More...</a><br /></td></tr>
<tr class="separator:ga28f4dfba771ddb5c78b2e9cad9516258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103665ce82345a6d67cf3b1b68fbcaaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga103665ce82345a6d67cf3b1b68fbcaaa">OS_MUTEX_GET</a>(mutex,  timeout)&#160;&#160;&#160;_OS_MUTEX_GET((mutex), (timeout))</td></tr>
<tr class="memdesc:ga103665ce82345a6d67cf3b1b68fbcaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire OS mutex.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga103665ce82345a6d67cf3b1b68fbcaaa">More...</a><br /></td></tr>
<tr class="separator:ga103665ce82345a6d67cf3b1b68fbcaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4324b015038dbaf8fcbdb1397633b516"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4324b015038dbaf8fcbdb1397633b516">OS_MUTEX_GET_OWNER</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_GET_OWNER(mutex)</td></tr>
<tr class="memdesc:ga4324b015038dbaf8fcbdb1397633b516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task owner of OS mutex.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga4324b015038dbaf8fcbdb1397633b516">More...</a><br /></td></tr>
<tr class="separator:ga4324b015038dbaf8fcbdb1397633b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd80ffd9b133985609826b40806571e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3cd80ffd9b133985609826b40806571e">OS_MUTEX_GET_OWNER_FROM_ISR</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_GET_OWNER_FROM_ISR(mutex)</td></tr>
<tr class="memdesc:ga3cd80ffd9b133985609826b40806571e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task owner of OS mutex from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3cd80ffd9b133985609826b40806571e">More...</a><br /></td></tr>
<tr class="separator:ga3cd80ffd9b133985609826b40806571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394961eb4773a92e659031b39cb357bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga394961eb4773a92e659031b39cb357bc">OS_MUTEX_GET_COUNT</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_GET_COUNT(mutex)</td></tr>
<tr class="memdesc:ga394961eb4773a92e659031b39cb357bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS mutex current count value.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga394961eb4773a92e659031b39cb357bc">More...</a><br /></td></tr>
<tr class="separator:ga394961eb4773a92e659031b39cb357bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d86269cdcaac3f6df08af7292849ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga20d86269cdcaac3f6df08af7292849ef">OS_MUTEX_GET_COUNT_FROM_ISR</a>(mutex)&#160;&#160;&#160;_OS_MUTEX_GET_COUNT_FROM_ISR(mutex)</td></tr>
<tr class="memdesc:ga20d86269cdcaac3f6df08af7292849ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS mutex current count value from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga20d86269cdcaac3f6df08af7292849ef">More...</a><br /></td></tr>
<tr class="separator:ga20d86269cdcaac3f6df08af7292849ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09506ad35a4182108374f79d60c7b054"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga09506ad35a4182108374f79d60c7b054">OS_EVENT_CREATE</a>(event)&#160;&#160;&#160;_OS_EVENT_CREATE(event)</td></tr>
<tr class="memdesc:ga09506ad35a4182108374f79d60c7b054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS event.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga09506ad35a4182108374f79d60c7b054">More...</a><br /></td></tr>
<tr class="separator:ga09506ad35a4182108374f79d60c7b054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c77555a99448ebe9cd25bd390f92d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab1c77555a99448ebe9cd25bd390f92d3">OS_EVENT_DELETE</a>(event)&#160;&#160;&#160;_OS_EVENT_DELETE(event)</td></tr>
<tr class="memdesc:gab1c77555a99448ebe9cd25bd390f92d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS event.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab1c77555a99448ebe9cd25bd390f92d3">More...</a><br /></td></tr>
<tr class="separator:gab1c77555a99448ebe9cd25bd390f92d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060073d02b4e7fb6b0a5ec588b6b98d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga060073d02b4e7fb6b0a5ec588b6b98d1">OS_EVENT_SIGNAL</a>(event)&#160;&#160;&#160;_OS_EVENT_SIGNAL(event)</td></tr>
<tr class="memdesc:ga060073d02b4e7fb6b0a5ec588b6b98d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OS event in signaled state.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga060073d02b4e7fb6b0a5ec588b6b98d1">More...</a><br /></td></tr>
<tr class="separator:ga060073d02b4e7fb6b0a5ec588b6b98d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8de4397bbf225a92c1105a5dadb3ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1d8de4397bbf225a92c1105a5dadb3ba">OS_EVENT_SIGNAL_FROM_ISR</a>(event)&#160;&#160;&#160;_OS_EVENT_SIGNAL_FROM_ISR(event)</td></tr>
<tr class="memdesc:ga1d8de4397bbf225a92c1105a5dadb3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OS event in signaled state from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga1d8de4397bbf225a92c1105a5dadb3ba">More...</a><br /></td></tr>
<tr class="separator:ga1d8de4397bbf225a92c1105a5dadb3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c9fd1f93ce06f44c50fca2abedd4907"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8c9fd1f93ce06f44c50fca2abedd4907">OS_EVENT_SIGNAL_FROM_ISR_NO_YIELD</a>(event,  need_yield)&#160;&#160;&#160;_OS_EVENT_SIGNAL_FROM_ISR_NO_YIELD((event), (need_yield))</td></tr>
<tr class="memdesc:ga8c9fd1f93ce06f44c50fca2abedd4907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OS event in signaled state from ISR without requesting running OS task to yield.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8c9fd1f93ce06f44c50fca2abedd4907">More...</a><br /></td></tr>
<tr class="separator:ga8c9fd1f93ce06f44c50fca2abedd4907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb1d31b30a33ccfbfed4cebabf6990a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a">OS_EVENT_WAIT</a>(event,  timeout)&#160;&#160;&#160;_OS_EVENT_WAIT((event), (timeout))</td></tr>
<tr class="memdesc:ga7fb1d31b30a33ccfbfed4cebabf6990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for OS event to be signaled.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a">More...</a><br /></td></tr>
<tr class="separator:ga7fb1d31b30a33ccfbfed4cebabf6990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c99697a636be93943260708124dd0e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3c99697a636be93943260708124dd0e7">OS_EVENT_CHECK</a>(event)&#160;&#160;&#160;_OS_EVENT_CHECK(event)</td></tr>
<tr class="memdesc:ga3c99697a636be93943260708124dd0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if OS event is signaled and clear it.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3c99697a636be93943260708124dd0e7">More...</a><br /></td></tr>
<tr class="separator:ga3c99697a636be93943260708124dd0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80375029118643dcd0d5635fed8a33de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga80375029118643dcd0d5635fed8a33de">OS_EVENT_CHECK_FROM_ISR</a>(event)&#160;&#160;&#160;_OS_EVENT_CHECK_FROM_ISR(event)</td></tr>
<tr class="memdesc:ga80375029118643dcd0d5635fed8a33de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check from ISR if OS event is signaled and clear it.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga80375029118643dcd0d5635fed8a33de">More...</a><br /></td></tr>
<tr class="separator:ga80375029118643dcd0d5635fed8a33de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e592d9acd648ce6b74f3ebc83a65e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga60e592d9acd648ce6b74f3ebc83a65e4">OS_EVENT_CHECK_FROM_ISR_NO_YIELD</a>(event,  need_yield)&#160;&#160;&#160;_OS_EVENT_CHECK_FROM_ISR_NO_YIELD((event), (need_yield))</td></tr>
<tr class="memdesc:ga60e592d9acd648ce6b74f3ebc83a65e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check from ISR if OS event is signaled and clear it, without requesting running OS task to yield.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga60e592d9acd648ce6b74f3ebc83a65e4">More...</a><br /></td></tr>
<tr class="separator:ga60e592d9acd648ce6b74f3ebc83a65e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa4609f7826824176ccf3284a0679c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0aa4609f7826824176ccf3284a0679c3">OS_EVENT_GET_STATUS</a>(event)&#160;&#160;&#160;_OS_EVENT_GET_STATUS(event)</td></tr>
<tr class="memdesc:ga0aa4609f7826824176ccf3284a0679c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS event status.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga0aa4609f7826824176ccf3284a0679c3">More...</a><br /></td></tr>
<tr class="separator:ga0aa4609f7826824176ccf3284a0679c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf57b36c0e104710a5dbd1238fca9b654"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf57b36c0e104710a5dbd1238fca9b654">OS_EVENT_GET_STATUS_FROM_ISR</a>(event)&#160;&#160;&#160;_OS_EVENT_GET_STATUS_FROM_ISR(event)</td></tr>
<tr class="memdesc:gaf57b36c0e104710a5dbd1238fca9b654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS event status from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf57b36c0e104710a5dbd1238fca9b654">More...</a><br /></td></tr>
<tr class="separator:gaf57b36c0e104710a5dbd1238fca9b654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be2de0540f21bc4b6b909fa672fb325"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7be2de0540f21bc4b6b909fa672fb325">OS_EVENT_YIELD</a>(higherPriorityTaskWoken)</td></tr>
<tr class="memdesc:ga7be2de0540f21bc4b6b909fa672fb325"><td class="mdescLeft">&#160;</td><td class="mdescRight">The running OS task yields control to the scheduler from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga7be2de0540f21bc4b6b909fa672fb325">More...</a><br /></td></tr>
<tr class="separator:ga7be2de0540f21bc4b6b909fa672fb325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e58ad0b5bae1e7bb80c7114716f3d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga88e58ad0b5bae1e7bb80c7114716f3d9">OS_EVENT_GROUP_CREATE</a>()&#160;&#160;&#160;_OS_EVENT_GROUP_CREATE()</td></tr>
<tr class="memdesc:ga88e58ad0b5bae1e7bb80c7114716f3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS event group.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga88e58ad0b5bae1e7bb80c7114716f3d9">More...</a><br /></td></tr>
<tr class="separator:ga88e58ad0b5bae1e7bb80c7114716f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bda5fac5b0e69c42c1c8385cd0108a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9">OS_EVENT_GROUP_WAIT_BITS</a>(event_group,  bits_to_wait,  clear_on_exit,  wait_for_all,  timeout)</td></tr>
<tr class="memdesc:ga3bda5fac5b0e69c42c1c8385cd0108a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for OS event group bits to become set.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9">More...</a><br /></td></tr>
<tr class="separator:ga3bda5fac5b0e69c42c1c8385cd0108a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3327457eefae5c693ae54145f1adeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaba3327457eefae5c693ae54145f1adeb">OS_EVENT_GROUP_SET_BITS</a>(event_group,  bits_to_set)&#160;&#160;&#160;_OS_EVENT_GROUP_SET_BITS((event_group), (bits_to_set))</td></tr>
<tr class="memdesc:gaba3327457eefae5c693ae54145f1adeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OS event group bits.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaba3327457eefae5c693ae54145f1adeb">More...</a><br /></td></tr>
<tr class="separator:gaba3327457eefae5c693ae54145f1adeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8714ef11e52d2057eb1629447209071e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8714ef11e52d2057eb1629447209071e">OS_EVENT_GROUP_SET_BITS_FROM_ISR</a>(event_group,  bits_to_set)&#160;&#160;&#160;_OS_EVENT_GROUP_SET_BITS_FROM_ISR((event_group), (bits_to_set))</td></tr>
<tr class="memdesc:ga8714ef11e52d2057eb1629447209071e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OS event group bits from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8714ef11e52d2057eb1629447209071e">More...</a><br /></td></tr>
<tr class="separator:ga8714ef11e52d2057eb1629447209071e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89995858cb14c88779a865f24e52c8e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga89995858cb14c88779a865f24e52c8e5">OS_EVENT_GROUP_SET_BITS_FROM_ISR_NO_YIELD</a>(event_group,  bits_to_set,  need_yield)&#160;&#160;&#160;_OS_EVENT_GROUP_SET_BITS_FROM_ISR_NO_YIELD((event_group), (bits_to_set), (need_yield))</td></tr>
<tr class="memdesc:ga89995858cb14c88779a865f24e52c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OS event group bits from ISR without requesting running OS task to yield.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga89995858cb14c88779a865f24e52c8e5">More...</a><br /></td></tr>
<tr class="separator:ga89995858cb14c88779a865f24e52c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e637dbf5ba23f88d74ea93dafdbe42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga46e637dbf5ba23f88d74ea93dafdbe42">OS_EVENT_GROUP_CLEAR_BITS</a>(event_group,  bits_to_clear)&#160;&#160;&#160;_OS_EVENT_GROUP_CLEAR_BITS((event_group), (bits_to_clear))</td></tr>
<tr class="memdesc:ga46e637dbf5ba23f88d74ea93dafdbe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear OS event group bits.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga46e637dbf5ba23f88d74ea93dafdbe42">More...</a><br /></td></tr>
<tr class="separator:ga46e637dbf5ba23f88d74ea93dafdbe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28c2d7842c556a29e3ce9fb68c20e36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae28c2d7842c556a29e3ce9fb68c20e36">OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR</a>(event_group,  bits_to_clear)&#160;&#160;&#160;_OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR((event_group), (bits_to_clear))</td></tr>
<tr class="memdesc:gae28c2d7842c556a29e3ce9fb68c20e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear OS event group bits from an interrupt.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gae28c2d7842c556a29e3ce9fb68c20e36">More...</a><br /></td></tr>
<tr class="separator:gae28c2d7842c556a29e3ce9fb68c20e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc34f47f4c851ffcba18917feafa2422"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabc34f47f4c851ffcba18917feafa2422">OS_EVENT_GROUP_GET_BITS</a>(event_group)&#160;&#160;&#160;_OS_EVENT_GROUP_GET_BITS(event_group)</td></tr>
<tr class="memdesc:gabc34f47f4c851ffcba18917feafa2422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS event group bits.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gabc34f47f4c851ffcba18917feafa2422">More...</a><br /></td></tr>
<tr class="separator:gabc34f47f4c851ffcba18917feafa2422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac289748c5e1f388342c1ae54012b806"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaac289748c5e1f388342c1ae54012b806">OS_EVENT_GROUP_GET_BITS_FROM_ISR</a>(event_group)&#160;&#160;&#160;_OS_EVENT_GROUP_GET_BITS_FROM_ISR(event_group)</td></tr>
<tr class="memdesc:gaac289748c5e1f388342c1ae54012b806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS event group bits from an interrupt.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaac289748c5e1f388342c1ae54012b806">More...</a><br /></td></tr>
<tr class="separator:gaac289748c5e1f388342c1ae54012b806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94f4416bf0ac7e69f7b1cef77822dfa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa94f4416bf0ac7e69f7b1cef77822dfa">OS_EVENT_GROUP_SYNC</a>(event_group,  bits_to_set,  bits_to_wait,  timeout)&#160;&#160;&#160;_OS_EVENT_GROUP_SYNC((event_group), (bits_to_set), (bits_to_wait), (timeout))</td></tr>
<tr class="memdesc:gaa94f4416bf0ac7e69f7b1cef77822dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize OS event group bits.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa94f4416bf0ac7e69f7b1cef77822dfa">More...</a><br /></td></tr>
<tr class="separator:gaa94f4416bf0ac7e69f7b1cef77822dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ad6b96a7fb19908798426b67779291"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae3ad6b96a7fb19908798426b67779291">OS_EVENT_GROUP_DELETE</a>(event_group)&#160;&#160;&#160;_OS_EVENT_GROUP_DELETE(event_group)</td></tr>
<tr class="memdesc:gae3ad6b96a7fb19908798426b67779291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS event group.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gae3ad6b96a7fb19908798426b67779291">More...</a><br /></td></tr>
<tr class="separator:gae3ad6b96a7fb19908798426b67779291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8b7bdb6581ede712d825f092ad00ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabc8b7bdb6581ede712d825f092ad00ea">OS_QUEUE_CREATE</a>(queue,  item_size,  max_items)&#160;&#160;&#160;_OS_QUEUE_CREATE((queue), (item_size), (max_items))</td></tr>
<tr class="memdesc:gabc8b7bdb6581ede712d825f092ad00ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gabc8b7bdb6581ede712d825f092ad00ea">More...</a><br /></td></tr>
<tr class="separator:gabc8b7bdb6581ede712d825f092ad00ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4125555127d460161078ddd93b4925"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaab4125555127d460161078ddd93b4925">OS_QUEUE_DELETE</a>(queue)&#160;&#160;&#160;_OS_QUEUE_DELETE(queue)</td></tr>
<tr class="memdesc:gaab4125555127d460161078ddd93b4925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaab4125555127d460161078ddd93b4925">More...</a><br /></td></tr>
<tr class="separator:gaab4125555127d460161078ddd93b4925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28eb0095f405f4a77b70afcb798b6fcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga28eb0095f405f4a77b70afcb798b6fcd">OS_QUEUE_PUT</a>(queue,  item,  timeout)&#160;&#160;&#160;_OS_QUEUE_PUT((queue), (item), (timeout))</td></tr>
<tr class="memdesc:ga28eb0095f405f4a77b70afcb798b6fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put element in OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga28eb0095f405f4a77b70afcb798b6fcd">More...</a><br /></td></tr>
<tr class="separator:ga28eb0095f405f4a77b70afcb798b6fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee5f52a66b92c1ee3500a92afb3ea2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gadee5f52a66b92c1ee3500a92afb3ea2b">OS_QUEUE_PUT_FROM_ISR</a>(queue,  item)&#160;&#160;&#160;_OS_QUEUE_PUT_FROM_ISR((queue), (item))</td></tr>
<tr class="memdesc:gadee5f52a66b92c1ee3500a92afb3ea2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put element in OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gadee5f52a66b92c1ee3500a92afb3ea2b">More...</a><br /></td></tr>
<tr class="separator:gadee5f52a66b92c1ee3500a92afb3ea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa001111f406c95c559ecbdcbf8be9b17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa001111f406c95c559ecbdcbf8be9b17">OS_QUEUE_REPLACE</a>(queue,  item)&#160;&#160;&#160;_OS_QUEUE_REPLACE((queue), (item))</td></tr>
<tr class="memdesc:gaa001111f406c95c559ecbdcbf8be9b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace element in OS queue of one element.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa001111f406c95c559ecbdcbf8be9b17">More...</a><br /></td></tr>
<tr class="separator:gaa001111f406c95c559ecbdcbf8be9b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7fb5e46bc81cadcd80fae41ad9b52f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8e7fb5e46bc81cadcd80fae41ad9b52f">OS_QUEUE_REPLACE_FROM_ISR</a>(queue,  item)&#160;&#160;&#160;_OS_QUEUE_REPLACE_FROM_ISR((queue), (item))</td></tr>
<tr class="memdesc:ga8e7fb5e46bc81cadcd80fae41ad9b52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace element in OS queue of one element from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8e7fb5e46bc81cadcd80fae41ad9b52f">More...</a><br /></td></tr>
<tr class="separator:ga8e7fb5e46bc81cadcd80fae41ad9b52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35c66dc5b578e61df935d4fcc770836"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa35c66dc5b578e61df935d4fcc770836">OS_QUEUE_REPLACE_FROM_ISR_NO_YIELD</a>(queue,  item,  need_yield)&#160;&#160;&#160;_OS_QUEUE_REPLACE_FROM_ISR_NO_YIELD((queue), (item), (need_yield))</td></tr>
<tr class="memdesc:gaa35c66dc5b578e61df935d4fcc770836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace element in OS queue of one element from ISR without requesting running OS task to yield.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa35c66dc5b578e61df935d4fcc770836">More...</a><br /></td></tr>
<tr class="separator:gaa35c66dc5b578e61df935d4fcc770836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga734ae4efa9b0f0648e46d68b39ae9639"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga734ae4efa9b0f0648e46d68b39ae9639">OS_QUEUE_GET</a>(queue,  item,  timeout)&#160;&#160;&#160;_OS_QUEUE_GET((queue), (item), (timeout))</td></tr>
<tr class="memdesc:ga734ae4efa9b0f0648e46d68b39ae9639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element from OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga734ae4efa9b0f0648e46d68b39ae9639">More...</a><br /></td></tr>
<tr class="separator:ga734ae4efa9b0f0648e46d68b39ae9639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32ec2dfb3ed339dee4a6ddde7abc9b78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga32ec2dfb3ed339dee4a6ddde7abc9b78">OS_QUEUE_GET_FROM_ISR</a>(queue,  item)&#160;&#160;&#160;_OS_QUEUE_GET_FROM_ISR((queue), (item))</td></tr>
<tr class="memdesc:ga32ec2dfb3ed339dee4a6ddde7abc9b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element from OS queue from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga32ec2dfb3ed339dee4a6ddde7abc9b78">More...</a><br /></td></tr>
<tr class="separator:ga32ec2dfb3ed339dee4a6ddde7abc9b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ba9e71bc082e604b2dc4c3427b9a97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga42ba9e71bc082e604b2dc4c3427b9a97">OS_QUEUE_GET_FROM_ISR_NO_YIELD</a>(queue,  item,  need_yield)&#160;&#160;&#160;_OS_QUEUE_GET_FROM_ISR_NO_YIELD((queue), (item), (need_yield))</td></tr>
<tr class="memdesc:ga42ba9e71bc082e604b2dc4c3427b9a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element from OS queue from ISR without requesting running OS task to yield.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga42ba9e71bc082e604b2dc4c3427b9a97">More...</a><br /></td></tr>
<tr class="separator:ga42ba9e71bc082e604b2dc4c3427b9a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1631dad9eb268f390e158cff9036ea3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab1631dad9eb268f390e158cff9036ea3">OS_QUEUE_PEEK</a>(queue,  item,  timeout)&#160;&#160;&#160;_OS_QUEUE_PEEK((queue), (item), (timeout))</td></tr>
<tr class="memdesc:gab1631dad9eb268f390e158cff9036ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek element from OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab1631dad9eb268f390e158cff9036ea3">More...</a><br /></td></tr>
<tr class="separator:gab1631dad9eb268f390e158cff9036ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0429cf73ac5731e7098876af50c61abf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0429cf73ac5731e7098876af50c61abf">OS_QUEUE_PEEK_FROM_ISR</a>(queue,  item)&#160;&#160;&#160;_OS_QUEUE_PEEK_FROM_ISR((queue), (item))</td></tr>
<tr class="memdesc:ga0429cf73ac5731e7098876af50c61abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek element from OS queue from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga0429cf73ac5731e7098876af50c61abf">More...</a><br /></td></tr>
<tr class="separator:ga0429cf73ac5731e7098876af50c61abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafe3e9f66d7afc396337a95b55eea8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gacafe3e9f66d7afc396337a95b55eea8b">OS_QUEUE_MESSAGES_WAITING</a>(queue)&#160;&#160;&#160;_OS_QUEUE_MESSAGES_WAITING(queue)</td></tr>
<tr class="memdesc:gacafe3e9f66d7afc396337a95b55eea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of messages stored in OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gacafe3e9f66d7afc396337a95b55eea8b">More...</a><br /></td></tr>
<tr class="separator:gacafe3e9f66d7afc396337a95b55eea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b257cb9c9c1930e985cd16d24f93e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga88b257cb9c9c1930e985cd16d24f93e3">OS_QUEUE_MESSAGES_WAITING_FROM_ISR</a>(queue)&#160;&#160;&#160;_OS_QUEUE_MESSAGES_WAITING_FROM_ISR(queue)</td></tr>
<tr class="memdesc:ga88b257cb9c9c1930e985cd16d24f93e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of messages stored in OS queue from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga88b257cb9c9c1930e985cd16d24f93e3">More...</a><br /></td></tr>
<tr class="separator:ga88b257cb9c9c1930e985cd16d24f93e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d8088ae8c9f2ead6cda61d5ca0d9bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga84d8088ae8c9f2ead6cda61d5ca0d9bd">OS_QUEUE_SPACES_AVAILABLE</a>(queue)&#160;&#160;&#160;_OS_QUEUE_SPACES_AVAILABLE(queue)</td></tr>
<tr class="memdesc:ga84d8088ae8c9f2ead6cda61d5ca0d9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of free spaces in OS queue.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga84d8088ae8c9f2ead6cda61d5ca0d9bd">More...</a><br /></td></tr>
<tr class="separator:ga84d8088ae8c9f2ead6cda61d5ca0d9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ddcaa3765d3322f6c1a5e48c102c61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61">OS_TIMER_CREATE</a>(name,  period,  reload,  timer_id,  callback)&#160;&#160;&#160;_OS_TIMER_CREATE((name), (period), (reload), (timer_id), (callback))</td></tr>
<tr class="memdesc:gab3ddcaa3765d3322f6c1a5e48c102c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS timer.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61">More...</a><br /></td></tr>
<tr class="separator:gab3ddcaa3765d3322f6c1a5e48c102c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829f2c08546706de27d74f3d94991e32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga829f2c08546706de27d74f3d94991e32">OS_TIMER_GET_TIMER_ID</a>(timer)&#160;&#160;&#160;_OS_TIMER_GET_TIMER_ID(timer)</td></tr>
<tr class="memdesc:ga829f2c08546706de27d74f3d94991e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS timer ID.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga829f2c08546706de27d74f3d94991e32">More...</a><br /></td></tr>
<tr class="separator:ga829f2c08546706de27d74f3d94991e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1566ca04ff8d3c2656777803f54f4d4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1566ca04ff8d3c2656777803f54f4d4f">OS_TIMER_IS_ACTIVE</a>(timer)&#160;&#160;&#160;_OS_TIMER_IS_ACTIVE(timer)</td></tr>
<tr class="memdesc:ga1566ca04ff8d3c2656777803f54f4d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if OS timer is active.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga1566ca04ff8d3c2656777803f54f4d4f">More...</a><br /></td></tr>
<tr class="separator:ga1566ca04ff8d3c2656777803f54f4d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8867349519f1d3d49e90dc71946d2b24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8867349519f1d3d49e90dc71946d2b24">OS_TIMER_START</a>(timer,  timeout)&#160;&#160;&#160;_OS_TIMER_START((timer), (timeout))</td></tr>
<tr class="memdesc:ga8867349519f1d3d49e90dc71946d2b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start OS timer.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8867349519f1d3d49e90dc71946d2b24">More...</a><br /></td></tr>
<tr class="separator:ga8867349519f1d3d49e90dc71946d2b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa365dd8088897672c6831793ab257532"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa365dd8088897672c6831793ab257532">OS_TIMER_STOP</a>(timer,  timeout)&#160;&#160;&#160;_OS_TIMER_STOP((timer), (timeout))</td></tr>
<tr class="memdesc:gaa365dd8088897672c6831793ab257532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop OS timer.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa365dd8088897672c6831793ab257532">More...</a><br /></td></tr>
<tr class="separator:gaa365dd8088897672c6831793ab257532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05137e07905384715f65f14a93e0c23e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga05137e07905384715f65f14a93e0c23e">OS_TIMER_CHANGE_PERIOD</a>(timer,  period,  timeout)&#160;&#160;&#160;_OS_TIMER_CHANGE_PERIOD((timer), (period), (timeout))</td></tr>
<tr class="memdesc:ga05137e07905384715f65f14a93e0c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change OS timer's period.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga05137e07905384715f65f14a93e0c23e">More...</a><br /></td></tr>
<tr class="separator:ga05137e07905384715f65f14a93e0c23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f2d4705593ca121a18eba61bb4523f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga51f2d4705593ca121a18eba61bb4523f">OS_TIMER_DELETE</a>(timer,  timeout)&#160;&#160;&#160;_OS_TIMER_DELETE((timer), (timeout))</td></tr>
<tr class="memdesc:ga51f2d4705593ca121a18eba61bb4523f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS timer.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga51f2d4705593ca121a18eba61bb4523f">More...</a><br /></td></tr>
<tr class="separator:ga51f2d4705593ca121a18eba61bb4523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62357077a12d85bed42f15b88e8c772"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772">OS_TIMER_RESET</a>(timer,  timeout)&#160;&#160;&#160;_OS_TIMER_RESET((timer), (timeout))</td></tr>
<tr class="memdesc:gaf62357077a12d85bed42f15b88e8c772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset OS timer.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772">More...</a><br /></td></tr>
<tr class="separator:gaf62357077a12d85bed42f15b88e8c772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fac74ca16c0a48fd92fecc0d414a1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga06fac74ca16c0a48fd92fecc0d414a1e">OS_TIMER_START_FROM_ISR</a>(timer)&#160;&#160;&#160;_OS_TIMER_START_FROM_ISR(timer)</td></tr>
<tr class="memdesc:ga06fac74ca16c0a48fd92fecc0d414a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start OS timer from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga06fac74ca16c0a48fd92fecc0d414a1e">More...</a><br /></td></tr>
<tr class="separator:ga06fac74ca16c0a48fd92fecc0d414a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5b4d5fff2947d1806559243e9fcdde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaca5b4d5fff2947d1806559243e9fcdde">OS_TIMER_STOP_FROM_ISR</a>(timer)&#160;&#160;&#160;_OS_TIMER_STOP_FROM_ISR(timer)</td></tr>
<tr class="memdesc:gaca5b4d5fff2947d1806559243e9fcdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop OS timer from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaca5b4d5fff2947d1806559243e9fcdde">More...</a><br /></td></tr>
<tr class="separator:gaca5b4d5fff2947d1806559243e9fcdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3c97a73258c9df80b82bbedaaf76b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafc3c97a73258c9df80b82bbedaaf76b4">OS_TIMER_CHANGE_PERIOD_FROM_ISR</a>(timer,  period)&#160;&#160;&#160;_OS_TIMER_CHANGE_PERIOD_FROM_ISR((timer), (period))</td></tr>
<tr class="memdesc:gafc3c97a73258c9df80b82bbedaaf76b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change OS timer period from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gafc3c97a73258c9df80b82bbedaaf76b4">More...</a><br /></td></tr>
<tr class="separator:gafc3c97a73258c9df80b82bbedaaf76b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435ecbfcbe8996f34ac2e237512c1269"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga435ecbfcbe8996f34ac2e237512c1269">OS_TIMER_RESET_FROM_ISR</a>(timer)&#160;&#160;&#160;_OS_TIMER_RESET_FROM_ISR(timer)</td></tr>
<tr class="memdesc:ga435ecbfcbe8996f34ac2e237512c1269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset OS timer from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga435ecbfcbe8996f34ac2e237512c1269">More...</a><br /></td></tr>
<tr class="separator:ga435ecbfcbe8996f34ac2e237512c1269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861400a2111b9d2f80fe2a443abafef8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga861400a2111b9d2f80fe2a443abafef8">OS_TIMER_SET_RELOAD_MODE</a>(timer,  auto_reload)&#160;&#160;&#160;_OS_TIMER_SET_RELOAD_MODE(timer, auto_reload)</td></tr>
<tr class="memdesc:ga861400a2111b9d2f80fe2a443abafef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timer auto-reload mode.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga861400a2111b9d2f80fe2a443abafef8">More...</a><br /></td></tr>
<tr class="separator:ga861400a2111b9d2f80fe2a443abafef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68906a872a118cdf7e134eaca42fbbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab68906a872a118cdf7e134eaca42fbbf">OS_TIMER_GET_RELOAD_MODE</a>(timer)&#160;&#160;&#160;_OS_TIMER_GET_RELOAD_MODE(timer)</td></tr>
<tr class="memdesc:gab68906a872a118cdf7e134eaca42fbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timer auto-reload mode.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab68906a872a118cdf7e134eaca42fbbf">More...</a><br /></td></tr>
<tr class="separator:gab68906a872a118cdf7e134eaca42fbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e7c2d285c949df0dbb6fa0b389b4a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9">OS_DELAY</a>(ticks)&#160;&#160;&#160;_OS_DELAY(ticks)</td></tr>
<tr class="memdesc:ga82e7c2d285c949df0dbb6fa0b389b4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution of OS task for specified time.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9">More...</a><br /></td></tr>
<tr class="separator:ga82e7c2d285c949df0dbb6fa0b389b4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27a78f1a8e447ceff51b57c91bf84e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa27a78f1a8e447ceff51b57c91bf84e3">OS_DELAY_UNTIL</a>(ticks)&#160;&#160;&#160;_OS_DELAY_UNTIL(ticks)</td></tr>
<tr class="memdesc:gaa27a78f1a8e447ceff51b57c91bf84e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution of OS task until specified time.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa27a78f1a8e447ceff51b57c91bf84e3">More...</a><br /></td></tr>
<tr class="separator:gaa27a78f1a8e447ceff51b57c91bf84e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d74be6b64086261aaa2c50db552c389"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4d74be6b64086261aaa2c50db552c389">OS_GET_TICK_COUNT</a>()&#160;&#160;&#160;_OS_GET_TICK_COUNT()</td></tr>
<tr class="memdesc:ga4d74be6b64086261aaa2c50db552c389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current OS tick count.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga4d74be6b64086261aaa2c50db552c389">More...</a><br /></td></tr>
<tr class="separator:ga4d74be6b64086261aaa2c50db552c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeced1dc0652d4a88f5781ffb28982d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gadeced1dc0652d4a88f5781ffb28982d6">OS_GET_TICK_COUNT_FROM_ISR</a>()&#160;&#160;&#160;_OS_GET_TICK_COUNT_FROM_ISR()</td></tr>
<tr class="memdesc:gadeced1dc0652d4a88f5781ffb28982d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current OS tick count from ISR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gadeced1dc0652d4a88f5781ffb28982d6">More...</a><br /></td></tr>
<tr class="separator:gadeced1dc0652d4a88f5781ffb28982d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4773c79590cb37558d7a116bf7bc90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga6d4773c79590cb37558d7a116bf7bc90">OS_TICKS_2_MS</a>(ticks)&#160;&#160;&#160;_OS_TICKS_2_MS(ticks)</td></tr>
<tr class="memdesc:ga6d4773c79590cb37558d7a116bf7bc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from OS ticks to ms.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga6d4773c79590cb37558d7a116bf7bc90">More...</a><br /></td></tr>
<tr class="separator:ga6d4773c79590cb37558d7a116bf7bc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede42a5688918815691a6e6636ace839"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaede42a5688918815691a6e6636ace839">OS_MS_2_TICKS</a>(ms)&#160;&#160;&#160;_OS_MS_2_TICKS(ms)</td></tr>
<tr class="memdesc:gaede42a5688918815691a6e6636ace839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from ms to OS ticks.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaede42a5688918815691a6e6636ace839">More...</a><br /></td></tr>
<tr class="separator:gaede42a5688918815691a6e6636ace839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ae742e5ba520e18dad2bc0d6b583f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga66ae742e5ba520e18dad2bc0d6b583f0">OS_DELAY_MS</a>(ms)&#160;&#160;&#160;_OS_DELAY_MS(ms)</td></tr>
<tr class="memdesc:ga66ae742e5ba520e18dad2bc0d6b583f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution of OS task for specified time.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga66ae742e5ba520e18dad2bc0d6b583f0">More...</a><br /></td></tr>
<tr class="separator:ga66ae742e5ba520e18dad2bc0d6b583f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597975f3d5d3682d317e275b1881a240"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga597975f3d5d3682d317e275b1881a240">OS_ENTER_CRITICAL_SECTION</a>()&#160;&#160;&#160;_OS_ENTER_CRITICAL_SECTION()</td></tr>
<tr class="memdesc:ga597975f3d5d3682d317e275b1881a240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter critical section from non-ISR context.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga597975f3d5d3682d317e275b1881a240">More...</a><br /></td></tr>
<tr class="separator:ga597975f3d5d3682d317e275b1881a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256b0f34e297c21d9f66ff09df7d8db9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga256b0f34e297c21d9f66ff09df7d8db9">OS_ENTER_CRITICAL_SECTION_FROM_ISR</a>(critical_section_status)&#160;&#160;&#160;_OS_ENTER_CRITICAL_SECTION_FROM_ISR(critical_section_status)</td></tr>
<tr class="memdesc:ga256b0f34e297c21d9f66ff09df7d8db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter critical section from ISR context.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga256b0f34e297c21d9f66ff09df7d8db9">More...</a><br /></td></tr>
<tr class="separator:ga256b0f34e297c21d9f66ff09df7d8db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efbc6587b1537847833b16eb891b75d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2efbc6587b1537847833b16eb891b75d">OS_LEAVE_CRITICAL_SECTION</a>()&#160;&#160;&#160;_OS_LEAVE_CRITICAL_SECTION()</td></tr>
<tr class="memdesc:ga2efbc6587b1537847833b16eb891b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave critical section from non-ISR context.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga2efbc6587b1537847833b16eb891b75d">More...</a><br /></td></tr>
<tr class="separator:ga2efbc6587b1537847833b16eb891b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d0538b2257bcb83fc1739e8da3c22b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga60d0538b2257bcb83fc1739e8da3c22b">OS_LEAVE_CRITICAL_SECTION_FROM_ISR</a>(critical_section_status)&#160;&#160;&#160;_OS_LEAVE_CRITICAL_SECTION_FROM_ISR(critical_section_status)</td></tr>
<tr class="memdesc:ga60d0538b2257bcb83fc1739e8da3c22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave critical section from ISR context.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga60d0538b2257bcb83fc1739e8da3c22b">More...</a><br /></td></tr>
<tr class="separator:ga60d0538b2257bcb83fc1739e8da3c22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae013d6d0b27ad84dc89024c5dd827b0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b">OS_MALLOC_FUNC</a>&#160;&#160;&#160;_OS_MALLOC_FUNC</td></tr>
<tr class="memdesc:gae013d6d0b27ad84dc89024c5dd827b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for OS memory allocation function.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b">More...</a><br /></td></tr>
<tr class="separator:gae013d6d0b27ad84dc89024c5dd827b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21743caf8af2c722bdd8a670192f8881"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga21743caf8af2c722bdd8a670192f8881">OS_MALLOC_NORET_FUNC</a>&#160;&#160;&#160;_OS_MALLOC_NORET_FUNC</td></tr>
<tr class="memdesc:ga21743caf8af2c722bdd8a670192f8881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for non-retain memory allocation function.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga21743caf8af2c722bdd8a670192f8881">More...</a><br /></td></tr>
<tr class="separator:ga21743caf8af2c722bdd8a670192f8881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1765b1b6fb9f9e7f550dfb671637f0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c">OS_MALLOC</a>(size)&#160;&#160;&#160;_OS_MALLOC(size)</td></tr>
<tr class="memdesc:gac1765b1b6fb9f9e7f550dfb671637f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from OS provided heap.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c">More...</a><br /></td></tr>
<tr class="separator:gac1765b1b6fb9f9e7f550dfb671637f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa518cdd7ba27ea28b30ed4e2e2d59a5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d">OS_MALLOC_NORET</a>(size)&#160;&#160;&#160;_OS_MALLOC_NORET(size)</td></tr>
<tr class="memdesc:gaa518cdd7ba27ea28b30ed4e2e2d59a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from non-retain heap.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d">More...</a><br /></td></tr>
<tr class="separator:gaa518cdd7ba27ea28b30ed4e2e2d59a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3512d548e2a84afa6fe2a8be6937074"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae3512d548e2a84afa6fe2a8be6937074">OS_FREE_FUNC</a>&#160;&#160;&#160;_OS_FREE_FUNC</td></tr>
<tr class="memdesc:gae3512d548e2a84afa6fe2a8be6937074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for OS free memory function.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gae3512d548e2a84afa6fe2a8be6937074">More...</a><br /></td></tr>
<tr class="separator:gae3512d548e2a84afa6fe2a8be6937074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3115e8af8ac7eec38217271311ed9d34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3115e8af8ac7eec38217271311ed9d34">OS_FREE_NORET_FUNC</a>&#160;&#160;&#160;_OS_FREE_NORET_FUNC</td></tr>
<tr class="memdesc:ga3115e8af8ac7eec38217271311ed9d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for non-retain memory free function.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3115e8af8ac7eec38217271311ed9d34">More...</a><br /></td></tr>
<tr class="separator:ga3115e8af8ac7eec38217271311ed9d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd363022ea0bfcadacf515b2e34985d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d">OS_FREE</a>(addr)&#160;&#160;&#160;_OS_FREE(addr)</td></tr>
<tr class="memdesc:gabbd363022ea0bfcadacf515b2e34985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap.">OS_MALLOC()</a>  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d">More...</a><br /></td></tr>
<tr class="separator:gabbd363022ea0bfcadacf515b2e34985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfdb04b48a504f559e42125fc43186d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bfdb04b48a504f559e42125fc43186d">OS_FREE_NORET</a>(addr)&#160;&#160;&#160;_OS_FREE_NORET(addr)</td></tr>
<tr class="memdesc:ga3bfdb04b48a504f559e42125fc43186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap.">OS_MALLOC_NORET()</a>  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bfdb04b48a504f559e42125fc43186d">More...</a><br /></td></tr>
<tr class="separator:ga3bfdb04b48a504f559e42125fc43186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c00e69676964fd026dd76b5da06ad0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3c00e69676964fd026dd76b5da06ad0f">OS_PRECONDITION</a>(cond)&#160;&#160;&#160;_OS_PRECONDITION(cond)</td></tr>
<tr class="memdesc:ga3c00e69676964fd026dd76b5da06ad0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS precondition.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3c00e69676964fd026dd76b5da06ad0f">More...</a><br /></td></tr>
<tr class="separator:ga3c00e69676964fd026dd76b5da06ad0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06342422c3b25434d33571af43f6813f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga06342422c3b25434d33571af43f6813f">OS_GET_TASKS_STATUS</a>(task_status,  status_size)&#160;&#160;&#160;_OS_GET_TASKS_STATUS((task_status), (status_size))</td></tr>
<tr class="memdesc:ga06342422c3b25434d33571af43f6813f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get monitored OS tasks' status.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga06342422c3b25434d33571af43f6813f">More...</a><br /></td></tr>
<tr class="separator:ga06342422c3b25434d33571af43f6813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb673b570c7489cc7f2f1dd6a632e15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabbb673b570c7489cc7f2f1dd6a632e15">OS_GET_TASK_STACK_WATERMARK</a>(task)&#160;&#160;&#160;_OS_GET_TASK_STACK_WATERMARK(task)</td></tr>
<tr class="memdesc:gabbb673b570c7489cc7f2f1dd6a632e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the high water mark of the stack associated with an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gabbb673b570c7489cc7f2f1dd6a632e15">More...</a><br /></td></tr>
<tr class="separator:gabbb673b570c7489cc7f2f1dd6a632e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79a0b5e1486e4b2af196fb0f61b511f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac79a0b5e1486e4b2af196fb0f61b511f">OS_GET_STACK_WATERMARK</a>(task)</td></tr>
<tr class="memdesc:gac79a0b5e1486e4b2af196fb0f61b511f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the high water mark of the stack associated with an OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gac79a0b5e1486e4b2af196fb0f61b511f">More...</a><br /></td></tr>
<tr class="separator:gac79a0b5e1486e4b2af196fb0f61b511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f148a5cf9ea2d24b9397ad5e21fe80d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga9f148a5cf9ea2d24b9397ad5e21fe80d">OS_GET_HEAP_WATERMARK</a>()&#160;&#160;&#160;_OS_GET_HEAP_WATERMARK()</td></tr>
<tr class="memdesc:ga9f148a5cf9ea2d24b9397ad5e21fe80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the high water mark of heap.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga9f148a5cf9ea2d24b9397ad5e21fe80d">More...</a><br /></td></tr>
<tr class="separator:ga9f148a5cf9ea2d24b9397ad5e21fe80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c1232634084cd90cffd32cfbe29d9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga47c1232634084cd90cffd32cfbe29d9c">OS_GET_FREE_HEAP_SIZE</a>()&#160;&#160;&#160;_OS_GET_FREE_HEAP_SIZE()</td></tr>
<tr class="memdesc:ga47c1232634084cd90cffd32cfbe29d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current free heap size.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga47c1232634084cd90cffd32cfbe29d9c">More...</a><br /></td></tr>
<tr class="separator:ga47c1232634084cd90cffd32cfbe29d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f60f4f66eeaf11537490392f33016e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga48f60f4f66eeaf11537490392f33016e">OS_GET_TASKS_NUMBER</a>()&#160;&#160;&#160;_OS_GET_TASKS_NUMBER()</td></tr>
<tr class="memdesc:ga48f60f4f66eeaf11537490392f33016e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current number of OS tasks.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga48f60f4f66eeaf11537490392f33016e">More...</a><br /></td></tr>
<tr class="separator:ga48f60f4f66eeaf11537490392f33016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7200613993969cb9c333a94d390c44b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7200613993969cb9c333a94d390c44b1">OS_GET_TASK_NAME</a>(task)&#160;&#160;&#160;_OS_GET_TASK_NAME(task)</td></tr>
<tr class="memdesc:ga7200613993969cb9c333a94d390c44b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task name.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga7200613993969cb9c333a94d390c44b1">More...</a><br /></td></tr>
<tr class="separator:ga7200613993969cb9c333a94d390c44b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793e6aa2e8283030295e8e0a809d77c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga793e6aa2e8283030295e8e0a809d77c4">OS_GET_TASK_STATE</a>(task)&#160;&#160;&#160;_OS_GET_TASK_STATE(task)</td></tr>
<tr class="memdesc:ga793e6aa2e8283030295e8e0a809d77c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task state.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga793e6aa2e8283030295e8e0a809d77c4">More...</a><br /></td></tr>
<tr class="separator:ga793e6aa2e8283030295e8e0a809d77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e03daa68eb4b55a02a343178f77199"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga83e03daa68eb4b55a02a343178f77199">OS_GET_TASK_PRIORITY</a>(task)&#160;&#160;&#160;_OS_GET_TASK_PRIORITY(task)</td></tr>
<tr class="memdesc:ga83e03daa68eb4b55a02a343178f77199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task priority.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga83e03daa68eb4b55a02a343178f77199">More...</a><br /></td></tr>
<tr class="separator:ga83e03daa68eb4b55a02a343178f77199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e79ac7a74a17fd693d30eadf2d60408"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4e79ac7a74a17fd693d30eadf2d60408">OS_GET_IDLE_TASK_HANDLE</a>()&#160;&#160;&#160;_OS_GET_IDLE_TASK_HANDLE()</td></tr>
<tr class="memdesc:ga4e79ac7a74a17fd693d30eadf2d60408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task handle associated with the Idle OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga4e79ac7a74a17fd693d30eadf2d60408">More...</a><br /></td></tr>
<tr class="separator:ga4e79ac7a74a17fd693d30eadf2d60408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4193ab92ead15f4344b61bebbc290e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab4193ab92ead15f4344b61bebbc290e5">OS_GET_TASK_HANDLE</a>(task_name)&#160;&#160;&#160;_OS_GET_TASK_HANDLE(task_name)</td></tr>
<tr class="memdesc:gab4193ab92ead15f4344b61bebbc290e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS task handle by name.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab4193ab92ead15f4344b61bebbc290e5">More...</a><br /></td></tr>
<tr class="separator:gab4193ab92ead15f4344b61bebbc290e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4147061a58644d033f1b99d4eb727ede"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4147061a58644d033f1b99d4eb727ede">OS_ATOMIC_COMPARE_AND_SWAP_U32</a>(value_location,  exchange_value,  swap_condition)&#160;&#160;&#160;_OS_ATOMIC_COMPARE_AND_SWAP_U32(value_location, exchange_value, swap_condition)</td></tr>
<tr class="memdesc:ga4147061a58644d033f1b99d4eb727ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and swap.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga4147061a58644d033f1b99d4eb727ede">More...</a><br /></td></tr>
<tr class="separator:ga4147061a58644d033f1b99d4eb727ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1845f7964414539a8b2938b9bc818199"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1845f7964414539a8b2938b9bc818199">OS_ATOMIC_SWAP_POINTERS_P32</a>(destination_pointer,  exchange_pointer)&#160;&#160;&#160;_OS_ATOMIC_SWAP_POINTERS_P32(destination_pointer, exchange_pointer)</td></tr>
<tr class="memdesc:ga1845f7964414539a8b2938b9bc818199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic swap (pointers)  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga1845f7964414539a8b2938b9bc818199">More...</a><br /></td></tr>
<tr class="separator:ga1845f7964414539a8b2938b9bc818199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa638bf2cd5b3ab091ab81a5b01e70a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4fa638bf2cd5b3ab091ab81a5b01e70a">OS_ATOMIC_COMPARE_AND_SWAP_POINTERS_P32</a>(destination_pointer,  exchange_pointer,  swap_condition)&#160;&#160;&#160;_OS_ATOMIC_COMPARE_AND_SWAP_POINTERS_P32(destination_pointer, exchange_pointer, swap_condition)</td></tr>
<tr class="memdesc:ga4fa638bf2cd5b3ab091ab81a5b01e70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and swap (pointers)  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga4fa638bf2cd5b3ab091ab81a5b01e70a">More...</a><br /></td></tr>
<tr class="separator:ga4fa638bf2cd5b3ab091ab81a5b01e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152787317e3e74fb492e2c8dbb8615e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga152787317e3e74fb492e2c8dbb8615e9">OS_ATOMIC_ADD_U32</a>(value_location,  add_value)&#160;&#160;&#160;_OS_ATOMIC_ADD_U32(value_location, add_value)</td></tr>
<tr class="memdesc:ga152787317e3e74fb492e2c8dbb8615e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga152787317e3e74fb492e2c8dbb8615e9">More...</a><br /></td></tr>
<tr class="separator:ga152787317e3e74fb492e2c8dbb8615e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2081d1f0509951a6c5f5b56e84431de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac2081d1f0509951a6c5f5b56e84431de">OS_ATOMIC_SUBTRACT_U32</a>(value_location,  subtract_value)&#160;&#160;&#160;_OS_ATOMIC_SUBTRACT_U32(value_location, subtract_value)</td></tr>
<tr class="memdesc:gac2081d1f0509951a6c5f5b56e84431de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gac2081d1f0509951a6c5f5b56e84431de">More...</a><br /></td></tr>
<tr class="separator:gac2081d1f0509951a6c5f5b56e84431de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc84bc5beaa94fc96730dace28adc2c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gafc84bc5beaa94fc96730dace28adc2c9">OS_ATOMIC_INCREMENT_U32</a>(value_location)&#160;&#160;&#160;_OS_ATOMIC_INCREMENT_U32(value_location)</td></tr>
<tr class="memdesc:gafc84bc5beaa94fc96730dace28adc2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gafc84bc5beaa94fc96730dace28adc2c9">More...</a><br /></td></tr>
<tr class="separator:gafc84bc5beaa94fc96730dace28adc2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf80ea8429912ffca87283a4fa91e24f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaaf80ea8429912ffca87283a4fa91e24f">OS_ATOMIC_DECREMENT_U32</a>(value_location)&#160;&#160;&#160;_OS_ATOMIC_DECREMENT_U32(value_location)</td></tr>
<tr class="memdesc:gaaf80ea8429912ffca87283a4fa91e24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaaf80ea8429912ffca87283a4fa91e24f">More...</a><br /></td></tr>
<tr class="separator:gaaf80ea8429912ffca87283a4fa91e24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3c6b44d426f60b855c02b255b0dcf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8f3c6b44d426f60b855c02b255b0dcf9">OS_ATOMIC_OR_U32</a>(value_location,  or_mask)&#160;&#160;&#160;_OS_ATOMIC_OR_U32(value_location, or_mask)</td></tr>
<tr class="memdesc:ga8f3c6b44d426f60b855c02b255b0dcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic OR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga8f3c6b44d426f60b855c02b255b0dcf9">More...</a><br /></td></tr>
<tr class="separator:ga8f3c6b44d426f60b855c02b255b0dcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f562a54c21452c8752671d2ea16efb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0f562a54c21452c8752671d2ea16efb8">OS_ATOMIC_AND_U32</a>(value_location,  and_mask)&#160;&#160;&#160;_OS_ATOMIC_AND_U32(value_location, and_mask)</td></tr>
<tr class="memdesc:ga0f562a54c21452c8752671d2ea16efb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic AND.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga0f562a54c21452c8752671d2ea16efb8">More...</a><br /></td></tr>
<tr class="separator:ga0f562a54c21452c8752671d2ea16efb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55bfc188594d0179b9d91807e353cc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab55bfc188594d0179b9d91807e353cc4">OS_ATOMIC_NAND_U32</a>(value_location,  nand_mask)&#160;&#160;&#160;_OS_ATOMIC_NAND_U32(value_location, nand_mask)</td></tr>
<tr class="memdesc:gab55bfc188594d0179b9d91807e353cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic NAND.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab55bfc188594d0179b9d91807e353cc4">More...</a><br /></td></tr>
<tr class="separator:gab55bfc188594d0179b9d91807e353cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab164fe87dd4e0eb4592655999d7fb1e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab164fe87dd4e0eb4592655999d7fb1e2">OS_ATOMIC_XOR_U32</a>(value_location,  xor_mask)&#160;&#160;&#160;_OS_ATOMIC_XOR_U32(value_location, xor_mask)</td></tr>
<tr class="memdesc:gab164fe87dd4e0eb4592655999d7fb1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic XOR.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gab164fe87dd4e0eb4592655999d7fb1e2">More...</a><br /></td></tr>
<tr class="separator:gab164fe87dd4e0eb4592655999d7fb1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb679967456d15afcdd809d587271cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaeeb679967456d15afcdd809d587271cf">OS_GET_HEAP_STATISTICS</a>(results_pointer)&#160;&#160;&#160;_OS_GET_HEAP_STATISTICS(results_pointer)</td></tr>
<tr class="memdesc:gaeeb679967456d15afcdd809d587271cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get heap statistics.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaeeb679967456d15afcdd809d587271cf">More...</a><br /></td></tr>
<tr class="separator:gaeeb679967456d15afcdd809d587271cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e3e255bd2d3f3e872cb27426010e62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga73e3e255bd2d3f3e872cb27426010e62">OS_SYS_PRE_STOP_PROCESSING</a>()&#160;&#160;&#160;_OS_SYS_PRE_STOP_PROCESSING()</td></tr>
<tr class="memdesc:ga73e3e255bd2d3f3e872cb27426010e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform processing prior to system stopping (e.g. entering hibernation)  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga73e3e255bd2d3f3e872cb27426010e62">More...</a><br /></td></tr>
<tr class="separator:ga73e3e255bd2d3f3e872cb27426010e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5d857ce3e79bd3ebfb6d52447667d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaef5d857ce3e79bd3ebfb6d52447667d5">OS_SYS_PRE_SLEEP_PROCESSING</a>(sleep_period)&#160;&#160;&#160;_OS_SYS_PRE_SLEEP_PROCESSING(sleep_period)</td></tr>
<tr class="memdesc:gaef5d857ce3e79bd3ebfb6d52447667d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform processing prior to system entering sleep.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaef5d857ce3e79bd3ebfb6d52447667d5">More...</a><br /></td></tr>
<tr class="separator:gaef5d857ce3e79bd3ebfb6d52447667d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6955bdf43c8301d4a9942c2db9b0681"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae6955bdf43c8301d4a9942c2db9b0681">OS_SYS_POST_SLEEP_PROCESSING</a>()&#160;&#160;&#160;_OS_SYS_POST_SLEEP_PROCESSING()</td></tr>
<tr class="memdesc:gae6955bdf43c8301d4a9942c2db9b0681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform processing after system waking-up.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gae6955bdf43c8301d4a9942c2db9b0681">More...</a><br /></td></tr>
<tr class="separator:gae6955bdf43c8301d4a9942c2db9b0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d53a1a4593c1af5f43f0bab5991b2b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1d53a1a4593c1af5f43f0bab5991b2b4">OS_SYS_PRE_IDLE_PROCESSING</a>(sleep_period)&#160;&#160;&#160;_OS_SYS_PRE_IDLE_PROCESSING(sleep_period)</td></tr>
<tr class="memdesc:ga1d53a1a4593c1af5f43f0bab5991b2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform processing prior to system entering idle state.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga1d53a1a4593c1af5f43f0bab5991b2b4">More...</a><br /></td></tr>
<tr class="separator:ga1d53a1a4593c1af5f43f0bab5991b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ce1872c7a1497b5507babaf3be07cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gad3ce1872c7a1497b5507babaf3be07cd">OS_SYS_POST_IDLE_PROCESSING</a>(sleep_period)&#160;&#160;&#160;_OS_SYS_POST_IDLE_PROCESSING(sleep_period)</td></tr>
<tr class="memdesc:gad3ce1872c7a1497b5507babaf3be07cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform processing after system exiting idle state.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gad3ce1872c7a1497b5507babaf3be07cd">More...</a><br /></td></tr>
<tr class="separator:gad3ce1872c7a1497b5507babaf3be07cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4c5b6679ac573a42506a0cae3c562d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga6a4c5b6679ac573a42506a0cae3c562d">OS_APP_MALLOC_FAILED</a>(...)</td></tr>
<tr class="memdesc:ga6a4c5b6679ac573a42506a0cae3c562d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to handle memory allocation failures.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga6a4c5b6679ac573a42506a0cae3c562d">More...</a><br /></td></tr>
<tr class="separator:ga6a4c5b6679ac573a42506a0cae3c562d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8c499d387aab5924a0828c607d365e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga6c8c499d387aab5924a0828c607d365e">OS_APP_IDLE</a>(...)</td></tr>
<tr class="memdesc:ga6c8c499d387aab5924a0828c607d365e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to be called on each iteration of the idle OS task.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga6c8c499d387aab5924a0828c607d365e">More...</a><br /></td></tr>
<tr class="separator:ga6c8c499d387aab5924a0828c607d365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab3d5686153c3277d74d26114d35a51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3ab3d5686153c3277d74d26114d35a51">OS_APP_STACK_OVERFLOW</a>(...)</td></tr>
<tr class="memdesc:ga3ab3d5686153c3277d74d26114d35a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to be called upon stack overflow.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga3ab3d5686153c3277d74d26114d35a51">More...</a><br /></td></tr>
<tr class="separator:ga3ab3d5686153c3277d74d26114d35a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36692aa7692e0147db212546178eca26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga36692aa7692e0147db212546178eca26">OS_APP_TICK</a>(...)</td></tr>
<tr class="memdesc:ga36692aa7692e0147db212546178eca26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to be called on every OS tick.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga36692aa7692e0147db212546178eca26">More...</a><br /></td></tr>
<tr class="separator:ga36692aa7692e0147db212546178eca26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09701f7eeeee95374f9f86d1575f9e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa09701f7eeeee95374f9f86d1575f9e1">OS_APP_DAEMON_TASK</a>(...)</td></tr>
<tr class="memdesc:gaa09701f7eeeee95374f9f86d1575f9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to be called at the point the daemon OS task starts executing.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gaa09701f7eeeee95374f9f86d1575f9e1">More...</a><br /></td></tr>
<tr class="separator:gaa09701f7eeeee95374f9f86d1575f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f187493e273da8e62ba1bf133b6f69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga49f187493e273da8e62ba1bf133b6f69">OS_TICK_ADVANCE</a>()&#160;&#160;&#160;_OS_TICK_ADVANCE()</td></tr>
<tr class="memdesc:ga49f187493e273da8e62ba1bf133b6f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance OS tick count.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga49f187493e273da8e62ba1bf133b6f69">More...</a><br /></td></tr>
<tr class="separator:ga49f187493e273da8e62ba1bf133b6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93a1a5a9f0c0b914c535e4445565c65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gad93a1a5a9f0c0b914c535e4445565c65">OS_TICK_INCREMENT</a>(ticks)&#160;&#160;&#160;_OS_TICK_INCREMENT(ticks)</td></tr>
<tr class="memdesc:gad93a1a5a9f0c0b914c535e4445565c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update OS tick count by adding a given number of OS ticks.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gad93a1a5a9f0c0b914c535e4445565c65">More...</a><br /></td></tr>
<tr class="separator:gad93a1a5a9f0c0b914c535e4445565c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f3930730a3bec33ab282c72a7796dd"><td class="memItemLeft" align="right" valign="top"><a id="gaa3f3930730a3bec33ab282c72a7796dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa3f3930730a3bec33ab282c72a7796dd">OS_PTR_TO_UINT</a>(p)&#160;&#160;&#160;((unsigned) (void *) (p))</td></tr>
<tr class="memdesc:gaa3f3930730a3bec33ab282c72a7796dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any pointer to unsigned int value. <br /></td></tr>
<tr class="separator:gaa3f3930730a3bec33ab282c72a7796dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3356801fef2a1e61c65631a60f5497d"><td class="memItemLeft" align="right" valign="top"><a id="gad3356801fef2a1e61c65631a60f5497d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gad3356801fef2a1e61c65631a60f5497d">OS_PTR_TO_INT</a>(p)&#160;&#160;&#160;((int) (void *) (p))</td></tr>
<tr class="memdesc:gad3356801fef2a1e61c65631a60f5497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any pointer to signed int value. <br /></td></tr>
<tr class="separator:gad3356801fef2a1e61c65631a60f5497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64494b18cfa2d9d95df93e16372107e"><td class="memItemLeft" align="right" valign="top"><a id="gae64494b18cfa2d9d95df93e16372107e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae64494b18cfa2d9d95df93e16372107e">OS_UINT_TO_PTR</a>(u)&#160;&#160;&#160;((void *) (unsigned) (u))</td></tr>
<tr class="memdesc:gae64494b18cfa2d9d95df93e16372107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any unsigned int value to pointer. <br /></td></tr>
<tr class="separator:gae64494b18cfa2d9d95df93e16372107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117b1997eb33b5a7e1538c1e0d516338"><td class="memItemLeft" align="right" valign="top"><a id="ga117b1997eb33b5a7e1538c1e0d516338"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga117b1997eb33b5a7e1538c1e0d516338">OS_INT_TO_PTR</a>(i)&#160;&#160;&#160;((void *) (int) (i))</td></tr>
<tr class="memdesc:ga117b1997eb33b5a7e1538c1e0d516338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any signed int value to pointer. <br /></td></tr>
<tr class="separator:ga117b1997eb33b5a7e1538c1e0d516338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga91db83d76f11008246e38e80bfeb24cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga91db83d76f11008246e38e80bfeb24cd">OS_NOTIFY_ACTION</a> { <br />
&#160;&#160;<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cdacf8af7394792ac07a6fb45b6966322ed">OS_NOTIFY_NO_ACTION</a> = _OS_NOTIFY_NO_ACTION, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cda707e11498965fb2a27d28003922eb33a">OS_NOTIFY_SET_BITS</a> = _OS_NOTIFY_SET_BITS, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cdadcdfb5913c4529e5673b6c2ae65ab1f3">OS_NOTIFY_INCREMENT</a> = _OS_NOTIFY_INCREMENT, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cda63b4d57115eb7e18e77dda410c8c8d16">OS_NOTIFY_VAL_WITH_OVERWRITE</a> = _OS_NOTIFY_VAL_WITH_OVERWRITE, 
<br />
&#160;&#160;<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cda4236b135cee8aa0ea383216a2a6600f3">OS_NOTIFY_VAL_WITHOUT_OVERWRITE</a> = _OS_NOTIFY_VAL_WITHOUT_OVERWRITE
<br />
 }</td></tr>
<tr class="memdesc:ga91db83d76f11008246e38e80bfeb24cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS task notification action.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga91db83d76f11008246e38e80bfeb24cd">More...</a><br /></td></tr>
<tr class="separator:ga91db83d76f11008246e38e80bfeb24cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe06d898bcd0410afc12cd1164cdb658"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabe06d898bcd0410afc12cd1164cdb658">OS_TASK_STATE</a> { <br />
&#160;&#160;<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658ae6721aefc70c2f731dd95976c86e2d08">OS_TASK_RUNNING</a> = _OS_TASK_RUNNING, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658a529cd0e1f131f501efe7cc3d1122d002">OS_TASK_READY</a> = _OS_TASK_READY, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658a4705e6f6965e05b68e1fd805005f1fed">OS_TASK_BLOCKED</a> = _OS_TASK_BLOCKED, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658a62ddebcd9f9807614278e7999168ec7e">OS_TASK_SUSPENDED</a> = _OS_TASK_SUSPENDED, 
<br />
&#160;&#160;<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658af3928fd43595cf4864252be0d5a0fd27">OS_TASK_DELETED</a> = _OS_TASK_DELETED
<br />
 }</td></tr>
<tr class="memdesc:gabe06d898bcd0410afc12cd1164cdb658"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS task state.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#gabe06d898bcd0410afc12cd1164cdb658">More...</a><br /></td></tr>
<tr class="separator:gabe06d898bcd0410afc12cd1164cdb658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284ead1d430aeefa5d9cb6fa9417a27b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga284ead1d430aeefa5d9cb6fa9417a27b">OS_SCHEDULER_STATE</a> { <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga284ead1d430aeefa5d9cb6fa9417a27ba4561b99e50f2a93a679a163c642b7d3c">OS_SCHEDULER_RUNNING</a> = _OS_SCHEDULER_RUNNING, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga284ead1d430aeefa5d9cb6fa9417a27ba306078dd3cf3fb81afb81e3df5322823">OS_SCHEDULER_NOT_STARTED</a> = _OS_SCHEDULER_NOT_STARTED, 
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gga284ead1d430aeefa5d9cb6fa9417a27baa4257dfe6a1c7f925748fbe552eee6e1">OS_SCHEDULER_SUSPENDED</a> = _OS_SCHEDULER_SUSPENDED
 }</td></tr>
<tr class="memdesc:ga284ead1d430aeefa5d9cb6fa9417a27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS scheduler state.  <a href="group___m_i_d___r_t_o___o_s_a_l.html#ga284ead1d430aeefa5d9cb6fa9417a27b">More...</a><br /></td></tr>
<tr class="separator:ga284ead1d430aeefa5d9cb6fa9417a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API and configuration for using an operating system with the SDK. </p>
<p>OS Abstraction Layer.</p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa09701f7eeeee95374f9f86d1575f9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09701f7eeeee95374f9f86d1575f9e1">&#9670;&nbsp;</a></span>OS_APP_DAEMON_TASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_APP_DAEMON_TASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> dummyDaemonTaskHook(__VA_ARGS__) <a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a>; \</div>
<div class="line">                                void dummyDaemonTaskHook(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Hook function to be called at the point the daemon OS task starts executing. </p>
<p>This is a hook function that is called at the point the daemon OS task starts executing. </p>

</div>
</div>
<a id="ga6c8c499d387aab5924a0828c607d365e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8c499d387aab5924a0828c607d365e">&#9670;&nbsp;</a></span>OS_APP_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_APP_IDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> dummyIdleHook(__VA_ARGS__) <a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a>; \</div>
<div class="line">                         void dummyIdleHook(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Hook function to be called on each iteration of the idle OS task. </p>
<p>This is a hook function that is called on each iteration of the idle OS task. It is essential that code added to this hook function never attempts to block in any way (for example, call <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga734ae4efa9b0f0648e46d68b39ae9639" title="Get element from OS queue.">OS_QUEUE_GET()</a> with a block time specified, or call <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9" title="Delay execution of OS task for specified time.">OS_DELAY()</a>). If the application makes use of the <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga24a73ccb253999f6d79b6985c097fb4e" title="Delete OS task.">OS_TASK_DELETE()</a> API function then it is also important that <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga6c8c499d387aab5924a0828c607d365e" title="Hook function to be called on each iteration of the idle OS task.">OS_APP_IDLE()</a> is permitted to return to its calling function, because it is the responsibility of the idle OS task to clean up memory allocated by the kernel to any task that has since been deleted. </p>

</div>
</div>
<a id="ga6a4c5b6679ac573a42506a0cae3c562d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a4c5b6679ac573a42506a0cae3c562d">&#9670;&nbsp;</a></span>OS_APP_MALLOC_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_APP_MALLOC_FAILED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> dummyMallocFailedHook(__VA_ARGS__) <a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a>; \</div>
<div class="line">                                  void dummyMallocFailedHook(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Hook function to handle memory allocation failures. </p>
<p>This is a hook function that is called only if a call to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap.">OS_MALLOC()</a> fails. <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga47c1232634084cd90cffd32cfbe29d9c" title="Get current free heap size.">OS_GET_FREE_HEAP_SIZE()</a> function can be used to query the size of free heap space that remains.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap.">OS_MALLOC</a> </dd>
<dd>
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga47c1232634084cd90cffd32cfbe29d9c" title="Get current free heap size.">OS_GET_FREE_HEAP_SIZE</a> </dd></dl>

</div>
</div>
<a id="ga3ab3d5686153c3277d74d26114d35a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab3d5686153c3277d74d26114d35a51">&#9670;&nbsp;</a></span>OS_APP_STACK_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_APP_STACK_OVERFLOW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> dummyStackOverflowHook(__VA_ARGS__) <a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a>; \</div>
<div class="line">                                   void dummyStackOverflowHook(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Hook function to be called upon stack overflow. </p>
<p>This is a hook function that is called if a stack overflow is detected. </p>

</div>
</div>
<a id="ga36692aa7692e0147db212546178eca26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36692aa7692e0147db212546178eca26">&#9670;&nbsp;</a></span>OS_APP_TICK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_APP_TICK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> dummyTickHook(__VA_ARGS__) <a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a>; \</div>
<div class="line">                         void dummyTickHook(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Hook function to be called on every OS tick. </p>
<p>This is a hook function that is called by each tick interrupt, i.e. from an interrupt context. It is essential that code added to this hook function never attempts to block in any way (for example, call <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9" title="Delay execution of OS task for specified time.">OS_DELAY()</a>) and only the interrupt-safe OSAL API functions can be used. </p>

</div>
</div>
<a id="ga152787317e3e74fb492e2c8dbb8615e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152787317e3e74fb492e2c8dbb8615e9">&#9670;&nbsp;</a></span>OS_ATOMIC_ADD_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_ADD_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">add_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_ADD_U32(value_location, add_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add. </p>
<p>Add add_value to value located at value_location</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_value</td><td>Value to be added to *value_location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="ga0f562a54c21452c8752671d2ea16efb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f562a54c21452c8752671d2ea16efb8">&#9670;&nbsp;</a></span>OS_ATOMIC_AND_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_AND_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">and_mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_AND_U32(value_location, and_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic AND. </p>
<p>Perform AND calculation on value at value_location with and_mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">and_mask</td><td>Value to be ANDed with *value_location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="ga4fa638bf2cd5b3ab091ab81a5b01e70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fa638bf2cd5b3ab091ab81a5b01e70a">&#9670;&nbsp;</a></span>OS_ATOMIC_COMPARE_AND_SWAP_POINTERS_P32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_COMPARE_AND_SWAP_POINTERS_P32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exchange_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_COMPARE_AND_SWAP_POINTERS_P32(destination_pointer, exchange_pointer, swap_condition)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and swap (pointers) </p>
<p>Set the address pointed to by destination_pointer to the value of *exchange_pointer, if the provided condition is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination_pointer</td><td>Pointer to memory location from where a pointer value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_pointer</td><td>Pointer value to be written to *destination_pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap_condition</td><td>The condition that need to be true for the swap to be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATOMIC_COMPARE_AND_SWAP_SUCCESS if the value was swapped, ATOMIC_COMPARE_AND_SWAP_FAILURE otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function only swaps *destination_pointer with exchange_pointer, if previous *destination_pointer value equals swap_condition. </dd></dl>

</div>
</div>
<a id="ga4147061a58644d033f1b99d4eb727ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4147061a58644d033f1b99d4eb727ede">&#9670;&nbsp;</a></span>OS_ATOMIC_COMPARE_AND_SWAP_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_COMPARE_AND_SWAP_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exchange_value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_COMPARE_AND_SWAP_U32(value_location, exchange_value, swap_condition)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and swap. </p>
<p>Change the contents of provided pointer with the exchange_value, if the provided condition is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where a pointer value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_value</td><td>The new value that will be swapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap_condition</td><td>The condition that need to be true for the swap to be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATOMIC_COMPARE_AND_SWAP_SUCCESS if the value was swapped, ATOMIC_COMPARE_AND_SWAP_FAILURE otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function only swaps *value_location with exchange_value, if previous *value_location value equals swap_condition. </dd></dl>

</div>
</div>
<a id="gaaf80ea8429912ffca87283a4fa91e24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf80ea8429912ffca87283a4fa91e24f">&#9670;&nbsp;</a></span>OS_ATOMIC_DECREMENT_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_DECREMENT_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_ATOMIC_DECREMENT_U32(value_location)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<p>Decrement value located at value_location by 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="gafc84bc5beaa94fc96730dace28adc2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc84bc5beaa94fc96730dace28adc2c9">&#9670;&nbsp;</a></span>OS_ATOMIC_INCREMENT_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_INCREMENT_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_ATOMIC_INCREMENT_U32(value_location)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<p>Increment value located at value_location by 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="gab55bfc188594d0179b9d91807e353cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab55bfc188594d0179b9d91807e353cc4">&#9670;&nbsp;</a></span>OS_ATOMIC_NAND_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_NAND_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nand_mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_NAND_U32(value_location, nand_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic NAND. </p>
<p>Perform NAND calculation on value at value_location with nand_mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nand_mask</td><td>Value to be NANDed with *value_location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="ga8f3c6b44d426f60b855c02b255b0dcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f3c6b44d426f60b855c02b255b0dcf9">&#9670;&nbsp;</a></span>OS_ATOMIC_OR_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_OR_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">or_mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_OR_U32(value_location, or_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic OR. </p>
<p>Perform OR calculation on value at value_location with or_mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">or_mask</td><td>Value to be ORed with *value_location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="gac2081d1f0509951a6c5f5b56e84431de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2081d1f0509951a6c5f5b56e84431de">&#9670;&nbsp;</a></span>OS_ATOMIC_SUBTRACT_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_SUBTRACT_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">subtract_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_SUBTRACT_U32(value_location, subtract_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<p>Subtract subtract_value from value located at value_location</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtract_value</td><td>Value to be subtracted from *value_location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="ga1845f7964414539a8b2938b9bc818199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1845f7964414539a8b2938b9bc818199">&#9670;&nbsp;</a></span>OS_ATOMIC_SWAP_POINTERS_P32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_SWAP_POINTERS_P32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exchange_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_SWAP_POINTERS_P32(destination_pointer, exchange_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic swap (pointers) </p>
<p>Set the address pointed to by destination_pointer to the value of *exchange_pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">destination_pointer</td><td>Pointer to memory location from where a pointer value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_pointer</td><td>Pointer value to be written to *destination_pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initial value of *destination_pointer. </dd></dl>

</div>
</div>
<a id="gab164fe87dd4e0eb4592655999d7fb1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab164fe87dd4e0eb4592655999d7fb1e2">&#9670;&nbsp;</a></span>OS_ATOMIC_XOR_U32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ATOMIC_XOR_U32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_location, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xor_mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_ATOMIC_XOR_U32(value_location, xor_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic XOR. </p>
<p>Perform XOR calculation on value at value_location with xor_mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_location</td><td>Pointer to memory location from where value is to be loaded and written back to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xor_mask</td><td>Value to be XORed with *value_location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous *value_location value. </dd></dl>

</div>
</div>
<a id="ga82e7c2d285c949df0dbb6fa0b389b4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82e7c2d285c949df0dbb6fa0b389b4a9">&#9670;&nbsp;</a></span>OS_DELAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_DELAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_DELAY(ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay execution of OS task for specified time. </p>
<p>This function delays in OS specific way execution of current OS task for specified amount of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks</td><td>number of ticks to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66ae742e5ba520e18dad2bc0d6b583f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ae742e5ba520e18dad2bc0d6b583f0">&#9670;&nbsp;</a></span>OS_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_DELAY_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ms</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_DELAY_MS(ms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay execution of OS task for specified time. </p>
<p>This function delays in OS specific way execution of current OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>number of ms to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa27a78f1a8e447ceff51b57c91bf84e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa27a78f1a8e447ceff51b57c91bf84e3">&#9670;&nbsp;</a></span>OS_DELAY_UNTIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_DELAY_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_DELAY_UNTIL(ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay execution of OS task until specified time. </p>
<p>This function delays in OS specific way execution of current OS task until specified time is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks</td><td>absolute time to wait until in ticks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga597975f3d5d3682d317e275b1881a240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga597975f3d5d3682d317e275b1881a240">&#9670;&nbsp;</a></span>OS_ENTER_CRITICAL_SECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ENTER_CRITICAL_SECTION</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_ENTER_CRITICAL_SECTION()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter critical section from non-ISR context. </p>
<p>This allows to enter critical section from non-ISR context. Implementation will disable interrupts with nesting counter. This function can be called several times by OS task but requires same number of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2efbc6587b1537847833b16eb891b75d" title="Leave critical section from non-ISR context.">OS_LEAVE_CRITICAL_SECTION()</a> calls to allow OS task switching and interrupts again.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2efbc6587b1537847833b16eb891b75d" title="Leave critical section from non-ISR context.">OS_LEAVE_CRITICAL_SECTION</a> </dd></dl>

</div>
</div>
<a id="ga256b0f34e297c21d9f66ff09df7d8db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga256b0f34e297c21d9f66ff09df7d8db9">&#9670;&nbsp;</a></span>OS_ENTER_CRITICAL_SECTION_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ENTER_CRITICAL_SECTION_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">critical_section_status</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_ENTER_CRITICAL_SECTION_FROM_ISR(critical_section_status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter critical section from ISR context. </p>
<p>This function allows to enter critical section from ISR context. It can be called several times from within ISR context but requires same number of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga60d0538b2257bcb83fc1739e8da3c22b" title="Leave critical section from ISR context.">OS_LEAVE_CRITICAL_SECTION_FROM_ISR()</a> calls to restore interrupt status.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga60d0538b2257bcb83fc1739e8da3c22b" title="Leave critical section from ISR context.">OS_LEAVE_CRITICAL_SECTION_FROM_ISR</a> </dd></dl>

</div>
</div>
<a id="ga3c99697a636be93943260708124dd0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c99697a636be93943260708124dd0e7">&#9670;&nbsp;</a></span>OS_EVENT_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_CHECK(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if OS event is signaled and clear it. </p>
<p>This function will return immediately with OS_EVENT_SIGNALED if OS event was in signaled state already. In case OS event is signaled, its state changes to not signaled after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled, otherwise OS_EVENT_NOT_SIGNALED </dd></dl>

</div>
</div>
<a id="ga80375029118643dcd0d5635fed8a33de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80375029118643dcd0d5635fed8a33de">&#9670;&nbsp;</a></span>OS_EVENT_CHECK_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CHECK_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_CHECK_FROM_ISR(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check from ISR if OS event is signaled and clear it. </p>
<p>This function will return immediately with OS_EVENT_SIGNALED if OS event was in signaled state already. In case OS event is signaled, its state changes to not signaled after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled, otherwise OS_EVENT_NOT_SIGNALED </dd></dl>

</div>
</div>
<a id="ga60e592d9acd648ce6b74f3ebc83a65e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e592d9acd648ce6b74f3ebc83a65e4">&#9670;&nbsp;</a></span>OS_EVENT_CHECK_FROM_ISR_NO_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CHECK_FROM_ISR_NO_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">need_yield&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_CHECK_FROM_ISR_NO_YIELD((event), (need_yield))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check from ISR if OS event is signaled and clear it, without requesting running OS task to yield. </p>
<p>This function will return immediately with OS_EVENT_SIGNALED if OS event was in signaled state already, without requesting running OS task to yield. In case OS event is signaled, its state changes to not signaled after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to check </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">need_yield</td><td>indication whether task yield is needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled, otherwise OS_EVENT_NOT_SIGNALED </dd></dl>

</div>
</div>
<a id="ga09506ad35a4182108374f79d60c7b054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09506ad35a4182108374f79d60c7b054">&#9670;&nbsp;</a></span>OS_EVENT_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_CREATE(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS event. </p>
<p>Function creates OS event that can be used to synchronize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>event handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c70e9ad6357b14cac5ab193f4038043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c70e9ad6357b14cac5ab193f4038043">&#9670;&nbsp;</a></span>OS_EVENT_CREATE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CREATE_FAILED&#160;&#160;&#160;((void)OS_EVENT_CREATE_FAILED,  <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga0781087ee54e5d1a007f6a6a7926ed79">OS_EVENT_CREATE_FAIL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event failed to be created. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Use OS_EVENT_CREATE_FAIL instead </dd></dl>

</div>
</div>
<a id="gab1c77555a99448ebe9cd25bd390f92d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1c77555a99448ebe9cd25bd390f92d3">&#9670;&nbsp;</a></span>OS_EVENT_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_DELETE(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS event. </p>
<p>Function destroys OS event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aa4609f7826824176ccf3284a0679c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa4609f7826824176ccf3284a0679c3">&#9670;&nbsp;</a></span>OS_EVENT_GET_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GET_STATUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_GET_STATUS(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS event status. </p>
<p>This function will return immediately with OS_EVENT_SIGNALED if OS event was in signaled state already. In case OS event is signaled, its state remains to signaled after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled, otherwise OS_EVENT_NOT_SIGNALED </dd></dl>

</div>
</div>
<a id="gaf57b36c0e104710a5dbd1238fca9b654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf57b36c0e104710a5dbd1238fca9b654">&#9670;&nbsp;</a></span>OS_EVENT_GET_STATUS_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GET_STATUS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_GET_STATUS_FROM_ISR(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS event status from ISR. </p>
<p>This function will return immediately with OS_EVENT_SIGNALED if OS event was in signaled state already. In case OS event is signaled, its state remains to signaled after calling this function.</p>
<p>This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled, otherwise OS_EVENT_NOT_SIGNALED </dd></dl>

</div>
</div>
<a id="ga46e637dbf5ba23f88d74ea93dafdbe42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46e637dbf5ba23f88d74ea93dafdbe42">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_CLEAR_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_CLEAR_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_clear&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_GROUP_CLEAR_BITS((event_group), (bits_to_clear))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear OS event group bits. </p>
<p>Function clears bits (flags) within an OS event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are to be cleared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_clear</td><td>a bitwise value that indicates the bit or bits to clear in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group bits before the specified bits were cleared </dd></dl>

</div>
</div>
<a id="gae28c2d7842c556a29e3ce9fb68c20e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae28c2d7842c556a29e3ce9fb68c20e36">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_clear&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR((event_group), (bits_to_clear))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear OS event group bits from an interrupt. </p>
<p>Function clears bits (flags) within an OS event group from an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are to be cleared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_clear</td><td>a bitwise value that indicates the bit or bits to clear in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group bits before the specified bits were cleared </dd></dl>

</div>
</div>
<a id="ga88e58ad0b5bae1e7bb80c7114716f3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88e58ad0b5bae1e7bb80c7114716f3d9">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_CREATE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_GROUP_CREATE()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS event group. </p>
<p>Function creates OS event group</p>
<dl class="section return"><dt>Returns</dt><dd>event group handle if successful, otherwise NULL </dd></dl>

</div>
</div>
<a id="gae3ad6b96a7fb19908798426b67779291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ad6b96a7fb19908798426b67779291">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_GROUP_DELETE(event_group)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS event group. </p>
<p>Function deletes an OS event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group being deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc34f47f4c851ffcba18917feafa2422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc34f47f4c851ffcba18917feafa2422">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_GET_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_GET_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_GROUP_GET_BITS(event_group)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS event group bits. </p>
<p>Function returns the current value of the event bits (event flags) in an OS event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group being queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group bits in the event group at the time <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabc34f47f4c851ffcba18917feafa2422" title="Get OS event group bits.">OS_EVENT_GROUP_GET_BITS()</a> was called </dd></dl>

</div>
</div>
<a id="gaac289748c5e1f388342c1ae54012b806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac289748c5e1f388342c1ae54012b806">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_GET_BITS_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_GET_BITS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_GROUP_GET_BITS_FROM_ISR(event_group)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS event group bits from an interrupt. </p>
<p>Function returns the current value of the event bits (event flags) in an OS event group from an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group being queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group bits in the event group at the time <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaac289748c5e1f388342c1ae54012b806" title="Get OS event group bits from an interrupt.">OS_EVENT_GROUP_GET_BITS_FROM_ISR()</a> was called </dd></dl>

</div>
</div>
<a id="gaba3327457eefae5c693ae54145f1adeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3327457eefae5c693ae54145f1adeb">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_SET_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SET_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_GROUP_SET_BITS((event_group), (bits_to_set))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OS event group bits. </p>
<p>Set bits (flags) within an OS event group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>a bitwise value that indicates the bit or bits to set in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the event group bits at the time the call to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaba3327457eefae5c693ae54145f1adeb" title="Set OS event group bits.">OS_EVENT_GROUP_SET_BITS()</a> returns </dd></dl>

</div>
</div>
<a id="ga8714ef11e52d2057eb1629447209071e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8714ef11e52d2057eb1629447209071e">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_SET_BITS_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SET_BITS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_GROUP_SET_BITS_FROM_ISR((event_group), (bits_to_set))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OS event group bits from ISR. </p>
<p>Set bits (flags) within an OS event group that can be called from an ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>a bitwise value that indicates the bit or bits to set in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the message was sent to the daemon OS task, then OS_OK is returned, otherwise OS_FAIL is returned </dd></dl>

</div>
</div>
<a id="ga89995858cb14c88779a865f24e52c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89995858cb14c88779a865f24e52c8e5">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_SET_BITS_FROM_ISR_NO_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SET_BITS_FROM_ISR_NO_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">need_yield&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_GROUP_SET_BITS_FROM_ISR_NO_YIELD((event_group), (bits_to_set), (need_yield))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OS event group bits from ISR without requesting running OS task to yield. </p>
<p>Set bits (flags) within an OS event group that can be called from an ISR without requesting running OS task to yield.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>a bitwise value that indicates the bit or bits to set in the event group </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">need_yield</td><td>indication whether task yield is needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the message was sent to the daemon OS task, then OS_OK is returned, otherwise OS_FAIL is returned </dd></dl>

</div>
</div>
<a id="gaa94f4416bf0ac7e69f7b1cef77822dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa94f4416bf0ac7e69f7b1cef77822dfa">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_SYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SYNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_wait, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_GROUP_SYNC((event_group), (bits_to_set), (bits_to_wait), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize OS event group bits. </p>
<p>Atomically set bits (flags) within an OS event group, then wait for a combination of bits to be set within the same OS event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are being set and tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>bit or bits to set in the event group before determining if all the bits specified by the bits_to_wait parameter are set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_wait</td><td>a bitwise value that indicates the bit or bits to test inside the event group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum amount of time (specified in 'ticks') to wait for all the bits specified by the bits_to_wait parameter value to become set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group bits at the time either the bits being waited for became set, or the block time expired </dd></dl>

</div>
</div>
<a id="ga3bda5fac5b0e69c42c1c8385cd0108a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bda5fac5b0e69c42c1c8385cd0108a9">&#9670;&nbsp;</a></span>OS_EVENT_GROUP_WAIT_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_WAIT_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_wait, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clear_on_exit, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait_for_all, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_OS_EVENT_GROUP_WAIT_BITS((event_group), (bits_to_wait), (clear_on_exit), (wait_for_all), \</div>
<div class="line">                                  (timeout))</div>
</div><!-- fragment -->
<p>Wait for OS event group bits to become set. </p>
<p>Function reads bits within an OS event group optionally entering the Blocked state (with a timeout) to wait for a bit or group of bits to become set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>handle of event group in which the bits are being tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_wait</td><td>a bitwise value to test inside the event group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_on_exit</td><td>= OS_TRUE: any bits set in the value passed as the bits_to_wait parameter will be cleared in the event group before <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9" title="Wait for OS event group bits to become set.">OS_EVENT_GROUP_WAIT_BITS()</a> returns OS_FALSE: bits in the event group are not altered when the call to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9" title="Wait for OS event group bits to become set.">OS_EVENT_GROUP_WAIT_BITS()</a> returns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_for_all</td><td>= OS_TRUE: <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9" title="Wait for OS event group bits to become set.">OS_EVENT_GROUP_WAIT_BITS()</a> will return when either <em>all</em> bits set in the value passed as the bits_to_wait parameter are set in the event group OS_FALSE: <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9" title="Wait for OS event group bits to become set.">OS_EVENT_GROUP_WAIT_BITS()</a> will return when <em>any</em> of the bits set in the value passed as the bits_to_wait parameter are set in the event group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum amount of time to wait for one/all of the bits specified by bits_to_wait to become set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the event group bits at the time either the event bits being waited for became set, or the timeout expired </dd></dl>

</div>
</div>
<a id="ga060073d02b4e7fb6b0a5ec588b6b98d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga060073d02b4e7fb6b0a5ec588b6b98d1">&#9670;&nbsp;</a></span>OS_EVENT_SIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_SIGNAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_SIGNAL(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OS event in signaled state. </p>
<p>Set OS event in signaled state so <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT()</a> will release waiting OS task if any. OS event will remain in signaled state till call to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT()</a> releases one OS task. This function should not be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to signal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_OK if event was signaled, otherwise OS_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT</a> </dd></dl>

</div>
</div>
<a id="ga1d8de4397bbf225a92c1105a5dadb3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8de4397bbf225a92c1105a5dadb3ba">&#9670;&nbsp;</a></span>OS_EVENT_SIGNAL_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_SIGNAL_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_EVENT_SIGNAL_FROM_ISR(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OS event in signaled state from ISR. </p>
<p>Set OS event in signaled state so <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT()</a> will release waiting OS task if any. OS event will remain in signaled state till call to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT()</a> releases one OS task. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to signal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_OK if event was signaled, otherwise OS_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT</a> </dd></dl>

</div>
</div>
<a id="ga8c9fd1f93ce06f44c50fca2abedd4907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c9fd1f93ce06f44c50fca2abedd4907">&#9670;&nbsp;</a></span>OS_EVENT_SIGNAL_FROM_ISR_NO_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_SIGNAL_FROM_ISR_NO_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">need_yield&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_SIGNAL_FROM_ISR_NO_YIELD((event), (need_yield))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OS event in signaled state from ISR without requesting running OS task to yield. </p>
<p>Set OS event in signaled state so <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT()</a> will release waiting OS task if any, without requesting running OS task to yield. OS event will remain in signaled state till call to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT()</a> releases one OS task. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to signal </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">need_yield</td><td>indication whether task yield is needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_OK if event was signaled, otherwise OS_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a" title="Wait for OS event to be signaled.">OS_EVENT_WAIT</a> </dd></dl>

</div>
</div>
<a id="ga7fb1d31b30a33ccfbfed4cebabf6990a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb1d31b30a33ccfbfed4cebabf6990a">&#9670;&nbsp;</a></span>OS_EVENT_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_WAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_EVENT_WAIT((event), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for OS event to be signaled. </p>
<p>This function waits for OS event to be in signaled state. If OS event was already in signaled state or become signaled in specified time, function will return OS_EVENT_SIGNALED, and the state of OS event will change to not signaled. To check if OS event is already signaled use OS_EVENT_NO_WAIT as timeout. To wait till OS event is signaled use OS_EVENT_FOREVER. This function can't be used in ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>handle of event to wait </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>number of ticks to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled, otherwise OS_EVENT_NOT_SIGNALED </dd></dl>

</div>
</div>
<a id="ga7be2de0540f21bc4b6b909fa672fb325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be2de0540f21bc4b6b909fa672fb325">&#9670;&nbsp;</a></span>OS_EVENT_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">higherPriorityTaskWoken</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">                (void)<a class="code" href="group___m_i_d___r_t_o___o_s_a_l.html#ga7be2de0540f21bc4b6b909fa672fb325">OS_EVENT_YIELD</a>; \</div>
<div class="line">                if (higherPriorityTaskWoken != <a class="code" href="group___m_i_d___r_t_o___o_s_a_l.html#ga5e0edee36263795a0a1f30658d4c8a3f">OS_FALSE</a>) { \</div>
<div class="line">                        OS_TASK_YIELD_FROM_ISR(); \</div>
<div class="line">                } \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>The running OS task yields control to the scheduler from ISR. </p>
<p>Function requests a context switch to another OS task. This function is safe to call from ISR.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>This macro is deprecated. User shall use OS_TASK_YIELD_FROM_ISR instead</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga558b8294bd6f926b449e6c0343160218" title="The running OS task yields control to the scheduler from ISR.">OS_TASK_YIELD_FROM_ISR</a> </dd></dl>

</div>
</div>
<a id="gabbd363022ea0bfcadacf515b2e34985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbd363022ea0bfcadacf515b2e34985d">&#9670;&nbsp;</a></span>OS_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_FREE(addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated by <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap.">OS_MALLOC()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address of the allocated memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap.">OS_MALLOC</a> </dd></dl>

</div>
</div>
<a id="gae3512d548e2a84afa6fe2a8be6937074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3512d548e2a84afa6fe2a8be6937074">&#9670;&nbsp;</a></span>OS_FREE_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE_FUNC&#160;&#160;&#160;_OS_FREE_FUNC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for OS free memory function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d" title="Free memory allocated by OS_MALLOC()">OS_FREE</a> </dd></dl>

</div>
</div>
<a id="ga3bfdb04b48a504f559e42125fc43186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bfdb04b48a504f559e42125fc43186d">&#9670;&nbsp;</a></span>OS_FREE_NORET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE_NORET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_FREE_NORET(addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated by <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap.">OS_MALLOC_NORET()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address of the allocated memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap.">OS_MALLOC_NORET</a> </dd></dl>

</div>
</div>
<a id="ga3115e8af8ac7eec38217271311ed9d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3115e8af8ac7eec38217271311ed9d34">&#9670;&nbsp;</a></span>OS_FREE_NORET_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE_NORET_FUNC&#160;&#160;&#160;_OS_FREE_NORET_FUNC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for non-retain memory free function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga3bfdb04b48a504f559e42125fc43186d" title="Free memory allocated by OS_MALLOC_NORET()">OS_FREE_NORET</a> </dd>
<dd>
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap.">OS_MALLOC_NORET</a> </dd></dl>

</div>
</div>
<a id="ga6a1a837adbf0d7c4cd6f4c86c5012563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a1a837adbf0d7c4cd6f4c86c5012563">&#9670;&nbsp;</a></span>OS_GET_CURRENT_TASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_CURRENT_TASK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_CURRENT_TASK()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current OS task handle. </p>
<dl class="section return"><dt>Returns</dt><dd>current OS task handle of type OS_TASK </dd></dl>

</div>
</div>
<a id="ga47c1232634084cd90cffd32cfbe29d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c1232634084cd90cffd32cfbe29d9c">&#9670;&nbsp;</a></span>OS_GET_FREE_HEAP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_FREE_HEAP_SIZE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_FREE_HEAP_SIZE()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current free heap size. </p>
<p>Function gets heap current available size.</p>
<dl class="section return"><dt>Returns</dt><dd>current free heap size in bytes </dd></dl>

</div>
</div>
<a id="gaeeb679967456d15afcdd809d587271cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb679967456d15afcdd809d587271cf">&#9670;&nbsp;</a></span>OS_GET_HEAP_STATISTICS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_HEAP_STATISTICS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">results_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_HEAP_STATISTICS(results_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get heap statistics. </p>
<p>Returns a OS_HEAP_STATISTICS_TYPE structure filled with information about the current heap state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results_pointer</td><td>Pointer to memory location where heap statistics data will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f148a5cf9ea2d24b9397ad5e21fe80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f148a5cf9ea2d24b9397ad5e21fe80d">&#9670;&nbsp;</a></span>OS_GET_HEAP_WATERMARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_HEAP_WATERMARK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_HEAP_WATERMARK()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the high water mark of heap. </p>
<p>Function gets the high water mark of heap. That is, the minimum free heap space (in bytes) there has been since heap was initiated.</p>
<dl class="section return"><dt>Returns</dt><dd>heap high water mark in bytes </dd></dl>

</div>
</div>
<a id="ga4e79ac7a74a17fd693d30eadf2d60408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e79ac7a74a17fd693d30eadf2d60408">&#9670;&nbsp;</a></span>OS_GET_IDLE_TASK_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_IDLE_TASK_HANDLE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_IDLE_TASK_HANDLE()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task handle associated with the Idle OS task. </p>
<dl class="section return"><dt>Returns</dt><dd>the task handle associated with the Idle task </dd></dl>

</div>
</div>
<a id="gac79a0b5e1486e4b2af196fb0f61b511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79a0b5e1486e4b2af196fb0f61b511f">&#9670;&nbsp;</a></span>OS_GET_STACK_WATERMARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_STACK_WATERMARK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">                (void)<a class="code" href="group___m_i_d___r_t_o___o_s_a_l.html#gac79a0b5e1486e4b2af196fb0f61b511f">OS_GET_STACK_WATERMARK</a>; \</div>
<div class="line">                OS_GET_TASK_STACK_WATERMARK(task); \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Get the high water mark of the stack associated with an OS task. </p>
<p>Function returns the high water mark of the stack associated with an OS task. That is, the minimum free stack space (in bytes) there has been since the OS task started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of the tracked task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>high water mark of the stack in bytes</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>This macro is deprecated. User shall use OS_GET_TASK_STACK_WATERMARK instead </dd></dl>

</div>
</div>
<a id="gab4193ab92ead15f4344b61bebbc290e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4193ab92ead15f4344b61bebbc290e5">&#9670;&nbsp;</a></span>OS_GET_TASK_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASK_HANDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task_name</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TASK_HANDLE(task_name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task handle by name. </p>
<dl class="section return"><dt>Returns</dt><dd>the task handle that has the name given as value in task_name argument </dd></dl>

</div>
</div>
<a id="ga7200613993969cb9c333a94d390c44b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7200613993969cb9c333a94d390c44b1">&#9670;&nbsp;</a></span>OS_GET_TASK_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASK_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TASK_NAME(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task name. </p>
<p>Function gets OS task name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of the monitored task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string pointer, points to the name of task </dd></dl>

</div>
</div>
<a id="ga83e03daa68eb4b55a02a343178f77199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e03daa68eb4b55a02a343178f77199">&#9670;&nbsp;</a></span>OS_GET_TASK_PRIORITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASK_PRIORITY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TASK_PRIORITY(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task priority. </p>
<p>Function gets OS task priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of the monitored task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the task priority </dd></dl>

</div>
</div>
<a id="gabbb673b570c7489cc7f2f1dd6a632e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb673b570c7489cc7f2f1dd6a632e15">&#9670;&nbsp;</a></span>OS_GET_TASK_STACK_WATERMARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASK_STACK_WATERMARK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TASK_STACK_WATERMARK(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the high water mark of the stack associated with an OS task. </p>
<p>Function returns the high water mark of the stack associated with an OS task. That is, the minimum free stack space (in bytes) there has been since the OS task started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of the tracked task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>high water mark of the stack in bytes </dd></dl>

</div>
</div>
<a id="ga793e6aa2e8283030295e8e0a809d77c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga793e6aa2e8283030295e8e0a809d77c4">&#9670;&nbsp;</a></span>OS_GET_TASK_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASK_STATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TASK_STATE(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task state. </p>
<p>Function gets OS task state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of the monitored task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the task state in OS_TASK_STATE </dd></dl>

</div>
</div>
<a id="ga48f60f4f66eeaf11537490392f33016e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48f60f4f66eeaf11537490392f33016e">&#9670;&nbsp;</a></span>OS_GET_TASKS_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASKS_NUMBER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TASKS_NUMBER()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current number of OS tasks. </p>
<p>Function gets current number of OS tasks.</p>
<dl class="section return"><dt>Returns</dt><dd>the current number of OS tasks </dd></dl>

</div>
</div>
<a id="ga06342422c3b25434d33571af43f6813f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06342422c3b25434d33571af43f6813f">&#9670;&nbsp;</a></span>OS_GET_TASKS_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASKS_STATUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task_status, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">status_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_GET_TASKS_STATUS((task_status), (status_size))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get monitored OS tasks' status. </p>
<p>Function gets the status of the monitored OS tasks in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_status</td><td>where the status of the monitored tasks is stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status_size</td><td>the size of the above container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the monitored tasks </dd></dl>

</div>
</div>
<a id="ga4d74be6b64086261aaa2c50db552c389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d74be6b64086261aaa2c50db552c389">&#9670;&nbsp;</a></span>OS_GET_TICK_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TICK_COUNT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TICK_COUNT()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current OS tick count. </p>
<dl class="section return"><dt>Returns</dt><dd>current tick count </dd></dl>

</div>
</div>
<a id="gadeced1dc0652d4a88f5781ffb28982d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeced1dc0652d4a88f5781ffb28982d6">&#9670;&nbsp;</a></span>OS_GET_TICK_COUNT_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TICK_COUNT_FROM_ISR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_GET_TICK_COUNT_FROM_ISR()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current OS tick count from ISR. </p>
<p>Version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4d74be6b64086261aaa2c50db552c389" title="Get current OS tick count.">OS_GET_TICK_COUNT()</a> that can be called from an interrupt service routine.</p>
<dl class="section return"><dt>Returns</dt><dd>current tick count</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4d74be6b64086261aaa2c50db552c389" title="Get current OS tick count.">OS_GET_TICK_COUNT</a> </dd></dl>

</div>
</div>
<a id="ga2efbc6587b1537847833b16eb891b75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2efbc6587b1537847833b16eb891b75d">&#9670;&nbsp;</a></span>OS_LEAVE_CRITICAL_SECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_LEAVE_CRITICAL_SECTION</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_LEAVE_CRITICAL_SECTION()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave critical section from non-ISR context. </p>
<p>Function restores interrupts and OS task switching. Number of calls to this function must match number of calls to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga597975f3d5d3682d317e275b1881a240" title="Enter critical section from non-ISR context.">OS_ENTER_CRITICAL_SECTION()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga597975f3d5d3682d317e275b1881a240" title="Enter critical section from non-ISR context.">OS_ENTER_CRITICAL_SECTION</a> </dd></dl>

</div>
</div>
<a id="ga60d0538b2257bcb83fc1739e8da3c22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60d0538b2257bcb83fc1739e8da3c22b">&#9670;&nbsp;</a></span>OS_LEAVE_CRITICAL_SECTION_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_LEAVE_CRITICAL_SECTION_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">critical_section_status</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_LEAVE_CRITICAL_SECTION_FROM_ISR(critical_section_status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave critical section from ISR context. </p>
<p>Function restores interrupts from ISR context. Number of calls to this function must match number of calls to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga256b0f34e297c21d9f66ff09df7d8db9" title="Enter critical section from ISR context.">OS_ENTER_CRITICAL_SECTION_FROM_ISR()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga256b0f34e297c21d9f66ff09df7d8db9" title="Enter critical section from ISR context.">OS_ENTER_CRITICAL_SECTION_FROM_ISR</a> </dd></dl>

</div>
</div>
<a id="gac1765b1b6fb9f9e7f550dfb671637f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1765b1b6fb9f9e7f550dfb671637f0c">&#9670;&nbsp;</a></span>OS_MALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MALLOC(size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory from OS provided heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of memory to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d" title="Free memory allocated by OS_MALLOC()">OS_FREE</a> </dd></dl>

</div>
</div>
<a id="gae013d6d0b27ad84dc89024c5dd827b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae013d6d0b27ad84dc89024c5dd827b0b">&#9670;&nbsp;</a></span>OS_MALLOC_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_FUNC&#160;&#160;&#160;_OS_MALLOC_FUNC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for OS memory allocation function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap.">OS_MALLOC</a> </dd></dl>

</div>
</div>
<a id="gaa518cdd7ba27ea28b30ed4e2e2d59a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa518cdd7ba27ea28b30ed4e2e2d59a5d">&#9670;&nbsp;</a></span>OS_MALLOC_NORET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_NORET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MALLOC_NORET(size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory from non-retain heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of memory to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d" title="Free memory allocated by OS_MALLOC()">OS_FREE</a> </dd></dl>

</div>
</div>
<a id="ga21743caf8af2c722bdd8a670192f8881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21743caf8af2c722bdd8a670192f8881">&#9670;&nbsp;</a></span>OS_MALLOC_NORET_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_NORET_FUNC&#160;&#160;&#160;_OS_MALLOC_NORET_FUNC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for non-retain memory allocation function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b" title="Name for OS memory allocation function.">OS_MALLOC_FUNC</a> </dd></dl>

</div>
</div>
<a id="gadb682982f7f1c6fa9b75c07d368b2c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb682982f7f1c6fa9b75c07d368b2c6a">&#9670;&nbsp;</a></span>OS_MINIMAL_TASK_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MINIMAL_TASK_STACK_SIZE&#160;&#160;&#160;_OS_MINIMAL_TASK_STACK_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimal stack size (in bytes) defined for an OS task. </p>
<p>This macro defines the minimal stack size that can be defined for an OS task. The value must be such, so that idle OS task and timer daemon OS task can run. </p>

</div>
</div>
<a id="gaede42a5688918815691a6e6636ace839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaede42a5688918815691a6e6636ace839">&#9670;&nbsp;</a></span>OS_MS_2_TICKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MS_2_TICKS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ms</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MS_2_TICKS(ms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from ms to OS ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>milliseconds to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value in OS ticks </dd></dl>

</div>
</div>
<a id="ga112a446b2367e0a86ea65e17b7b001ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112a446b2367e0a86ea65e17b7b001ea">&#9670;&nbsp;</a></span>OS_MUTEX_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_CREATE(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS mutex. </p>
<p>Function creates OS mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>mutex handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_MUTEX_CREATE_SUCCESS when mutex was created successfully, OS_MUTEX_CREATE_FAIL otherwise </dd></dl>

</div>
</div>
<a id="gaa5893744c78917098de907860aebf782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5893744c78917098de907860aebf782">&#9670;&nbsp;</a></span>OS_MUTEX_CREATE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_CREATE_FAILED&#160;&#160;&#160;((void)OS_MUTEX_CREATE_FAILED,  <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga5c295a966bce5d380ff8444dc55f36f8">OS_MUTEX_CREATE_FAIL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex failed to be created. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Use OS_MUTEX_CREATE_FAIL instead </dd></dl>

</div>
</div>
<a id="ga7fbc523417b45470fffc0c5b009361b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fbc523417b45470fffc0c5b009361b7">&#9670;&nbsp;</a></span>OS_MUTEX_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_DELETE(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS mutex. </p>
<p>Function deletes OS mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga103665ce82345a6d67cf3b1b68fbcaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga103665ce82345a6d67cf3b1b68fbcaaa">&#9670;&nbsp;</a></span>OS_MUTEX_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_MUTEX_GET((mutex), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire OS mutex. </p>
<p>Access to shared resource can be guarded by OS mutex. When OS task wants to get access to this resource, call <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga103665ce82345a6d67cf3b1b68fbcaaa" title="Acquire OS mutex.">OS_MUTEX_GET()</a>. If mutex was not taken by any OS task yet, call will succeed and OS mutex will be assigned to calling OS task. Next call to already acquired OS mutex from same OS task will succeed. If OS mutex is already taken by other OS task, calling task will wait for specified time before failing. For non-blocking acquire <code>timeout</code> can be OS_MUTEX_NO_WAIT, for infinite wait till OS mutex is released OS_MUTEX_FOREVER should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex to acquire </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>number of ticks that to acquire mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga394961eb4773a92e659031b39cb357bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga394961eb4773a92e659031b39cb357bc">&#9670;&nbsp;</a></span>OS_MUTEX_GET_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_GET_COUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_GET_COUNT(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS mutex current count value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mutex current count value </dd></dl>

</div>
</div>
<a id="ga20d86269cdcaac3f6df08af7292849ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d86269cdcaac3f6df08af7292849ef">&#9670;&nbsp;</a></span>OS_MUTEX_GET_COUNT_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_GET_COUNT_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_GET_COUNT_FROM_ISR(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS mutex current count value from ISR. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga394961eb4773a92e659031b39cb357bc" title="Get OS mutex current count value.">OS_MUTEX_GET_COUNT()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mutex current count value</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga394961eb4773a92e659031b39cb357bc" title="Get OS mutex current count value.">OS_MUTEX_GET_COUNT</a> </dd></dl>

</div>
</div>
<a id="ga4324b015038dbaf8fcbdb1397633b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4324b015038dbaf8fcbdb1397633b516">&#9670;&nbsp;</a></span>OS_MUTEX_GET_OWNER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_GET_OWNER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_GET_OWNER(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task owner of OS mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS task owner of mutex </dd></dl>

</div>
</div>
<a id="ga3cd80ffd9b133985609826b40806571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd80ffd9b133985609826b40806571e">&#9670;&nbsp;</a></span>OS_MUTEX_GET_OWNER_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_GET_OWNER_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_GET_OWNER_FROM_ISR(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS task owner of OS mutex from ISR. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4324b015038dbaf8fcbdb1397633b516" title="Get OS task owner of OS mutex.">OS_MUTEX_GET_OWNER()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS task owner of mutex</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga4324b015038dbaf8fcbdb1397633b516" title="Get OS task owner of OS mutex.">OS_MUTEX_GET_OWNER</a> </dd></dl>

</div>
</div>
<a id="ga28f4dfba771ddb5c78b2e9cad9516258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f4dfba771ddb5c78b2e9cad9516258">&#9670;&nbsp;</a></span>OS_MUTEX_PUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_PUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_MUTEX_PUT(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release OS mutex. </p>
<p>Decrease OS mutex count, and when number of calls to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga103665ce82345a6d67cf3b1b68fbcaaa" title="Acquire OS mutex.">OS_MUTEX_GET()</a> equals number of calls to <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga28f4dfba771ddb5c78b2e9cad9516258" title="Release OS mutex.">OS_MUTEX_PUT()</a>, OS mutex can be acquired by other OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>handle of mutex to release</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga103665ce82345a6d67cf3b1b68fbcaaa" title="Acquire OS mutex.">OS_MUTEX_GET</a> </dd></dl>

</div>
</div>
<a id="ga8ff8327f2bc3495792a7b4f1beafecc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ff8327f2bc3495792a7b4f1beafecc9">&#9670;&nbsp;</a></span>OS_PERIOD_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_PERIOD_MS&#160;&#160;&#160;((void)OS_PERIOD_MS,            <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2d9c4c46f8f9ff59d4f28571bbe30471">OS_TICK_PERIOD_MS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS tick period (in msec) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>This macro is deprecated. Use OS_TICK_PERIOD_MS instead </dd></dl>

</div>
</div>
<a id="ga3c00e69676964fd026dd76b5da06ad0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c00e69676964fd026dd76b5da06ad0f">&#9670;&nbsp;</a></span>OS_PRECONDITION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_PRECONDITION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_PRECONDITION(cond)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS precondition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>conditional expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc8b7bdb6581ede712d825f092ad00ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc8b7bdb6581ede712d825f092ad00ea">&#9670;&nbsp;</a></span>OS_QUEUE_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_items&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_CREATE((queue), (item_size), (max_items))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS queue. </p>
<p>Function creates OS queue that can contain <code>max_items</code> of specified size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue</td><td>handle of queue to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>queue element size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_items</td><td>max number of items that queue can store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab4125555127d460161078ddd93b4925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4125555127d460161078ddd93b4925">&#9670;&nbsp;</a></span>OS_QUEUE_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_QUEUE_DELETE(queue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes OS queue. </p>
<p>Function deletes OS queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga734ae4efa9b0f0648e46d68b39ae9639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga734ae4efa9b0f0648e46d68b39ae9639">&#9670;&nbsp;</a></span>OS_QUEUE_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_GET((queue), (item), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get element from OS queue. </p>
<p>Function gets element from OS queue and removes it. If there is nothing in OS queue for <code>timeout</code> ticks error is returned. Use OS_QUEUE_NO_WAIT for <code>timeout</code> to get message without waiting. Use OS_QUEUE_FOREVER to wait till message arrives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to get item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait for element in queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if element was received from queue </dd></dl>

</div>
</div>
<a id="ga32ec2dfb3ed339dee4a6ddde7abc9b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32ec2dfb3ed339dee4a6ddde7abc9b78">&#9670;&nbsp;</a></span>OS_QUEUE_GET_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_GET_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_GET_FROM_ISR((queue), (item))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get element from OS queue from ISR. </p>
<p>Function gets element from OS queue and removes it. If there is nothing in OS queue, indication that OS queue is empty is returned immediately.</p>
<p>This is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to get item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if element was received from queue </dd></dl>

</div>
</div>
<a id="ga42ba9e71bc082e604b2dc4c3427b9a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ba9e71bc082e604b2dc4c3427b9a97">&#9670;&nbsp;</a></span>OS_QUEUE_GET_FROM_ISR_NO_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_GET_FROM_ISR_NO_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">need_yield&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_GET_FROM_ISR_NO_YIELD((queue), (item), (need_yield))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get element from OS queue from ISR without requesting running OS task to yield. </p>
<p>Function gets element from OS queue and removes it. If there is nothing in OS queue, indication that OS queue is empty is returned immediately.</p>
<p>This is safe to call from ISR, without requesting current OS task to yield.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to get item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">need_yield</td><td>indication whether task yield is needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if element was received from queue </dd></dl>

</div>
</div>
<a id="gacafe3e9f66d7afc396337a95b55eea8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacafe3e9f66d7afc396337a95b55eea8b">&#9670;&nbsp;</a></span>OS_QUEUE_MESSAGES_WAITING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_MESSAGES_WAITING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_QUEUE_MESSAGES_WAITING(queue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of messages stored in OS queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of the queue to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of messages available in the queue </dd></dl>

</div>
</div>
<a id="ga88b257cb9c9c1930e985cd16d24f93e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b257cb9c9c1930e985cd16d24f93e3">&#9670;&nbsp;</a></span>OS_QUEUE_MESSAGES_WAITING_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_MESSAGES_WAITING_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_QUEUE_MESSAGES_WAITING_FROM_ISR(queue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of messages stored in OS queue from ISR. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gacafe3e9f66d7afc396337a95b55eea8b" title="Get the number of messages stored in OS queue.">OS_QUEUE_MESSAGES_WAITING()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of the queue to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of messages available in the queue</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gacafe3e9f66d7afc396337a95b55eea8b" title="Get the number of messages stored in OS queue.">OS_QUEUE_MESSAGES_WAITING</a> </dd></dl>

</div>
</div>
<a id="gab1631dad9eb268f390e158cff9036ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1631dad9eb268f390e158cff9036ea3">&#9670;&nbsp;</a></span>OS_QUEUE_PEEK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PEEK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_PEEK((queue), (item), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek element from OS queue. </p>
<p>Function gets element from OS queue without removing it. If there is nothing in OS queue for <code>timeout</code> ticks error is returned. Use OS_QUEUE_NO_WAIT for <code>timeout</code> to get message without waiting. Use OS_QUEUE_FOREVER to wait till message arrives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to peek item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait for element in queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if element was received from queue </dd></dl>

</div>
</div>
<a id="ga0429cf73ac5731e7098876af50c61abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0429cf73ac5731e7098876af50c61abf">&#9670;&nbsp;</a></span>OS_QUEUE_PEEK_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PEEK_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_PEEK_FROM_ISR((queue), (item))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek element from OS queue from ISR. </p>
<p>Function gets element from OS queue without removing it. If there is nothing in OS queue, indication that OS queue is empty is returned immediately.</p>
<p>This is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to peek item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if element was received from queue </dd></dl>

</div>
</div>
<a id="ga28eb0095f405f4a77b70afcb798b6fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28eb0095f405f4a77b70afcb798b6fcd">&#9670;&nbsp;</a></span>OS_QUEUE_PUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_PUT((queue), (item), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put element in OS queue. </p>
<p>Function adds element into OS queue if there is enough room for it. If there is no room in OS queue for <code>timeout</code> ticks element is not put in OS queue and error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait for space in queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_FULL if there was no place in queue OS_QUEUE_OK if message was put in queue </dd></dl>

</div>
</div>
<a id="gadee5f52a66b92c1ee3500a92afb3ea2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadee5f52a66b92c1ee3500a92afb3ea2b">&#9670;&nbsp;</a></span>OS_QUEUE_PUT_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PUT_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_PUT_FROM_ISR((queue), (item))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put element in OS queue. </p>
<p>Function adds element into OS queue if there is enough room for it. If there is no room in OS queue error is returned immediately.</p>
<p>This is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_FULL if there was no place in queue OS_QUEUE_OK if message was put in queue </dd></dl>

</div>
</div>
<a id="gaa001111f406c95c559ecbdcbf8be9b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa001111f406c95c559ecbdcbf8be9b17">&#9670;&nbsp;</a></span>OS_QUEUE_REPLACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_REPLACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_REPLACE((queue), (item))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace element in OS queue of one element. </p>
<p>Function adds element into OS queue if it is empty. If OS queue is not empty, the element is replaced/overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_OK is always returned</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Macro is intended for use with queues that have a length of one, meaning the queue is either empty or full. </dd></dl>

</div>
</div>
<a id="ga8e7fb5e46bc81cadcd80fae41ad9b52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e7fb5e46bc81cadcd80fae41ad9b52f">&#9670;&nbsp;</a></span>OS_QUEUE_REPLACE_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_REPLACE_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_REPLACE_FROM_ISR((queue), (item))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace element in OS queue of one element from ISR. </p>
<p>Function adds element into OS queue if it is empty. If OS queue is not empty, the element is replaced/overwritten.</p>
<p>This is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_OK is always returned</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Macro is intended for use with queues that have a length of one, meaning the queue is either empty or full. </dd></dl>

</div>
</div>
<a id="gaa35c66dc5b578e61df935d4fcc770836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa35c66dc5b578e61df935d4fcc770836">&#9670;&nbsp;</a></span>OS_QUEUE_REPLACE_FROM_ISR_NO_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_REPLACE_FROM_ISR_NO_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">need_yield&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_QUEUE_REPLACE_FROM_ISR_NO_YIELD((queue), (item), (need_yield))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace element in OS queue of one element from ISR without requesting running OS task to yield. </p>
<p>Function adds element into OS queue if it is empty. If OS queue is not empty, the element is replaced/overwritten.</p>
<p>This is safe to call from ISR, without requesting current OS task to yield.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">need_yield</td><td>indication whether task yield is needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_OK is always returned</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Macro is intended for use with queues that have a length of one, meaning the queue is either empty or full. </dd></dl>

</div>
</div>
<a id="ga84d8088ae8c9f2ead6cda61d5ca0d9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d8088ae8c9f2ead6cda61d5ca0d9bd">&#9670;&nbsp;</a></span>OS_QUEUE_SPACES_AVAILABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_SPACES_AVAILABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_QUEUE_SPACES_AVAILABLE(queue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of free spaces in OS queue. </p>
<p>Function gets the number of free spaces in OS queue, that is the number of items that can be sent to OS queue before OS queue becomes full if no items are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>handle of the queue to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of free spaces available in the queue </dd></dl>

</div>
</div>
<a id="gad3ce1872c7a1497b5507babaf3be07cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ce1872c7a1497b5507babaf3be07cd">&#9670;&nbsp;</a></span>OS_SYS_POST_IDLE_PROCESSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_SYS_POST_IDLE_PROCESSING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sleep_period</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_SYS_POST_IDLE_PROCESSING(sleep_period)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform processing after system exiting idle state. </p>
<p>Function performs processing after system exiting idle state. This function is called only by the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sleep_period</td><td>sleep period in cycles of source clock used for the OS timer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If OS_SYS_POST_IDLE_PROCESSING is already defined, it is application responsibility to call also _OS_SYS_POST_IDLE_PROCESSING function since it may be needed by the OS. </dd></dl>

</div>
</div>
<a id="gae6955bdf43c8301d4a9942c2db9b0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6955bdf43c8301d4a9942c2db9b0681">&#9670;&nbsp;</a></span>OS_SYS_POST_SLEEP_PROCESSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_SYS_POST_SLEEP_PROCESSING</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_SYS_POST_SLEEP_PROCESSING()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform processing after system waking-up. </p>
<p>Function performs processing after system waking-up. This function is called only by the system.</p>
<dl class="section note"><dt>Note</dt><dd>If OS_SYS_POST_SLEEP_PROCESSING is already defined, it is application responsibility to call also _OS_SYS_POST_SLEEP_PROCESSING function since it may be needed by the OS. </dd></dl>

</div>
</div>
<a id="ga1d53a1a4593c1af5f43f0bab5991b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d53a1a4593c1af5f43f0bab5991b2b4">&#9670;&nbsp;</a></span>OS_SYS_PRE_IDLE_PROCESSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_SYS_PRE_IDLE_PROCESSING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sleep_period</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_SYS_PRE_IDLE_PROCESSING(sleep_period)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform processing prior to system entering idle state. </p>
<p>Function performs processing prior to system entering idle state. This function is called only by the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sleep_period</td><td>sleep period in cycles of source clock used for the OS timer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If OS_SYS_PRE_IDLE_PROCESSING is already defined, it is application responsibility to call also _OS_SYS_PRE_IDLE_PROCESSING function since it may be needed by the OS. </dd></dl>

</div>
</div>
<a id="gaef5d857ce3e79bd3ebfb6d52447667d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5d857ce3e79bd3ebfb6d52447667d5">&#9670;&nbsp;</a></span>OS_SYS_PRE_SLEEP_PROCESSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_SYS_PRE_SLEEP_PROCESSING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sleep_period</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_SYS_PRE_SLEEP_PROCESSING(sleep_period)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform processing prior to system entering sleep. </p>
<p>Function performs processing prior to system entering sleep. This function is called only by the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sleep_period</td><td>sleep period in cycles of source clock used for the OS timer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If OS_SYS_PRE_SLEEP_PROCESSING is already defined, it is application responsibility to call also _OS_SYS_PRE_SLEEP_PROCESSING function since it may be needed by the OS.</dd>
<dd>
Adding application code by defining <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaef5d857ce3e79bd3ebfb6d52447667d5" title="Perform processing prior to system entering sleep.">OS_SYS_PRE_SLEEP_PROCESSING()</a> will have an impact on minimum sleep time, as implied by dg_configMIN_SLEEP_TIME.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___s_e_t_t_i_n_g_s.html#gad506b11fe8c9feacbfcadf539e622d8c" title="Minimum sleep time.">dg_configMIN_SLEEP_TIME</a> </dd></dl>

</div>
</div>
<a id="ga73e3e255bd2d3f3e872cb27426010e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e3e255bd2d3f3e872cb27426010e62">&#9670;&nbsp;</a></span>OS_SYS_PRE_STOP_PROCESSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_SYS_PRE_STOP_PROCESSING</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_SYS_PRE_STOP_PROCESSING()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform processing prior to system stopping (e.g. entering hibernation) </p>
<p>Function performs processing prior to system stopping (e.g. entering hibernation). This function is called only by the system.</p>
<dl class="section note"><dt>Note</dt><dd>If OS_SYS_PRE_STOP_PROCESSING is already defined, it is application responsibility to call also _OS_SYS_PRE_STOP_PROCESSING function since it may be needed by the OS. </dd></dl>

</div>
</div>
<a id="gaf506bff5b51e8404ab109eb2a30c2682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf506bff5b51e8404ab109eb2a30c2682">&#9670;&nbsp;</a></span>OS_TASK_ARG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_ARG_TYPE&#160;&#160;&#160;_OS_TASK_ARG_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type of OS task function (i.e. OS_TASK_FUNCTION) argument. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga914bc8dfdd39ca3b9caecb795ae583d7" title="Declare an OS task function.">OS_TASK_FUNCTION</a> </dd></dl>

</div>
</div>
<a id="gaf2a5564afaf810733986c2326a323be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a5564afaf810733986c2326a323be2">&#9670;&nbsp;</a></span>OS_TASK_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task_func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stack_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">priority, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_OS_TASK_CREATE((name), (task_func), (<a class="code" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf506bff5b51e8404ab109eb2a30c2682">OS_TASK_ARG_TYPE</a>)(arg), \</div>
<div class="line">                         <a class="code" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gafa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(stack_size + <a class="code" href="group___s_y_s_t_e_m___v_i_e_w.html#ga6157a4519e88c40dc4d3aa7b9893d160">dg_configSYSTEMVIEW_STACK_OVERHEAD</a>, <a class="code" href="group___m_i_d___r_t_o___o_s_a_l.html#gadb682982f7f1c6fa9b75c07d368b2c6a">OS_MINIMAL_TASK_STACK_SIZE</a> ) , \</div>
<div class="line">                        (priority), (task))</div>
</div><!-- fragment -->
<p>Create OS task. </p>
<p>Function creates OS task. OS task is ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>task name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_func</td><td>starting point of task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>parameter past to <code>task_func</code> on task start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>stack size allocated for task in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>number specifying task priority </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>OS specific task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_CREATE_SUCCESS if task was created successfully </dd></dl>

</div>
</div>
<a id="ga24a73ccb253999f6d79b6985c097fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a73ccb253999f6d79b6985c097fb4e">&#9670;&nbsp;</a></span>OS_TASK_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_DELETE(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS task. </p>
<p>Function deletes OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>OS specific task handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga914bc8dfdd39ca3b9caecb795ae583d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga914bc8dfdd39ca3b9caecb795ae583d7">&#9670;&nbsp;</a></span>OS_TASK_FUNCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_FUNCTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_FUNCTION(func, arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare an OS task function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>name of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>function argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00f2215f0acf1afbe553051eda1972f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00f2215f0acf1afbe553051eda1972f2">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY((task), (value), (action))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task, updating its notification value. </p>
<p>Must not be called from ISR!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a id="gaf5eac367a1d83149f77bf4cd28d6a93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5eac367a1d83149f77bf4cd28d6a93e">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_AND_QUERY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_AND_QUERY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prev_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY((task), (value), (action), (prev_value))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task, updating its notification value and returning previous value. </p>
<p>Must not be called from ISR!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_value</td><td>pointer to previous notification value - optional - can be set to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a id="gafcd241bf5e92f687315264e75fbe6d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd241bf5e92f687315264e75fbe6d84">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_AND_QUERY_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_AND_QUERY_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prev_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY_FROM_ISR((task), (value), (action), (prev_value))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task from ISR, updating its notification value and returning previous value. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf5eac367a1d83149f77bf4cd28d6a93e" title="Send notification to OS task, updating its notification value and returning previous value.">OS_TASK_NOTIFY_AND_QUERY()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_value</td><td>pointer to previous notification value - optional - can be set to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf5eac367a1d83149f77bf4cd28d6a93e" title="Send notification to OS task, updating its notification value and returning previous value.">OS_TASK_NOTIFY_AND_QUERY</a> </dd></dl>

</div>
</div>
<a id="ga8d92c8db6703066f78d0cc3a83635b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d92c8db6703066f78d0cc3a83635b8f">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_AND_QUERY_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_AND_QUERY_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prev_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY_INDEXED((task), (index), (value), (action), (prev_value))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task, updating a notification index value and returning previous value. </p>
<p>Must not be called from ISR!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_value</td><td>pointer to previous notification value - optional - can be set to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a id="ga87cf5f0d1af9f206309244c360aba310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87cf5f0d1af9f206309244c360aba310">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_AND_QUERY_INDEXED_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_AND_QUERY_INDEXED_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prev_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_AND_QUERY_INDEXED_FROM_ISR((task), (index), (value), (action), (prev_value))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task from ISR, updating a notification index value and returning previous value. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8d92c8db6703066f78d0cc3a83635b8f" title="Send notification to OS task, updating a notification index value and returning previous value.">OS_TASK_NOTIFY_AND_QUERY_INDEXED()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_value</td><td>pointer to previous notification value - optional - can be set to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8d92c8db6703066f78d0cc3a83635b8f" title="Send notification to OS task, updating a notification index value and returning previous value.">OS_TASK_NOTIFY_AND_QUERY_INDEXED</a> </dd></dl>

</div>
</div>
<a id="ga41c0bb07f14dea53797a0a922d27dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c0bb07f14dea53797a0a922d27dbdc">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_FROM_ISR((task), (value), (action))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task from ISR, updating its notification value. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga00f2215f0acf1afbe553051eda1972f2" title="Send notification to OS task, updating its notification value.">OS_TASK_NOTIFY()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga00f2215f0acf1afbe553051eda1972f2" title="Send notification to OS task, updating its notification value.">OS_TASK_NOTIFY</a> </dd></dl>

</div>
</div>
<a id="ga922cdffae7bfcabc3e3a29e2521365b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga922cdffae7bfcabc3e3a29e2521365b4">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_GIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_GIVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a notification event to OS task, incrementing its notification value. </p>
<p>Must not be called from ISR! Use <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga073a550e64dbb4b8b4acfd9c83370775" title="Send a notification event to OS task from ISR, incrementing its notification value.">OS_TASK_NOTIFY_GIVE_FROM_ISR()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_GIVE calls OS_TASK_NOTIFY with action set to OS_NOTIFY_INCREMENT resulting in all calls returning OS_TASK_NOTIFY_SUCCESS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga073a550e64dbb4b8b4acfd9c83370775" title="Send a notification event to OS task from ISR, incrementing its notification value.">OS_TASK_NOTIFY_GIVE_FROM_ISR</a> </dd></dl>

</div>
</div>
<a id="ga073a550e64dbb4b8b4acfd9c83370775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073a550e64dbb4b8b4acfd9c83370775">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_GIVE_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_GIVE_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE_FROM_ISR(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a notification event to OS task from ISR, incrementing its notification value. </p>
<p>Send notification event from interrupt service routine (ISR) to OS task that can unblock the receiving OS task, incrementing the receiving OS task's notification value. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79f3cea689385669347d3cc0cd3be330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79f3cea689385669347d3cc0cd3be330">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_GIVE_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_GIVE_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE_INDEXED((task), (index))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a notification event to OS task, incrementing a notification index value. </p>
<p>Must not be called from ISR! Use <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga073a550e64dbb4b8b4acfd9c83370775" title="Send a notification event to OS task from ISR, incrementing its notification value.">OS_TASK_NOTIFY_GIVE_FROM_ISR()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_GIVE calls OS_TASK_NOTIFY with action set to OS_NOTIFY_INCREMENT resulting in all calls returning OS_TASK_NOTIFY_SUCCESS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga1fb236aaa2b6d31cfb8b94b1dbf031b0" title="Send a notification event to OS task from ISR, incrementing a notification index value.">OS_TASK_NOTIFY_GIVE_INDEXED_FROM_ISR</a> </dd></dl>

</div>
</div>
<a id="ga1fb236aaa2b6d31cfb8b94b1dbf031b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fb236aaa2b6d31cfb8b94b1dbf031b0">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_GIVE_INDEXED_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_GIVE_INDEXED_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_GIVE_INDEXED_FROM_ISR((task), (index))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a notification event to OS task from ISR, incrementing a notification index value. </p>
<p>Send notification event from interrupt service routine (ISR) to OS task that can unblock the receiving OS task, incrementing the receiving OS task's notification value. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86995eac646484de40bc613d650aad5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86995eac646484de40bc613d650aad5e">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_INDEXED((task), (index), (value), (action))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task, updating one notification index value. </p>
<p>Must not be called from ISR!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a id="ga7630f7b69c9971fd3a8df91f065a92d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7630f7b69c9971fd3a8df91f065a92d3">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_INDEXED_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_INDEXED_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_INDEXED_FROM_ISR((task), (index), (value), (action))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send notification to OS task from ISR, updating a notification index value. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga86995eac646484de40bc613d650aad5e" title="Send notification to OS task, updating one notification index value.">OS_TASK_NOTIFY_INDEXED()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred (OS_NOTIFY_ACTION)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga86995eac646484de40bc613d650aad5e" title="Send notification to OS task, updating one notification index value.">OS_TASK_NOTIFY_INDEXED</a> </dd></dl>

</div>
</div>
<a id="gae0a86269604f9ac15d5330e831bec448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a86269604f9ac15d5330e831bec448">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_STATE_CLEAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_STATE_CLEAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_NOTIFY_STATE_CLEAR(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the notification state of an OS task. </p>
<p>This function will clear the notification value of an OS task</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task. Set to NULL to clear the notification state of the calling task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
OS_TASK_NOTIFY_SUCCESS if the task's notification state was set to eNotWaitingNotification, otherwise OS_TASK_NOTIFY_FAIL. </dd></dl>

</div>
</div>
<a id="ga06c972de35e501963cd037ae79f80770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c972de35e501963cd037ae79f80770">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_STATE_CLEAR_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_STATE_CLEAR_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_STATE_CLEAR_INDEXED((task), (index))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a notification index state of an OS task. </p>
<p>This function will clear the value of one entry in the notification array of an OS task</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task. Set to NULL to clear the notification state of the calling task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification value that will be cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
OS_TASK_NOTIFY_SUCCESS if the task's notification state was set to eNotWaitingNotification, otherwise OS_TASK_NOTIFY_FAIL. </dd></dl>

</div>
</div>
<a id="gaf7a3bb58bc89af3bb73c75bb4fa8644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a3bb58bc89af3bb73c75bb4fa8644e">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_TAKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_TAKE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clear_on_exit, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time_to_wait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_TAKE((clear_on_exit), (time_to_wait))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task notification value on exit. </p>
<p>This function waits for the calling OS task to receive a notification event and unblocks it if its notification value is equal to zero. OS task notification value is updated for each received notification according to clear_on_exit parameter value passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_on_exit</td><td>= OS_FALSE: task's notification value is decremented before <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task n...">OS_TASK_NOTIFY_TAKE()</a> exits, OS_TRUE: task's notification value is reset to 0 before <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task n...">OS_TASK_NOTIFY_TAKE()</a> exits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_to_wait</td><td>maximum time to wait in the blocked state for a notification event to be received if a notification is not already pending when <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task n...">OS_TASK_NOTIFY_TAKE()</a> is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="gac4fec959f7e36be1ddec7577263ca4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4fec959f7e36be1ddec7577263ca4ed">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_TAKE_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_TAKE_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clear_on_exit, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time_to_wait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_TAKE_INDEXED((index), (clear_on_exit), (time_to_wait))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the calling OS task to receive a notification event, clearing to zero or decrementing a task notification index value on exit. </p>
<p>This function waits for the calling OS task to receive a notification event and unblocks it if its notification value is equal to zero. OS task notification value is updated for each received notification according to clear_on_exit parameter value passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_on_exit</td><td>= OS_FALSE: task's notification value is decremented before <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task n...">OS_TASK_NOTIFY_TAKE()</a> exits, OS_TRUE: task's notification value is reset to 0 before <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task n...">OS_TASK_NOTIFY_TAKE()</a> exits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_to_wait</td><td>maximum time to wait in the blocked state for a notification event to be received if a notification is not already pending when <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Wait for the calling OS task to receive a notification event, clearing to zero or decrementing task n...">OS_TASK_NOTIFY_TAKE()</a> is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="gaa10720bf3b19b56bee2ba64a26e386d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa10720bf3b19b56bee2ba64a26e386d2">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_VALUE_CLEAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_VALUE_CLEAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_clear&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_VALUE_CLEAR((task), (bits_to_clear))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear specific bits in the notification state of an OS task. </p>
<p>This function clears the bits specified in the provided bitmask from the task's notification value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task. Set to NULL to clear the notification state of the calling task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_clear</td><td>bits of the notification value that will be cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the target task's notification value before the specified bits were cleared. </dd></dl>

</div>
</div>
<a id="ga79db09862be1de33b88733b7cc3fac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79db09862be1de33b88733b7cc3fac71">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_VALUE_CLEAR_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_VALUE_CLEAR_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_clear&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_VALUE_CLEAR_INDEXED((task), (index), (bits_to_clear))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear specific bits in a notification index state of an OS task. </p>
<p>This function clears the bits specified in the provided bitmask from one of the task's notification array values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task. Set to NULL to clear the notification state of the calling task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification value that will be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_clear</td><td>bits of the notification value that will be cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the target task's notification value before the specified bits were cleared. </dd></dl>

</div>
</div>
<a id="gafbdd8702f6b22611d3cc340602a427d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbdd8702f6b22611d3cc340602a427d8">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_WAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exit_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks_to_wait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_WAIT((entry_bits), (exit_bits), (value), (ticks_to_wait))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the calling OS task to receive a notification, updating task notification value on exit. </p>
<p>This function waits for the calling OS task to receive a notification, updating OS task notification value according to entry_bits and exit_bits parameter values passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_bits</td><td>any bits set in entry_bits will be cleared in calling notification value before the task enters to OS_TASK_NOTIFY_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_bits</td><td>any bits set in exit_bits will be cleared in calling notification value before OS_TASK_NOTIFY_WAIT function exits if a notification was received </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>pointer to task's notification value, if not required can be set to NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks_to_wait</td><td>maximum time to wait in the blocked state for a notification to be received if a notification is not already pending when OS_TASK_NOTIFY_WAIT is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_SUCCESS if notification was received or was already pending when OS_TASK_NOTIFY_WAIT was called OS_TASK_NOTIFY_FAIL if the call OS_TASK_NOTIFY_WAIT timed out before notification was received </dd></dl>

</div>
</div>
<a id="gafbd8c032f28cf08f205094e692b9b80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd8c032f28cf08f205094e692b9b80c">&#9670;&nbsp;</a></span>OS_TASK_NOTIFY_WAIT_INDEXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_WAIT_INDEXED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exit_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks_to_wait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_NOTIFY_WAIT_INDEXED((index), (entry_bits), (exit_bits), (value), (ticks_to_wait))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the calling OS task to receive a notification, updating a task notification index value on exit. </p>
<p>This function waits for the calling OS task to receive a notification, updating OS task notification value according to entry_bits and exit_bits parameter values passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the index in the notification array that the notification will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_bits</td><td>any bits set in entry_bits will be cleared in calling notification value before the task enters to OS_TASK_NOTIFY_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_bits</td><td>any bits set in exit_bits will be cleared in calling notification value before OS_TASK_NOTIFY_WAIT function exits if a notification was received </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>pointer to task's notification value, if not required can be set to NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks_to_wait</td><td>maximum time to wait in the blocked state for a notification to be received if a notification is not already pending when OS_TASK_NOTIFY_WAIT is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_SUCCESS if notification was received or was already pending when OS_TASK_NOTIFY_WAIT was called OS_TASK_NOTIFY_FAIL if the call OS_TASK_NOTIFY_WAIT timed out before notification was received </dd></dl>

</div>
</div>
<a id="gabd8dafae5ca6f00ee8ce776ae1212fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8dafae5ca6f00ee8ce776ae1212fd5">&#9670;&nbsp;</a></span>OS_TASK_PRIORITY_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_PRIORITY_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_PRIORITY_GET(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of an OS task. </p>
<p>Function returns the priority of an OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>OS specific task handle. if NULL, the running task is assumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the priority of the task (OS_UBASE_TYPE) </dd></dl>

</div>
</div>
<a id="ga8861b855a72140a44005066c682be830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8861b855a72140a44005066c682be830">&#9670;&nbsp;</a></span>OS_TASK_PRIORITY_GET_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_PRIORITY_GET_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_PRIORITY_GET_FROM_ISR(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of an OS task from ISR. </p>
<p>A version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabd8dafae5ca6f00ee8ce776ae1212fd5" title="Get the priority of an OS task.">OS_TASK_PRIORITY_GET()</a> that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>OS specific task handle. if NULL, the running task is assumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the priority of the task (OS_UBASE_TYPE)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabd8dafae5ca6f00ee8ce776ae1212fd5" title="Get the priority of an OS task.">OS_TASK_PRIORITY_GET</a> </dd></dl>

</div>
</div>
<a id="ga02bb1b8afdd47bf1031e94aceaf19865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bb1b8afdd47bf1031e94aceaf19865">&#9670;&nbsp;</a></span>OS_TASK_PRIORITY_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_PRIORITY_SET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TASK_PRIORITY_SET((task), (prio))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of an OS task. </p>
<p>Function sets the priority of an OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>OS specific task handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>OS new priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac00c9c3498aa76bf2a427f415a2ef5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00c9c3498aa76bf2a427f415a2ef5fa">&#9670;&nbsp;</a></span>OS_TASK_RESUME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_RESUME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_RESUME(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume OS task. </p>
<p>Make OS task ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a4dfac299a63b8d1205d72d7268370b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a4dfac299a63b8d1205d72d7268370b">&#9670;&nbsp;</a></span>OS_TASK_RESUME_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_RESUME_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_RESUME_FROM_ISR(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume OS task from ISR. </p>
<p>Make OS task ready to run. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa84368282a0e802f529f1423988725fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84368282a0e802f529f1423988725fe">&#9670;&nbsp;</a></span>OS_TASK_SUSPEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_SUSPEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_SUSPEND(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend OS task. </p>
<p>Remove OS task from execution queue. OS task will not be run until <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac00c9c3498aa76bf2a427f415a2ef5fa" title="Resume OS task.">OS_TASK_RESUME()</a> or <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2a4dfac299a63b8d1205d72d7268370b" title="Resume OS task from ISR.">OS_TASK_RESUME_FROM_ISR()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>handle of task to suspend</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gac00c9c3498aa76bf2a427f415a2ef5fa" title="Resume OS task.">OS_TASK_RESUME</a> </dd>
<dd>
<a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga2a4dfac299a63b8d1205d72d7268370b" title="Resume OS task from ISR.">OS_TASK_RESUME_FROM_ISR</a> </dd></dl>

</div>
</div>
<a id="ga9b95512f360b2980c30404776efc2a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b95512f360b2980c30404776efc2a21">&#9670;&nbsp;</a></span>OS_TASK_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_YIELD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_YIELD()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The running OS task yields control to the scheduler. </p>
<p>Function requests a context switch to another OS task. </p>

</div>
</div>
<a id="ga558b8294bd6f926b449e6c0343160218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga558b8294bd6f926b449e6c0343160218">&#9670;&nbsp;</a></span>OS_TASK_YIELD_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_YIELD_FROM_ISR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TASK_YIELD_FROM_ISR()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The running OS task yields control to the scheduler from ISR. </p>
<p>Function requests a context switch to another OS task from interrupt service routine (ISR). </p>

</div>
</div>
<a id="ga49f187493e273da8e62ba1bf133b6f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f187493e273da8e62ba1bf133b6f69">&#9670;&nbsp;</a></span>OS_TICK_ADVANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TICK_ADVANCE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TICK_ADVANCE()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance OS tick count. </p>
<p>Function advances OS tick count, updates the list of blocked OS tasks waiting for a specific time period to pass, and triggers context switch, accordingly.</p>
<p>This function is intended for internal use only. </p>

</div>
</div>
<a id="gad93a1a5a9f0c0b914c535e4445565c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93a1a5a9f0c0b914c535e4445565c65">&#9670;&nbsp;</a></span>OS_TICK_INCREMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TICK_INCREMENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TICK_INCREMENT(ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update OS tick count by adding a given number of OS ticks. </p>
<p>Function updates OS tick count by adding a given number of OS ticks after a period during which the system was in sleep or power down mode.</p>
<p>This function is intended for internal use only. </p>

</div>
</div>
<a id="ga6d4773c79590cb37558d7a116bf7bc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4773c79590cb37558d7a116bf7bc90">&#9670;&nbsp;</a></span>OS_TICKS_2_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TICKS_2_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TICKS_2_MS(ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from OS ticks to ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks</td><td>tick count to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value in ms </dd></dl>

</div>
</div>
<a id="ga8a68360ed332a7a45f9a44af68f56ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a68360ed332a7a45f9a44af68f56ac9">&#9670;&nbsp;</a></span>OS_TIME_TO_TICKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIME_TO_TICKS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time_in_ms</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIME_TO_TICKS(time_in_ms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a time in milliseconds to a time in ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_in_ms</td><td>time in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time in ticks </dd></dl>

</div>
</div>
<a id="ga05137e07905384715f65f14a93e0c23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05137e07905384715f65f14a93e0c23e">&#9670;&nbsp;</a></span>OS_TIMER_CHANGE_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_CHANGE_PERIOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">period, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_CHANGE_PERIOD((timer), (period), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change OS timer's period. </p>
<p>Functions updates OS timer's period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>new timer's period </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL if timeout has occured </dd></dl>

</div>
</div>
<a id="gafc3c97a73258c9df80b82bbedaaf76b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3c97a73258c9df80b82bbedaaf76b4">&#9670;&nbsp;</a></span>OS_TIMER_CHANGE_PERIOD_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_CHANGE_PERIOD_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">period&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_CHANGE_PERIOD_FROM_ISR((timer), (period))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change OS timer period from ISR. </p>
<p>Version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga05137e07905384715f65f14a93e0c23e" title="Change OS timer&#39;s period.">OS_TIMER_CHANGE_PERIOD()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>new timer period</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga05137e07905384715f65f14a93e0c23e" title="Change OS timer&#39;s period.">OS_TIMER_CHANGE_PERIOD</a> </dd></dl>

</div>
</div>
<a id="gab3ddcaa3765d3322f6c1a5e48c102c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ddcaa3765d3322f6c1a5e48c102c61">&#9670;&nbsp;</a></span>OS_TIMER_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">period, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reload, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callback&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_CREATE((name), (period), (reload), (timer_id), (callback))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS timer. </p>
<p>Function creates software OS timer with given timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>timer name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>timer period in ticks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reload</td><td>indicates if callback will be called once or multiple times OS_TIMER_RELOAD - the callback will be called multiple times OS_TIMER_ONCE - the callback will be called once </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer_id</td><td>identifier which can be used to identify timer in callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>callback called when timer expires</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the timer if timer created successfully, otherwise NULL </dd></dl>

</div>
</div>
<a id="ga51f2d4705593ca121a18eba61bb4523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f2d4705593ca121a18eba61bb4523f">&#9670;&nbsp;</a></span>OS_TIMER_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_DELETE((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS timer. </p>
<p>Function deletes previously created OS timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL if timeout has occured </dd></dl>

</div>
</div>
<a id="gab68906a872a118cdf7e134eaca42fbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab68906a872a118cdf7e134eaca42fbbf">&#9670;&nbsp;</a></span>OS_TIMER_GET_RELOAD_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_GET_RELOAD_MODE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIMER_GET_RELOAD_MODE(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timer auto-reload mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_RELOAD if timer is set to auto reload after expiration, OS_TIMER_ONCE otherwise </dd></dl>

</div>
</div>
<a id="ga829f2c08546706de27d74f3d94991e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829f2c08546706de27d74f3d94991e32">&#9670;&nbsp;</a></span>OS_TIMER_GET_TIMER_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_GET_TIMER_ID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIMER_GET_TIMER_ID(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS timer ID. </p>
<p>Function returns OS timer id assigned in <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61" title="Create OS timer.">OS_TIMER_CREATE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timer id</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61" title="Create OS timer.">OS_TIMER_CREATE</a> </dd></dl>

</div>
</div>
<a id="ga1566ca04ff8d3c2656777803f54f4d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1566ca04ff8d3c2656777803f54f4d4f">&#9670;&nbsp;</a></span>OS_TIMER_IS_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_IS_ACTIVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIMER_IS_ACTIVE(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if OS timer is active. </p>
<p>Function checks OS timer status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if timer is active, otherwise false </dd></dl>

</div>
</div>
<a id="gaf62357077a12d85bed42f15b88e8c772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf62357077a12d85bed42f15b88e8c772">&#9670;&nbsp;</a></span>OS_TIMER_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_RESET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_RESET((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset OS timer. </p>
<p>Function restarts previously created OS timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL if timeout has occured </dd></dl>

</div>
</div>
<a id="ga435ecbfcbe8996f34ac2e237512c1269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435ecbfcbe8996f34ac2e237512c1269">&#9670;&nbsp;</a></span>OS_TIMER_RESET_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_RESET_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIMER_RESET_FROM_ISR(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset OS timer from ISR. </p>
<p>Version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772" title="Reset OS timer.">OS_TIMER_RESET()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772" title="Reset OS timer.">OS_TIMER_RESET</a> </dd></dl>

</div>
</div>
<a id="ga861400a2111b9d2f80fe2a443abafef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga861400a2111b9d2f80fe2a443abafef8">&#9670;&nbsp;</a></span>OS_TIMER_SET_RELOAD_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_SET_RELOAD_MODE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">auto_reload&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_SET_RELOAD_MODE(timer, auto_reload)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timer auto-reload mode. </p>
<p>Sets timer to auto-reload or oneshot mode. If auto_reload is equal to OS_TIMER_RELOAD, then the timer will reload after it expires. If auto_reload is equal to OS_TIMER_ONCE, then the timer will only expire once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">auto_reload</td><td>automatic reload mode. OS_TIMER_RELOAD sets the timer to auto-reload. OS_TIMER_ONCE sets the timer to expire once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8867349519f1d3d49e90dc71946d2b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8867349519f1d3d49e90dc71946d2b24">&#9670;&nbsp;</a></span>OS_TIMER_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_START</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_START((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start OS timer. </p>
<p>Function starts OS timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL if timeout has occured</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61" title="Create OS timer.">OS_TIMER_CREATE</a> </dd></dl>

</div>
</div>
<a id="ga06fac74ca16c0a48fd92fecc0d414a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fac74ca16c0a48fd92fecc0d414a1e">&#9670;&nbsp;</a></span>OS_TIMER_START_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_START_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIMER_START_FROM_ISR(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start OS timer from ISR. </p>
<p>Version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8867349519f1d3d49e90dc71946d2b24" title="Start OS timer.">OS_TIMER_START()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga8867349519f1d3d49e90dc71946d2b24" title="Start OS timer.">OS_TIMER_START</a> </dd></dl>

</div>
</div>
<a id="gaa365dd8088897672c6831793ab257532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa365dd8088897672c6831793ab257532">&#9670;&nbsp;</a></span>OS_TIMER_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_STOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_OS_TIMER_STOP((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop OS timer. </p>
<p>Function stops OS timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL if timeout has occured</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61" title="Create OS timer.">OS_TIMER_CREATE</a> </dd></dl>

</div>
</div>
<a id="gaca5b4d5fff2947d1806559243e9fcdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5b4d5fff2947d1806559243e9fcdde">&#9670;&nbsp;</a></span>OS_TIMER_STOP_FROM_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_STOP_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;_OS_TIMER_STOP_FROM_ISR(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop OS timer from ISR. </p>
<p>Version of <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa365dd8088897672c6831793ab257532" title="Stop OS timer.">OS_TIMER_STOP()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully OS_TIMER_FAIL otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gaa365dd8088897672c6831793ab257532" title="Stop OS timer.">OS_TIMER_STOP</a> </dd></dl>

</div>
</div>
<a id="gaf02f894fd016f2e3a90d7e7c3d478f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02f894fd016f2e3a90d7e7c3d478f61">&#9670;&nbsp;</a></span>OS_USE_TICKLESS_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_USE_TICKLESS_IDLE&#160;&#160;&#160;_OS_USE_TICKLESS_IDLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable use of low power tickless mode. </p>
<p>If this macro is set to a non-zero value, then the use of OS low power tickless mode is enabled, otherwise the OS tick interrupt is kept running at all times. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga91db83d76f11008246e38e80bfeb24cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91db83d76f11008246e38e80bfeb24cd">&#9670;&nbsp;</a></span>OS_NOTIFY_ACTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga91db83d76f11008246e38e80bfeb24cd">OS_NOTIFY_ACTION</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS task notification action. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga91db83d76f11008246e38e80bfeb24cdacf8af7394792ac07a6fb45b6966322ed"></a>OS_NOTIFY_NO_ACTION&#160;</td><td class="fielddoc"><p>Subject task receives event, but its notification value is not updated </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91db83d76f11008246e38e80bfeb24cda707e11498965fb2a27d28003922eb33a"></a>OS_NOTIFY_SET_BITS&#160;</td><td class="fielddoc"><p>Notification value of subject task will be bitwise ORed with task value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91db83d76f11008246e38e80bfeb24cdadcdfb5913c4529e5673b6c2ae65ab1f3"></a>OS_NOTIFY_INCREMENT&#160;</td><td class="fielddoc"><p>Notification value of subject task will be incremented by one </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91db83d76f11008246e38e80bfeb24cda63b4d57115eb7e18e77dda410c8c8d16"></a>OS_NOTIFY_VAL_WITH_OVERWRITE&#160;</td><td class="fielddoc"><p>Notification value of subject task is unconditionally set to task value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91db83d76f11008246e38e80bfeb24cda4236b135cee8aa0ea383216a2a6600f3"></a>OS_NOTIFY_VAL_WITHOUT_OVERWRITE&#160;</td><td class="fielddoc"><p>If subject task has a notification pending then notification value will be set to task value otherwise task value is not updated </p>
</td></tr>
</table>

</div>
</div>
<a id="ga284ead1d430aeefa5d9cb6fa9417a27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284ead1d430aeefa5d9cb6fa9417a27b">&#9670;&nbsp;</a></span>OS_SCHEDULER_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#ga284ead1d430aeefa5d9cb6fa9417a27b">OS_SCHEDULER_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS scheduler state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga284ead1d430aeefa5d9cb6fa9417a27ba4561b99e50f2a93a679a163c642b7d3c"></a>OS_SCHEDULER_RUNNING&#160;</td><td class="fielddoc"><p>Scheduler is in running state </p>
</td></tr>
<tr><td class="fieldname"><a id="gga284ead1d430aeefa5d9cb6fa9417a27ba306078dd3cf3fb81afb81e3df5322823"></a>OS_SCHEDULER_NOT_STARTED&#160;</td><td class="fielddoc"><p>Scheduler is not started </p>
</td></tr>
<tr><td class="fieldname"><a id="gga284ead1d430aeefa5d9cb6fa9417a27baa4257dfe6a1c7f925748fbe552eee6e1"></a>OS_SCHEDULER_SUSPENDED&#160;</td><td class="fielddoc"><p>Scheduler is in the suspended state </p>
</td></tr>
</table>

</div>
</div>
<a id="gabe06d898bcd0410afc12cd1164cdb658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe06d898bcd0410afc12cd1164cdb658">&#9670;&nbsp;</a></span>OS_TASK_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___m_i_d___r_t_o___o_s_a_l.html#gabe06d898bcd0410afc12cd1164cdb658">OS_TASK_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS task state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabe06d898bcd0410afc12cd1164cdb658ae6721aefc70c2f731dd95976c86e2d08"></a>OS_TASK_RUNNING&#160;</td><td class="fielddoc"><p>Task is in running state, a task is querying the state of itself </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe06d898bcd0410afc12cd1164cdb658a529cd0e1f131f501efe7cc3d1122d002"></a>OS_TASK_READY&#160;</td><td class="fielddoc"><p>Task is in a ready state </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe06d898bcd0410afc12cd1164cdb658a4705e6f6965e05b68e1fd805005f1fed"></a>OS_TASK_BLOCKED&#160;</td><td class="fielddoc"><p>Task is in blocked state </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe06d898bcd0410afc12cd1164cdb658a62ddebcd9f9807614278e7999168ec7e"></a>OS_TASK_SUSPENDED&#160;</td><td class="fielddoc"><p>Task is in the suspended state, or is in the blocked state with an infinite time out </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe06d898bcd0410afc12cd1164cdb658af3928fd43595cf4864252be0d5a0fd27"></a>OS_TASK_DELETED&#160;</td><td class="fielddoc"><p>Task is deleted, but its TCB has not yet been freed </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup___b_s_p___d_e_f_i_n_i_t_i_o_n_s_html_ga6c30d490cd2302ff05d355f3ec844c1f"><div class="ttname"><a href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a></div><div class="ttdeci">#define __UNUSED</div><div class="ttdoc">Attribute to silence warnings about unused parameters/variables/function.</div><div class="ttdef"><b>Definition:</b> sdk_defs.h:405</div></div>
<div class="ttc" id="agroup___m_i_d___r_t_o___o_s_a_l_html_gadb682982f7f1c6fa9b75c07d368b2c6a"><div class="ttname"><a href="group___m_i_d___r_t_o___o_s_a_l.html#gadb682982f7f1c6fa9b75c07d368b2c6a">OS_MINIMAL_TASK_STACK_SIZE</a></div><div class="ttdeci">#define OS_MINIMAL_TASK_STACK_SIZE</div><div class="ttdoc">Minimal stack size (in bytes) defined for an OS task.</div><div class="ttdef"><b>Definition:</b> osal.h:67</div></div>
<div class="ttc" id="agroup___b_s_p___d_e_f_i_n_i_t_i_o_n_s_html_gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><div class="ttname"><a href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gafa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a></div><div class="ttdeci">#define MAX(a, b)</div><div class="ttdoc">Macro the maximum of two values.</div><div class="ttdef"><b>Definition:</b> sdk_defs.h:545</div></div>
<div class="ttc" id="agroup___m_i_d___r_t_o___o_s_a_l_html_gaf506bff5b51e8404ab109eb2a30c2682"><div class="ttname"><a href="group___m_i_d___r_t_o___o_s_a_l.html#gaf506bff5b51e8404ab109eb2a30c2682">OS_TASK_ARG_TYPE</a></div><div class="ttdeci">#define OS_TASK_ARG_TYPE</div><div class="ttdoc">Data type of OS task function (i.e. OS_TASK_FUNCTION) argument.</div><div class="ttdef"><b>Definition:</b> osal.h:214</div></div>
<div class="ttc" id="agroup___m_i_d___r_t_o___o_s_a_l_html_ga7be2de0540f21bc4b6b909fa672fb325"><div class="ttname"><a href="group___m_i_d___r_t_o___o_s_a_l.html#ga7be2de0540f21bc4b6b909fa672fb325">OS_EVENT_YIELD</a></div><div class="ttdeci">#define OS_EVENT_YIELD(higherPriorityTaskWoken)</div><div class="ttdoc">The running OS task yields control to the scheduler from ISR.</div><div class="ttdef"><b>Definition:</b> osal.h:1053</div></div>
<div class="ttc" id="agroup___m_i_d___r_t_o___o_s_a_l_html_ga5e0edee36263795a0a1f30658d4c8a3f"><div class="ttname"><a href="group___m_i_d___r_t_o___o_s_a_l.html#ga5e0edee36263795a0a1f30658d4c8a3f">OS_FALSE</a></div><div class="ttdeci">#define OS_FALSE</div><div class="ttdoc">Boolean False.</div><div class="ttdef"><b>Definition:</b> osal.h:173</div></div>
<div class="ttc" id="agroup___s_y_s_t_e_m___v_i_e_w_html_ga6157a4519e88c40dc4d3aa7b9893d160"><div class="ttname"><a href="group___s_y_s_t_e_m___v_i_e_w.html#ga6157a4519e88c40dc4d3aa7b9893d160">dg_configSYSTEMVIEW_STACK_OVERHEAD</a></div><div class="ttdeci">#define dg_configSYSTEMVIEW_STACK_OVERHEAD</div><div class="ttdoc">Stack size overhead when System View API is used.</div><div class="ttdef"><b>Definition:</b> bsp_debug.h:180</div></div>
<div class="ttc" id="agroup___m_i_d___r_t_o___o_s_a_l_html_gac79a0b5e1486e4b2af196fb0f61b511f"><div class="ttname"><a href="group___m_i_d___r_t_o___o_s_a_l.html#gac79a0b5e1486e4b2af196fb0f61b511f">OS_GET_STACK_WATERMARK</a></div><div class="ttdeci">#define OS_GET_STACK_WATERMARK(task)</div><div class="ttdoc">Get the high water mark of the stack associated with an OS task.</div><div class="ttdef"><b>Definition:</b> osal.h:1950</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:41 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
