<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SmartSnippets DA1470x SDK: Clock Manager Service</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1470x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Clock Manager Service<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___s_e_r_v_i_c_e_s.html">System Services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Clock Manager.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sys__clock__mgr_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__clock__mgr_8h.html">sys_clock_mgr.h</a></td></tr>
<tr class="memdesc:sys__clock__mgr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock Manager header file. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5809b1cb2bda0d94647cb3aedf7aa373"><td class="memItemLeft" align="right" valign="top"><a id="ga5809b1cb2bda0d94647cb3aedf7aa373"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a> </td></tr>
<tr class="memdesc:ga5809b1cb2bda0d94647cb3aedf7aa373"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYS_CLOCK_MGR error codes. <br /></td></tr>
<tr class="separator:ga5809b1cb2bda0d94647cb3aedf7aa373"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79">cm_sys_clk_init</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gad4e7df8e63e272869fcc340ece7b4d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize system clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79">More...</a><br /></td></tr>
<tr class="separator:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21be99e0948c369d31d53a5bd187dbd"><td class="memItemLeft" align="right" valign="top"><a id="gab21be99e0948c369d31d53a5bd187dbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab21be99e0948c369d31d53a5bd187dbd">cm_rcx_calibrate</a> (void)</td></tr>
<tr class="memdesc:gab21be99e0948c369d31d53a5bd187dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RCX. <br /></td></tr>
<tr class="separator:gab21be99e0948c369d31d53a5bd187dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0deec6c3c8fc0f44efeefca205c99b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50">cm_sys_clk_set</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:ga0deec6c3c8fc0f44efeefca205c99b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50">More...</a><br /></td></tr>
<tr class="separator:ga0deec6c3c8fc0f44efeefca205c99b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae838f7f275a650999c7b4dd4d6b6ee45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45">cm_sys_clk_set_priority</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> *sys_clk_prio_array)</td></tr>
<tr class="memdesc:gae838f7f275a650999c7b4dd4d6b6ee45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock priority.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45">More...</a><br /></td></tr>
<tr class="separator:gae838f7f275a650999c7b4dd4d6b6ee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2a634d09edb938c1e457cb34c0867d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d">cm_sys_clk_request</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gacd2a634d09edb938c1e457cb34c0867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request for system clock switch.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d">More...</a><br /></td></tr>
<tr class="separator:gacd2a634d09edb938c1e457cb34c0867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86645b23a9c3fb64f31dcf96c056a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf86645b23a9c3fb64f31dcf96c056a88">cm_sys_clk_release</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gaf86645b23a9c3fb64f31dcf96c056a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the system clock. It terminates a matching request.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf86645b23a9c3fb64f31dcf96c056a88">More...</a><br /></td></tr>
<tr class="separator:gaf86645b23a9c3fb64f31dcf96c056a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a489811442df40533f748695d6494d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7a489811442df40533f748695d6494d">cm_cpu_clk_set</a> (<a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> clk)</td></tr>
<tr class="memdesc:gae7a489811442df40533f748695d6494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7a489811442df40533f748695d6494d">More...</a><br /></td></tr>
<tr class="separator:gae7a489811442df40533f748695d6494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86825b725aa19f183a4876d8a42ccbef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga86825b725aa19f183a4876d8a42ccbef">cm_cpu_clk_set_fromISR</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> clk, <a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> hdiv)</td></tr>
<tr class="memdesc:ga86825b725aa19f183a4876d8a42ccbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU clock (interrupt safe version).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga86825b725aa19f183a4876d8a42ccbef">More...</a><br /></td></tr>
<tr class="separator:ga86825b725aa19f183a4876d8a42ccbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcdd32b50b8dc2f5b7801522fe365e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gabcdd32b50b8dc2f5b7801522fe365e3f">cm_apb_slow_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> div)</td></tr>
<tr class="memdesc:gabcdd32b50b8dc2f5b7801522fe365e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slow-pclk divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gabcdd32b50b8dc2f5b7801522fe365e3f">More...</a><br /></td></tr>
<tr class="separator:gabcdd32b50b8dc2f5b7801522fe365e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c7649939d439045d58fec27c4b48c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2">cm_apb_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> div)</td></tr>
<tr class="memdesc:gaa4c7649939d439045d58fec27c4b48c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pclk divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2">More...</a><br /></td></tr>
<tr class="separator:gaa4c7649939d439045d58fec27c4b48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b18ecfc74a372db8f75ba23c974126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126">cm_ahb_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> div)</td></tr>
<tr class="memdesc:ga44b18ecfc74a372db8f75ba23c974126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA High speed Bus (AHB) clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126">More...</a><br /></td></tr>
<tr class="separator:ga44b18ecfc74a372db8f75ba23c974126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec75427c454e4476752fa28d8147b47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e">cm_sys_clk_get</a> (void)</td></tr>
<tr class="memdesc:gaec75427c454e4476752fa28d8147b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sys_clk.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e">More...</a><br /></td></tr>
<tr class="separator:gaec75427c454e4476752fa28d8147b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e8b66a29249da4716fff22c4447307"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE <a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf0e8b66a29249da4716fff22c4447307">cm_sys_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:gaf0e8b66a29249da4716fff22c4447307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sys_clk (interrupt safe)  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf0e8b66a29249da4716fff22c4447307">More...</a><br /></td></tr>
<tr class="separator:gaf0e8b66a29249da4716fff22c4447307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cc79ea656e36d39c93c29df906be289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9cc79ea656e36d39c93c29df906be289">cm_apb_slow_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga9cc79ea656e36d39c93c29df906be289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get slow-pclk divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9cc79ea656e36d39c93c29df906be289">More...</a><br /></td></tr>
<tr class="separator:ga9cc79ea656e36d39c93c29df906be289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1c46e80c972a2214a394c62b9c60bc22">cm_apb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga1c46e80c972a2214a394c62b9c60bc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pclk divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1c46e80c972a2214a394c62b9c60bc22">More...</a><br /></td></tr>
<tr class="separator:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9">cm_ahb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hclk divider.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9">More...</a><br /></td></tr>
<tr class="separator:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c2817b0b31bec83ce2d4245766a300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga60c2817b0b31bec83ce2d4245766a300">cm_cpu_clk_get</a> (void)</td></tr>
<tr class="memdesc:ga60c2817b0b31bec83ce2d4245766a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga60c2817b0b31bec83ce2d4245766a300">More...</a><br /></td></tr>
<tr class="separator:ga60c2817b0b31bec83ce2d4245766a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9540456bdb05be3817c6e23babba9a"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE <a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gafb9540456bdb05be3817c6e23babba9a">cm_cpu_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:gafb9540456bdb05be3817c6e23babba9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU clock (interrupt safe version).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gafb9540456bdb05be3817c6e23babba9a">More...</a><br /></td></tr>
<tr class="separator:gafb9540456bdb05be3817c6e23babba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b96b631a34f1e2c30a9213f300d3798"><td class="memItemLeft" align="right" valign="top"><a id="ga8b96b631a34f1e2c30a9213f300d3798"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8b96b631a34f1e2c30a9213f300d3798">cm_calibrate_rc32k</a> (void)</td></tr>
<tr class="memdesc:ga8b96b631a34f1e2c30a9213f300d3798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RC32K. <br /></td></tr>
<tr class="separator:ga8b96b631a34f1e2c30a9213f300d3798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae884fa4c86df75b1cb87f591b9417e2b">cm_rcx_us_2_lpcycles</a> (uint32_t usec)</td></tr>
<tr class="memdesc:gae884fa4c86df75b1cb87f591b9417e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts usec to RCX cycles.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae884fa4c86df75b1cb87f591b9417e2b">More...</a><br /></td></tr>
<tr class="separator:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga64bbd9cd49b18ce46a71fa41ae287587">cm_rcx_us_2_lpcycles_low_acc</a> (uint32_t usec)</td></tr>
<tr class="memdesc:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts time to RCX cycles.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga64bbd9cd49b18ce46a71fa41ae287587">More...</a><br /></td></tr>
<tr class="separator:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga73baf5e403b2eb3f68f01a2d53d06260">cm_wait_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the fast Xtal clock has settled.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga73baf5e403b2eb3f68f01a2d53d06260">More...</a><br /></td></tr>
<tr class="separator:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8877669784653584dcbc4fb1ac0536"><td class="memItemLeft" align="right" valign="top"><a id="ga5b8877669784653584dcbc4fb1ac0536"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5b8877669784653584dcbc4fb1ac0536">cm_rcx_calibration_task_init</a> (void)</td></tr>
<tr class="memdesc:ga5b8877669784653584dcbc4fb1ac0536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the RCX calibration task. <br /></td></tr>
<tr class="separator:ga5b8877669784653584dcbc4fb1ac0536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535fddae4aadc649ce4c11c9bb43b0d1"><td class="memItemLeft" align="right" valign="top"><a id="ga535fddae4aadc649ce4c11c9bb43b0d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga535fddae4aadc649ce4c11c9bb43b0d1">cm_rcx_trigger_calibration</a> (void)</td></tr>
<tr class="memdesc:ga535fddae4aadc649ce4c11c9bb43b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger RCX calibration. <br /></td></tr>
<tr class="separator:ga535fddae4aadc649ce4c11c9bb43b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9857796532a9d4e64156b009bd82fee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9857796532a9d4e64156b009bd82fee2">cm_lp_clk_init</a> (void)</td></tr>
<tr class="memdesc:ga9857796532a9d4e64156b009bd82fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Low Power clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9857796532a9d4e64156b009bd82fee2">More...</a><br /></td></tr>
<tr class="separator:ga9857796532a9d4e64156b009bd82fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9cd5a730fa9e64f14ff69ceec56f72e"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab9cd5a730fa9e64f14ff69ceec56f72e">cm_lp_clk_is_avail</a> (void)</td></tr>
<tr class="memdesc:gab9cd5a730fa9e64f14ff69ceec56f72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab9cd5a730fa9e64f14ff69ceec56f72e">More...</a><br /></td></tr>
<tr class="separator:gab9cd5a730fa9e64f14ff69ceec56f72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1fededcf7c044045f8499081bb21187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad1fededcf7c044045f8499081bb21187">cm_lp_clk_is_avail_fromISR</a> (void)</td></tr>
<tr class="memdesc:gad1fededcf7c044045f8499081bb21187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available (interrupt safe version).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad1fededcf7c044045f8499081bb21187">More...</a><br /></td></tr>
<tr class="separator:gad1fededcf7c044045f8499081bb21187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga6dcfa191a663cbc9e2998e79cbc7b68e">cm_wait_lp_clk_ready</a> (void)</td></tr>
<tr class="memdesc:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the Low Power clock is available.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga6dcfa191a663cbc9e2998e79cbc7b68e">More...</a><br /></td></tr>
<tr class="separator:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3698bba6a0d9239d858dd3594997f8"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7f3698bba6a0d9239d858dd3594997f8">cm_lp_clk_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga7f3698bba6a0d9239d858dd3594997f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the flag that indicates that the Low Power clock is available.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7f3698bba6a0d9239d858dd3594997f8">More...</a><br /></td></tr>
<tr class="separator:ga7f3698bba6a0d9239d858dd3594997f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95526e50703ab838153d26e353f36c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga95526e50703ab838153d26e353f36c4b">cm_wait_pll_lock</a> (void)</td></tr>
<tr class="memdesc:ga95526e50703ab838153d26e353f36c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the PLL is locked. If the PLL is locked then the function exits immediately.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga95526e50703ab838153d26e353f36c4b">More...</a><br /></td></tr>
<tr class="separator:ga95526e50703ab838153d26e353f36c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba413ed32c21bd011825078ea924377"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaaba413ed32c21bd011825078ea924377">cm_poll_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:gaaba413ed32c21bd011825078ea924377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the fast Xtal clock is ready.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaaba413ed32c21bd011825078ea924377">More...</a><br /></td></tr>
<tr class="separator:gaaba413ed32c21bd011825078ea924377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42130a961bf048df25f60247d52c5c2"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae42130a961bf048df25f60247d52c5c2">cm_enable_xtalm</a> (void)</td></tr>
<tr class="memdesc:gae42130a961bf048df25f60247d52c5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the fast Xtal clock.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae42130a961bf048df25f60247d52c5c2">More...</a><br /></td></tr>
<tr class="separator:gae42130a961bf048df25f60247d52c5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b5e56bfe97a614a994c39807b7f979"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga31b5e56bfe97a614a994c39807b7f979">cm_sys_clk_sleep</a> (bool entering_sleep)</td></tr>
<tr class="memdesc:ga31b5e56bfe97a614a994c39807b7f979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock (unprotected).  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga31b5e56bfe97a614a994c39807b7f979">More...</a><br /></td></tr>
<tr class="separator:ga31b5e56bfe97a614a994c39807b7f979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b5c93661da300c5277ae9fb2429cd5"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga17b5c93661da300c5277ae9fb2429cd5">cm_halt_until_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:ga17b5c93661da300c5277ae9fb2429cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until the fast Xtal clock has settled.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga17b5c93661da300c5277ae9fb2429cd5">More...</a><br /></td></tr>
<tr class="separator:ga17b5c93661da300c5277ae9fb2429cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56ed15acc5f7574a4ef86dea5840326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab56ed15acc5f7574a4ef86dea5840326">cm_register_xtal_ready_callback</a> (void(*cb)(void))</td></tr>
<tr class="memdesc:gab56ed15acc5f7574a4ef86dea5840326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function to be called when the fast Xtal clock settles.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab56ed15acc5f7574a4ef86dea5840326">More...</a><br /></td></tr>
<tr class="separator:gab56ed15acc5f7574a4ef86dea5840326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d0724f1e68b8a52d62c1171c24ebea8"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga4d0724f1e68b8a52d62c1171c24ebea8">cm_halt_until_pll_locked</a> (void)</td></tr>
<tr class="memdesc:ga4d0724f1e68b8a52d62c1171c24ebea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until PLL is locked.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga4d0724f1e68b8a52d62c1171c24ebea8">More...</a><br /></td></tr>
<tr class="separator:ga4d0724f1e68b8a52d62c1171c24ebea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661682b3995c84cc5868142896f6fd63"><td class="memItemLeft" align="right" valign="top">__RETAINED_HOT_CODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga661682b3995c84cc5868142896f6fd63">cm_halt_until_sysclk_ready</a> (void)</td></tr>
<tr class="memdesc:ga661682b3995c84cc5868142896f6fd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until system clock (either PLL or XTAL32M) is ready.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga661682b3995c84cc5868142896f6fd63">More...</a><br /></td></tr>
<tr class="separator:ga661682b3995c84cc5868142896f6fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212df5cb9b95fa019fbe90e3ffebcde5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga212df5cb9b95fa019fbe90e3ffebcde5">cm_halt_until_pll_usb_locked</a> (void)</td></tr>
<tr class="memdesc:ga212df5cb9b95fa019fbe90e3ffebcde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until USB PLL is locked.  <a href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga212df5cb9b95fa019fbe90e3ffebcde5">More...</a><br /></td></tr>
<tr class="separator:ga212df5cb9b95fa019fbe90e3ffebcde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5bbaed272d0e1dc7a9c65b79e3e88b"><td class="memItemLeft" align="right" valign="top"><a id="gaaf5bbaed272d0e1dc7a9c65b79e3e88b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaaf5bbaed272d0e1dc7a9c65b79e3e88b">cm_sys_enable_pll_usb</a> (void)</td></tr>
<tr class="memdesc:gaaf5bbaed272d0e1dc7a9c65b79e3e88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable USB PLL. <br /></td></tr>
<tr class="separator:gaaf5bbaed272d0e1dc7a9c65b79e3e88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8219dd40eb66164dfe62490f4b499e17"><td class="memItemLeft" align="right" valign="top"><a id="ga8219dd40eb66164dfe62490f4b499e17"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8219dd40eb66164dfe62490f4b499e17">cm_sys_disable_pll_usb</a> (void)</td></tr>
<tr class="memdesc:ga8219dd40eb66164dfe62490f4b499e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable USB PLL. <br /></td></tr>
<tr class="separator:ga8219dd40eb66164dfe62490f4b499e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110d4400b5cf8cc539a5897ca66d9838"><td class="memItemLeft" align="right" valign="top"><a id="ga110d4400b5cf8cc539a5897ca66d9838"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga110d4400b5cf8cc539a5897ca66d9838">cm_rchs_calibrate</a> (void)</td></tr>
<tr class="memdesc:ga110d4400b5cf8cc539a5897ca66d9838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RCHS. <br /></td></tr>
<tr class="separator:ga110d4400b5cf8cc539a5897ca66d9838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Clock Manager. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga462965cf64536f7d5d6f9c72b5f3e4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462965cf64536f7d5d6f9c72b5f3e4e9">&#9670;&nbsp;</a></span>cm_ahb_get_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> cm_ahb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hclk divider. </p>
<p>Returns the current setting of the AMBA High speed Bus clock (hclk) divider.</p>
<dl class="section return"><dt>Returns</dt><dd>The hclk divider being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="ga44b18ecfc74a372db8f75ba23c974126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b18ecfc74a372db8f75ba23c974126">&#9670;&nbsp;</a></span>cm_ahb_set_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_ahb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA High speed Bus (AHB) clock. </p>
<p>The frequency of the AHB clock is (system_clock / (1 &lt;&lt; div)). Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will be aborted or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the AHB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the divider was changed to the requested value, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="ga1c46e80c972a2214a394c62b9c60bc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c46e80c972a2214a394c62b9c60bc22">&#9670;&nbsp;</a></span>cm_apb_get_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> cm_apb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pclk divider. </p>
<p>Returns the current setting of the AMBA Fast Peripheral Bus clock (pclk) divider.</p>
<dl class="section return"><dt>Returns</dt><dd>The (fast) pclk divider being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="gaa4c7649939d439045d58fec27c4b48c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c7649939d439045d58fec27c4b48c2">&#9670;&nbsp;</a></span>cm_apb_set_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_apb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set pclk divider. </p>
<p>Changes the setting of the AMBA Fast Peripheral Bus clock (pclk) divider. The frequency of the pclk is (system_clock / (1 &lt;&lt; hclk_div)) / (1 &lt;&lt; div).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new pclk divider setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="ga9cc79ea656e36d39c93c29df906be289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cc79ea656e36d39c93c29df906be289">&#9670;&nbsp;</a></span>cm_apb_slow_get_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> cm_apb_slow_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get slow-pclk divider. </p>
<p>Returns the current setting of the AMBA Slow Peripheral Bus clock (slow-pclk) divider.</p>
<dl class="section return"><dt>Returns</dt><dd>The slow-pclk divider being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="gabcdd32b50b8dc2f5b7801522fe365e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcdd32b50b8dc2f5b7801522fe365e3f">&#9670;&nbsp;</a></span>cm_apb_slow_set_clock_divider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_apb_slow_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slow-pclk divider. </p>
<p>Changes the setting of the AMBA Slow Peripheral Bus clock (slow-pclk) divider. The frequency of the slow-pclk is (DivN / (1 &lt;&lt; div)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new slow-pclk divider setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="ga60c2817b0b31bec83ce2d4245766a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60c2817b0b31bec83ce2d4245766a300">&#9670;&nbsp;</a></span>cm_cpu_clk_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU clock. </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="gafb9540456bdb05be3817c6e23babba9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb9540456bdb05be3817c6e23babba9a">&#9670;&nbsp;</a></span>cm_cpu_clk_get_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE <a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU clock (interrupt safe version). </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gae7a489811442df40533f748695d6494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a489811442df40533f748695d6494d">&#9670;&nbsp;</a></span>cm_cpu_clk_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_cpu_clk_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td>
          <td class="paramname"><em>clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU clock. </p>
<p>It attempts to achieve a specific CPU clock frequency by applying the proper settings for the system clock (sys_clk) and the AMBA High speed bus (AHB) divider. (The ARM CPU runs using the AHB clock.) If the requested frequency is not achievable with any sys_clk, it returns false. It will also return false in case PLL160 is in use and the requested frequency is only achievable with a different sys_clk setting.</p>
<p>If the requested frequency requires enabling the fast Xtal clock (XTAL32M), then, apart from powering on XTAL32M, the function will wait for it to settle before setting it as sys_clk. If it also requires using the PLL as sys_clk, then the function, will also wait for it to lock.</p>
<p>The Clock Manager will also take care of restoring the last-requested CPU clock frequency (unless implicitly changed using <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a>) to the type set by this function after each wake-up, automatically, as soon as XTAL32M (and PLL) settles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>The CPU clock frequency (in MHz).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested clock switch was applied, else false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In case there are more than one possible ways to achieve the specified CPU frequency, the function tries to preserve the current sys_clk setting if possible, otherwise:<ul>
<li>If XTAL32M is currently being used (i.e. currently selected clock is XTAL32M or PLL160M) it tries to make use of it.</li>
<li>If it is not currently being used (i.e. the currently selected clock is the high speed RC (RCHS)), it tries to avoid using it (and continue using RCHS).</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the requested frequency implies switching to PLL160, the function will do so but (unlike the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a> function) this will not affect (i.e. it will not protect PLL160 from) any future <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a> or <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7a489811442df40533f748695d6494d" title="Set the CPU clock.">cm_cpu_clk_set()</a> calls requesting sys_clk settings other than PLL160 (by the same or other task)!</dd>
<dd>
Similarly, in case of making use of the cm_sys_clk_request/release() mechanism, this function takes into account any existing active sys_clk requests before switching to the appropriate sys_clk but it does not also affect the existing requests (it does not constitute a request by itself).</dd>
<dd>
It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="ga86825b725aa19f183a4876d8a42ccbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86825b725aa19f183a4876d8a42ccbef">&#9670;&nbsp;</a></span>cm_cpu_clk_set_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_cpu_clk_set_fromISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>hdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU clock (interrupt safe version). </p>
<p>It sets the system clock (sys_clk) and the AMBA High speed bus (AHB) divider to the requested values. So, in fact, since The ARM CPU runs using the AHB clock, it implicitly sets the CPU clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>The clock source to use as sys_clk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdiv</td><td>The divider of the AHB clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must only be called from Interrupt Context and/or with all interrupts disabled.</dd>
<dd>
The caller must have checked that the current sys_clk is not the desired one before calling this function. </dd></dl>

</div>
</div>
<a id="gae42130a961bf048df25f60247d52c5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42130a961bf048df25f60247d52c5c2">&#9670;&nbsp;</a></span>cm_enable_xtalm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_enable_xtalm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the fast Xtal clock. </p>
<p>Checks if the fast Xtal clock (XTAL32M) is started. If not, it checks if there is a PDC entry for starting XTAL32M and if there is, it uses PDC to start it. Otherwise, it enables it using <a class="el" href="group___h_w___c_l_k.html#ga2fc015f080bb3c75682d74591b2611ee" title="Activate a System clock.">hw_clk_enable_sysclk()</a>. </p>

</div>
</div>
<a id="ga4d0724f1e68b8a52d62c1171c24ebea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d0724f1e68b8a52d62c1171c24ebea8">&#9670;&nbsp;</a></span>cm_halt_until_pll_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_halt_until_pll_locked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until PLL is locked. </p>
<p>It executes a WFI() call waiting for the PLL Lοck interrupt. Any other interrupts that hit are served. </p>

</div>
</div>
<a id="ga212df5cb9b95fa019fbe90e3ffebcde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212df5cb9b95fa019fbe90e3ffebcde5">&#9670;&nbsp;</a></span>cm_halt_until_pll_usb_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_halt_until_pll_usb_locked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until USB PLL is locked. </p>
<p>It executes a WFI() call waiting for the PLL48_LOCK_IRQn. </p>

</div>
</div>
<a id="ga661682b3995c84cc5868142896f6fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga661682b3995c84cc5868142896f6fd63">&#9670;&nbsp;</a></span>cm_halt_until_sysclk_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_halt_until_sysclk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until system clock (either PLL or XTAL32M) is ready. </p>
<p>It executes a WFI() call waiting for the XTAL32M Ready interrupt and PLL LOCK interrupt if needed. Any other interrupts that hit are served. </p>

</div>
</div>
<a id="ga17b5c93661da300c5277ae9fb2429cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17b5c93661da300c5277ae9fb2429cd5">&#9670;&nbsp;</a></span>cm_halt_until_xtalm_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_halt_until_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until the fast Xtal clock has settled. </p>
<p>It executes a WFI() call waiting for the fast Xtal clock Ready interrupt. Any other interrupts that hit are served. </p>

</div>
</div>
<a id="ga9857796532a9d4e64156b009bd82fee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9857796532a9d4e64156b009bd82fee2">&#9670;&nbsp;</a></span>cm_lp_clk_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lp_clk_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Low Power clock. </p>
<dl class="section note"><dt>Note</dt><dd>Since the XTAL32K settling takes a long time, the function does not block waiting for XTAL32K to settle. However, the system is kept in active mode until this completes.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As for most other functions of the Clock Manager, it should not be called before <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize system clock.">cm_sys_clk_init()</a>.</dd>
<dd>
It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gab9cd5a730fa9e64f14ff69ceec56f72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9cd5a730fa9e64f14ff69ceec56f72e">&#9670;&nbsp;</a></span>cm_lp_clk_is_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE bool cm_lp_clk_is_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="gad1fededcf7c044045f8499081bb21187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1fededcf7c044045f8499081bb21187">&#9670;&nbsp;</a></span>cm_lp_clk_is_avail_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool cm_lp_clk_is_avail_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available (interrupt safe version). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga7f3698bba6a0d9239d858dd3594997f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f3698bba6a0d9239d858dd3594997f8">&#9670;&nbsp;</a></span>cm_lp_clk_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_lp_clk_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the flag that indicates that the Low Power clock is available. </p>
<p>It is called when the system wakes up from a "forced" deep sleep state and the low power XTAL (XTAL32K) is used as the Low Power clock so that the system won't enter sleep until XTAL32K has settled.</p>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="gaaba413ed32c21bd011825078ea924377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaba413ed32c21bd011825078ea924377">&#9670;&nbsp;</a></span>cm_poll_xtalm_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE bool cm_poll_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the fast Xtal clock is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the fast Xtal clock has settled, else false. </dd></dl>

</div>
</div>
<a id="gae884fa4c86df75b1cb87f591b9417e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae884fa4c86df75b1cb87f591b9417e2b">&#9670;&nbsp;</a></span>cm_rcx_us_2_lpcycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t cm_rcx_us_2_lpcycles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts usec to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Maximum time period is 4.095msec. </dd></dl>

</div>
</div>
<a id="ga64bbd9cd49b18ce46a71fa41ae287587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64bbd9cd49b18ce46a71fa41ae287587">&#9670;&nbsp;</a></span>cm_rcx_us_2_lpcycles_low_acc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cm_rcx_us_2_lpcycles_low_acc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts time to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a low accuracy function. To have good accuracy, the minimum time period should be 1msec and the maximum 200msec. Above 200msec, the function calculates more RCX cycles than necessary. </dd></dl>

</div>
</div>
<a id="gab56ed15acc5f7574a4ef86dea5840326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56ed15acc5f7574a4ef86dea5840326">&#9670;&nbsp;</a></span>cm_register_xtal_ready_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_register_xtal_ready_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback function to be called when the fast Xtal clock settles. </p>
<p>cb pointer to the callback function </p>

</div>
</div>
<a id="gaec75427c454e4476752fa28d8147b47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec75427c454e4476752fa28d8147b47e">&#9670;&nbsp;</a></span>cm_sys_clk_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get sys_clk. </p>
<p>Returns that system clock (sys_clk) that the system uses at that moment.</p>
<dl class="section return"><dt>Returns</dt><dd>: The real sys_clk used by the system.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="gaf0e8b66a29249da4716fff22c4447307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e8b66a29249da4716fff22c4447307">&#9670;&nbsp;</a></span>cm_sys_clk_get_fromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE <a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get sys_clk (interrupt safe) </p>
<p>Returns the system clock (sys_clk) that the system uses at that moment (interrupt safe version).</p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system. </dd></dl>

</div>
</div>
<a id="gad4e7df8e63e272869fcc340ece7b4d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e7df8e63e272869fcc340ece7b4d79">&#9670;&nbsp;</a></span>cm_sys_clk_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize system clock. </p>
<p>It initializes the Clock Manager and sets the system clock (sys_clk) to the (initially) preferred clock source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as sys_clk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The sys_clk can be changed later by calling <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It has to be called only once, after power-up and before calling most other functions of the Clock Manager (since it initializes the internal data used by them).</dd>
<dd>
It must be called with interrupts enabled!</dd>
<dd>
If case of selecting PLL as sys_clk, then any attempt to switch to another sys_clk later using <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a> will fail (i.e. will return cm_sysclk_pll_used_by_task)! Therefore, in case of intending to use PLL only temporarily, a different sys_clk should first be chosen with <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize system clock.">cm_sys_clk_init()</a> and the switch to PLL must be done at a later step, when needed, using the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a> function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a> </dd></dl>

</div>
</div>
<a id="gaf86645b23a9c3fb64f31dcf96c056a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86645b23a9c3fb64f31dcf96c056a88">&#9670;&nbsp;</a></span>cm_sys_clk_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a> cm_sys_clk_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the system clock. It terminates a matching request. </p>
<p>If there are other sys_clk requests that are still active (i.e. not released), the system will switch to the one that has the highest priority. Otherwise, it will switch to the initial sys_clk that was specified when <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize system clock.">cm_sys_clk_init()</a> was called. No change however will be made if Div1 is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source the system was requested to use, when the matching <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d" title="Request for system clock switch.">cm_sys_clk_request()</a> was called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cm_sysclk_success: the release operation was completed successfully and either triggered a switch to a lower_priority sys_clk or did not trigger any sys_clk_change (either because there are still other active requests for the same sys_clk that have not been released yet or because there are no other active requests and the released sys_clk is also the default one (as specified in <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize system clock.">cm_sys_clk_init()</a>)) </dd>
<dd>
cm_sysclk_div1_clk_in_use: the release operation was completed successfully and it should normally trigger a new sys_clk change (based on other active requests) but it didn't because a peripheral is clocked by the Div1 clock</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called ONLY for terminating a matching cm_sys_clk_request. If called alone the system will reach an error-state!</dd>
<dd>
It cannot be called from Interrupt Context.</dd>
<dd>
It may block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d" title="Request for system clock switch.">cm_sys_clk_request</a> </dd></dl>

</div>
</div>
<a id="gacd2a634d09edb938c1e457cb34c0867d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd2a634d09edb938c1e457cb34c0867d">&#9670;&nbsp;</a></span>cm_sys_clk_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a> cm_sys_clk_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request for system clock switch. </p>
<p>This function can be used for system clock switching instead of <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a>. It requests from the Clock Manager to use a specific clock source as system clock (sys_clk). If this is possible, the request is accepted and the function switches the sys_clk setting to the selected clock source and returns cm_sysclk_success. Otherwise, the request is rejected and the function returns a value that denotes the reason why the switch was not possible.</p>
<p>The request can be cancelled/released later by calling <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf86645b23a9c3fb64f31dcf96c056a88" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a>. Until then, the requested sys_clk is protected from any lower priority sys_clk requests (with the priority as defined by <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a>).</p>
<p>There are two reasons that make switching the system clock not possible. Either if there is at least one peripheral that currently uses the Div1 clock, or if the current system clock has higher priority and is currently in use. In the latter case, in order for the switch to be successful a release operation should execute first.</p>
<p>If the request involves enabling the fast Xtal clock (XTAL32M), then, apart from powering on the XTAL32M, the function will wait for it to settle before setting it as sys_clk. If the PLL is requested, the function will also wait for the PLL to lock.</p>
<p>The Clock Manager will also take care of automatically restoring the sys_clk to the requested setting after each wake-up (as soon as the XTAL32M settles (and the PLL locks), if used).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as sys_clk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cm_sysclk_success: if the requested sys_clk switch was applied </dd>
<dd>
cm_sysclk_div1_clk_in_use: if the sys_clk cannot be switched because a peripheral is clocked by the Div1 clock </dd>
<dd>
cm_sysclk_higher_prio_used: if a higher priority system clock is still in use</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires that <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a> has been called in advance.</dd>
<dd>
Even if the request is rejected, it is still taken into account (until cancelled by a corresponding <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf86645b23a9c3fb64f31dcf96c056a88" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a> call), and the switch to the requested clock may take place later (e.g. as soon as the existing higher priority clock requests are released).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a> </dd>
<dd>
<a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf86645b23a9c3fb64f31dcf96c056a88" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a> </dd></dl>

</div>
</div>
<a id="ga0deec6c3c8fc0f44efeefca205c99b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0deec6c3c8fc0f44efeefca205c99b50">&#9670;&nbsp;</a></span>cm_sys_clk_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5809b1cb2bda0d94647cb3aedf7aa373">cm_sys_clk_set_status_t</a> cm_sys_clk_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock. </p>
<p>This function requests from the Clock Manager to use a specific clock source as system clock (sys_clk). If this is possible, the request is accepted and the function switches the sys_clk setting to the selected clock source and returns cm_sysclk_success. Otherwise, the request is rejected and the function returns a value that denotes the reason why the switch was not possible.</p>
<p>If the request involves enabling the fast Xtal clock (XTAL32M), then, apart from powering on the XTAL32M, the function will wait for it to settle before setting it as sys_clk. If the PLL is requested, the function will also wait for the PLL to lock.</p>
<p>The Clock Manager will also take care of automatically restoring the sys_clk to the requested setting after each wake-up (as soon as the XTAL32M settles (and the PLL locks), if used).</p>
<p>If a switch to PLL is performed, the Clock Manager retains the PLL as sys_clk until it is not needed anymore. This is more specifically done on the following scheme: A successful PLL request is noted down by the Clock Manager and is considered "active" until it is "invalidated". A request for a different clock source - regardless if it is eventually accepted or rejected - invalidates the latest successful PLL request* (if any). If after this (i.e. the invalidation), there still is at least one active PLL request, then the new request (i.e. the non-PLL one) is rejected (the function returns cm_sysclk_pll_used_by_task) and the PLL is retained as sys_clk. Otherwise, the new request is accepted and the function changes the sys_clk and returns cm_sys_clk_success.</p>
<p>*If OS_PRESENT, it invalidates only the latest successful PLL request that was made by the same task.</p>
<p>On top of the above, if there is at least one peripheral that currently uses the Div1 clock, the function rejects any request for a sys_clk setting other than the current one. If the dg_configABORT_IF_SYSTICK_CLK_ERR setting is enabled, the same also applies for the case the SysTick timer is running. In such cases, the function returns cm_sysclk_div1_clk_in_use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as sys_clk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cm_sysclk_success: if the requested sys_clk switch was applied </dd>
<dd>
cm_sysclk_div1_clk_in_use: if the sys_clk cannot be switched because a peripheral is clocked by the Div1 clock </dd>
<dd>
cm_sysclk_pll_used_by_task: if the PLL is still needed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function provides protection only for the PLL clock. In order to have protection also for the other available sys_clk options based on a certain desired sys_clk priority scheme, it is recommended to use the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae838f7f275a650999c7b4dd4d6b6ee45" title="Set the system clock priority.">cm_sys_clk_set_priority()</a>, <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d" title="Request for system clock switch.">cm_sys_clk_request()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf86645b23a9c3fb64f31dcf96c056a88" title="Restores the system clock. It terminates a matching request.">cm_sys_clk_release()</a> functions instead.</dd>
<dd>
It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="gae838f7f275a650999c7b4dd4d6b6ee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae838f7f275a650999c7b4dd4d6b6ee45">&#9670;&nbsp;</a></span>cm_sys_clk_set_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_set_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> *&#160;</td>
          <td class="paramname"><em>sys_clk_prio_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock priority. </p>
<p>The system clock priority indicates which sys_clk prevails against another one when requesting a new sys_clk using <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d" title="Request for system clock switch.">cm_sys_clk_request()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk_prio_array</td><td>pointer to array containing the system clock priority (in decreasing order)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If called, the Clock Manager considers <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d" title="Request for system clock switch.">cm_sys_clk_request()</a> to be used for any possible future system clock switching (instead of <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock.">cm_sys_clk_set()</a>).</dd>
<dd>
The provided array is expected to hold the first five members of the sys_clk_t enum in the order that denotes the desired priority scheme, with each type appearing only once in the array and the first element denoting the highest priority sys_clk. In case the array contains more elements, only the first five ones are taken into account.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If dg_configENABLE_RCHS_CALIBRATION is set to 1, the priorities of all RCHS clock types must be lower than the one of XTAL32M.</dd>
<dd>
It has to be called only once, after power-up and before calling <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79" title="Initialize system clock.">cm_sys_clk_init()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gacd2a634d09edb938c1e457cb34c0867d" title="Request for system clock switch.">cm_sys_clk_request()</a> </dd></dl>

</div>
</div>
<a id="ga31b5e56bfe97a614a994c39807b7f979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b5e56bfe97a614a994c39807b7f979">&#9670;&nbsp;</a></span>cm_sys_clk_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__RETAINED_HOT_CODE void cm_sys_clk_sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>entering_sleep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock (unprotected). </p>
<p>It attempts to:</p><ul>
<li>Prepare the system clock for sleep: called when the system is entering power-down mode. The system clock settings of the application are kept in order to be able to restore them. If the PLL is active it will be turned off. (It is called with the scheduler stopped and all interrupts disabled in this case.)</li>
<li>Restore the previous setting: called when the fast Xtal clock settles. (It is called from ISR context with all interrupts disabled in this case.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entering_sleep</td><td>true if the system is going to sleep, else false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context and/or with all interrupts disabled.</dd>
<dd>
The function is internal to the clock and power managers and should not be used externally! </dd></dl>

</div>
</div>
<a id="ga6dcfa191a663cbc9e2998e79cbc7b68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcfa191a663cbc9e2998e79cbc7b68e">&#9670;&nbsp;</a></span>cm_wait_lp_clk_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_lp_clk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the Low Power clock is available. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a id="ga95526e50703ab838153d26e353f36c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95526e50703ab838153d26e353f36c4b">&#9670;&nbsp;</a></span>cm_wait_pll_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_pll_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the PLL is locked. If the PLL is locked then the function exits immediately. </p>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
It may block. </dd></dl>

</div>
</div>
<a id="ga73baf5e403b2eb3f68f01a2d53d06260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73baf5e403b2eb3f68f01a2d53d06260">&#9670;&nbsp;</a></span>cm_wait_xtalm_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the fast Xtal clock has settled. </p>
<dl class="section warning"><dt>Warning</dt><dd>It cannot be called from Interrupt Context.</dd>
<dd>
If may block. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 13:50:42 for SmartSnippets DA1470x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
